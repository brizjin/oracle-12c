        1. Компиляция операций и представлений.

1.1. Разъяснение по поводу версии ТЯ 6.1.Х и выше и Oracle9i. Версия
ТЯ 6.1 декларируется как совместимая с версией Oracle9i. Расширения
PL/SQL и SQL версии 9i реализованы в PL/Plus практически в полном
объеме, однако реализованы также и некоторые ограничения, сопутствующие
Oracle9i. В частности, - это более строгая проверка спецификаций
функций и процедур в глобальных и локальных описаниях (пакете и теле
пакета - если апеллировать к понятиям Oracle). Версия ТЯ при генерации
текста пакетов не контролирует версию Oracle, поэтому некоторые
конструкции (например, вложенные PL/SQL таблицы или таблицы PL/SQL
структур с вложенными подструктурами и другими PL/SQL таблицами,
bulk выборка в таблицу PL/SQL структур), корректные для Oracle9i,
будут приводить к ошибкам в теле пакетов PL/SQL для версии Oracle8i.
Также можно отметить, что в версии Oracle8i SQL-выражения, используемые
в PL/SQL, ориентированы на SQL-синтаксис Oracle7 и в них нельзя
использовать синтаксис, разрешенный в непосредственном SQL (в
частности, это подзапросы в выборках и case выражения), так что
такой синтаксис в версии Oracle8i может использоваться только
для генерации текста представлений.

1.2. Информация по статусам операций:
    VALID/VALID - PL/PLUS ok, пакет ok.
    VALID/INVALID - PL/PLUS ok. Пакет стал инвалидным в результате
        изменения объекта, от которого он зависит (например, другого
        пакета), как правило, ошибок не содержит и становится_
        валидным при первом обращении к нему на исполнение.
    PROCESSED/??? - PL/PLUS ok. Пакет инвалидный и, как правило,
        содержит ошибки. Ошибки могут быть вызваны следующими
        причинами :
        1. Кривизна данных - объекты, на которые ссылается пакет,
           отсутствуют или инвалидны, однако в словаре системы они
           описаны как нормальные, то есть потеряна целостность.
           Могут быть также невалидны используемые в операции
           db-линки на момент компиляции. То же может происходить
           при изменениях ядра системы в обход декларированных процедур
           (удаление или изменение системных пакетов и таблиц, которые
           не отражены в словаре).
        2. Ошибки внутри PL/SQL вставок в операции.
        3. Ошибка в тексте операции, где недостаточно скрупулезно
           проверена семантика препроцессором (так как некоторые
           семантические проверки препроцессором PL/Plus не
           выполняются, их анализ делегирован препроцессору PL/SQL),
           либо используется версия Oracle, которая не поддерживает
           все семантические конструкции, доступные в PL/Plus (см п.1).
        4. Пакет PL/SQL может быть валидным и не содержать ошибок,
           тогда состояние PROCESSED указывает на то, что при
           пересоздании пакета после обработки препроцессором PL/Plus
           пакет пересоздан не был - в результате ошибки Oracle в процессе
           компиляции. Ошибка компиляции в таком случае записывается
           в Журнал изменения операций. Наиболее часто встречаемые
           причины ошибок компиляции:
           - пакет операции был заблокирован другим пользователем
             (либо активной сессией, использующей пакет, либо также
             перекомпиляцией),
           - нехватка места в системном табличном пространстве SYSTEM,
           - используемые операцией удаленные объекты (через dblink)
             не могли быть разобраны по причине невозможности установления
             соединения через dblink во время компиляции.
    NOT COMPILED/??? - Операция либо только создана и ни разу не
           была откомпилирована, либо на этапе ее компиляции
           произошло исключение препроцессора (это может произойти
           из-за ошибок в тексте PL/PLUS, которые вызывают исключения
           препроцессора, например, когда отдельные конструкции текста
           операции или сгенеренный текст таких конструкций слишком велик
           и не умещается во внутренние строковые буфера, ограниченные
           размером в 32к - максимальный размер строки PL/SQL).
    INVALID/??? - Операция содержит ошибки в тексте PL/PLUS.
    UPDATED/??? - Операция была изменена (или были изменены объекты,
           на которые она ссылается) в результате регламентированных
           изменений в словаре системы. Такие операции следует
           перекомпилировать, так как даже при валидном пакете
           операция может работать неправильно.

1.3. Порядок распознавания препроцессором PL/Plus идентификаторов :
  а) в выражениях:
    1) Идентификаторы переменных (в т.ч. процедуры и функции),
       например ID_VAR. Возврат на 1) для поиска полей найденной
       переменной, либо реквизитов и операций по ссылке.
    2) Имена декларированных системных пакетов и процедур (RTL,
       STANDARD,STDIO и т.п.). Прямая идентификация возможна с
       помощью префикса '::', например ::RTL.DEBUG, ::STDIO.PUT_LINE;
       В режиме расширенного синтаксиса этот пункт дополняется
       поиском всех PL/SQL пакетов владельца схемы IBSO.
       Возврат на 1) - поиск глобальных переменных, функций и процедур
       пакета с выбором подходящего вызова методом подбора по типу
       фактических параметров в случае перекрытых функций и процедур
       (подробнее п.1.10). Следует также отметить, что при включении
       расширенного синтаксиса количество включенных в поиск
       идентификаторов объектов резко увеличивается, что, во-первых,
       увеличивает время компиляции (т.к. поиск ведется по словарю
       Oracle, который очень медленный), а, во-вторых, повышает
       вероятность ошибки в случае конфликта имен пакетов и имен
       реквизитов/операций/типов, т.е. в такой ситуации алгоритм
       поиска будет использовать имя пакета и к пп. 3)-4)-5) просто
       не перейдет.
    3) Имена реквизитов текущего типа, прямая идентификация_
       возможна через заключение имени реквизита в квадратные
       скобки, например [ATTR_ID]. Возврат на 3) - поиск реквизитов
       [ATTR_ID].
    4) Имена операций текущего типа, идентификация такая же,
       как и для реквизитов, поэтому имена реквизитов и операций
       не могут совпадать в одном типе, пример - [EDIT#AUTO].
       Возврат на 1) - поиск глобальных переменных, функций и процедур
       операции.
    5) Имена типов. Прямая идентификация возможна с помощью
       префикса '::' и квадратных скобок, пример ::[SYSTEM].
       Возврат на 3) - поиск реквизитов и операций нового типа.
    6) Поиск операций типа RUNTIME - возврат на 3).
    7) Ошибка поиска - PLP-NOT_CLASS_COMPONENT.
  б) при описании типов переменных, полей структур, возвращаемых значений функций:
    1) если описание указано только одним идентификатором, то ищутся
       1.1) Идентификаторы пользовательских типов текущей операции.
       1.2) Имена типов словаря данных. Прямая идентификация возможна
            возможна через заключение имени типа в квадратные скобки.
    2) Если в 1) ничего не найдено, то описание типа интерпретируется
       как выражение и используется алгоритм в а), при этом в поиск
       декларированных системных пакетов и процедур включаются также
       глобальные типы этих пакетов, при этом указание фактических
       параметров вызовов функций не допустимо. Результирующим типом
       является тип заданного выражения.
Если при описании типов в б) используется модификатор %type, то
это предписывает препроцессору сразу использовать тип выражения,
к которому применен %type (т.е. сразу переходить к б)-2), пропуская б)-1) ).
При этом нужно понимать, что идентификатор типа в выражении интерпретируется
как ссылка (на статический экземпляр типа), тогда как в описании
это сам тип и есть.
		Пример:
          v1 [AC_FIN]; -- собственно тип [AC_FIN]
          v2 ref [AC_FIN]; ссылка на [AC_FIN]
          v3 ::[AC_FIN]; -- выражение для ссылки на статический экземпляр [AC_FIN]
          v4 [AC_FIN]%type; -- аналог выражения ::[AC_FIN], что есть ссылка на [AC_FIN]
          v5 [AC_FIN].[MAIN_V_ID]; -- выражение для реквизита [MAIN_V_ID] типа [AC_FIN]
          v6 [AC_FIN].[MAIN_V_ID]%type; -- то же, что v5
          v7 v1%type; -- использовать тип выражения v1, что есть тип [AC_FIN]
          v8 USER; -- используется тип [USER]
          v9 USER%type; -- используется функция STANDARD.USER
                Преобразуется в (PL/SQL):
          V1	Z#AC_FIN#INTERFACE.CLASS#AC_FIN;
          V2	number;
          V3	number;
          V4	number;
          V5	VARCHAR2(25);
          V6	VARCHAR2(25);
	  V7	Z#AC_FIN#INTERFACE.CLASS#AC_FIN;
	  V8	Z#USER#INTERFACE.CLASS#USER;
	  V9	VARCHAR2(128);

1.4. Разъяснение по поводу использования операторов в выражениях.
Приоритеты операторов (в порядке убывания приоритета):
. -> => :: % (разыменование структур, ссылок, модификаторы)
() (скобки)
** (возведение в степень)
+ - prior (унарные операторы - знак выражения, prior оператор)
* / (умножение, деление)
+ - || (сложение, вычитание, конкатенация)
= > < >= <= != <> IN (NOT IN) EXISTS (NOT EXISTS) LIKE (NOT LIKE) IS NULL (IS NOT NULL)
	(операторы сравнения)
NOT (логическое отрицание)
AND (логическое И)
OR  (логическое ИЛИ)
    Выражения, содержащие операторы, вычисляется по следующим принципам:
- выражения с одинаковым приоритетом вычисляются в порядке следования (слева направо);
- выражения, содержащие операторы с большим приоритетом, вычисляются раньше
выражений с меньшим приоритетом независимо от их расположения;
- тип результирующего выражения и операндов определяются самим оператором,
при необходимости производится умолчательное приведение типов.
		Пример:
1. Выражение
	'XXXX'||1000+2000
будет вычисляться так:
	('XXXX'||1000)+2000
- Конкатенация: 1000 приводим к строке '1000', конкатенируем с 'XXXX', получаем
	'XXXX1000'+2000
- Сложение: 'XXXX1000' приводим к числу, получаем исключение VALUE_ERROR.
2. Выражение
	2000+1000||'XXXX'
будет вычисляться так:
	(2000+1000)||'XXXX'
- Сложение: 2000+1000, получаем
	3000||'XXXX'
- Конкатенация: 3000 приводим к строке '3000', конкатенируем с 'XXXX', получаем
	'3000XXXX'
Формально оба выражения корректны, а по сути - первое содержит ошибку.

1.5. Реализована замена обращений к глобальным переменным и константам
текущей операции на обращения без префикса pl/sql пакета (в случае вычислений
на этапе компиляции это могло приводить к недетерминированной генерации
результирующего кода и зависимости этого кода от результатов предыдущей
компиляции). Например, обращения к глобальной переменной V1 просто по имени
V1 и при указании префикса текущей операции (т.е. [CLASS]::[METHOD].V1)
транслируются одинаково.

1.6. Запрещена модификация системных реквизитов (%CLASS,%STATE,%COLLECTION)
в операторе UPDATE.

1.7. Разъяснения по поводу вычислений на этапе компиляции (типы вычисляемых
конструкций регулируются настройками компилятора или прагмой calculate):
    - при использовании в выражениях глобальных констант (описанных через синтаксис
      const в секции глобальных описаний), эти выражения вычисляются независимо от того,
      как инициализируются глобальные константы (т.е. их инициализация может зависеть от того,
      кто компилирует операцию, соответственно, разные пользователи, компилирующие операцию,
      содержащую выражения с такой константой, могут получить разный код pl/sql пакета).
    - при использовании конструкции поиска по логическому условию (::[CLASS](<condition>)),
      конструкция вычисляется ВСЕГДА, независимо от того, использует ли она не вычисляемые
      в обычном режиме выражения, вызовы не вычисляемых функций, обращения к глобальным
      переменным (не константам) и т.д.
    - вычисляются строковые и ссылочные реквизиты (т.е. все, кроме дат, чисел и логики)
      статического экземпляра ТБП SYSTEM и экземпляров, полученных при поиске по логическому
      условию (см. предыдущий пункт), причем ссылки могут вычисляться при любом уровне
      вложенности.
    - список системных функций, которые вычисляются для константных и вычисляемых аргументов:
      STANDARD:
        ABS, ASCII, CEIL, FLOOR, INITCAP, INSTR, LENGTH, LOWER, LPAD, LTRIM,
        MOD, REPLACE, ROUND, RPAD, RTRIM, SUBSTR, TO_CHAR, TO_NUMBER, TRANSLATE,
        TRUNC, UPPER, SIGN, BITAND, TRIM,
      RTL:
        OBJECT_CLASS, OBJECT_STATE, OBJECT_COLLECTION, OBJECT_PARENT,
        OBJECT_CLASS_PARENT, OBJECT_CLASS_ENTITY, BOOL_CHAR, BOOL_NUM,
        SAFE_REPLACE, CLASS_PARENT, CLASS_ENTITY, COLLECTION_PARENT
        COLLECTION_CLASS, OBJECT_PARENT_CLASS,
      LIB: CLASS_NAME, STATE_NAME, ATTR_NAME, CLASS_SIZE
При вычислении ссылки на экземпляр по логическому условию могут возникать
следующие ситуации:
- поиск выполнен успешно,- вычисленное значение в дальнейшем используется
  как ссылочная константа;
- экземпляр не найден, - в зависимости от опции компилятора (pragma SUBSTITUTE)
  возникает либо ошибка компиляции PLP-OBJECT_NOT_FOUND, либо используется
  пустое значение для результирующей ссылочной константы;
- найдено несколько экземпляров, удовлетворяющих заданному условию, -
  в зависимости от опции компилятора (pragma SUBSTITUTE) возникает либо ошибка
  компиляции PLP-TOO_MANY_ROWS, либо возвращается первое полученное значение
  для результирующей ссылочной константы;
- значение ссылки НЕ ВЫЧИСЛИЛОСЬ на этапе компиляции из-за ошибок при
  выполнении запроса на поиск экземпляра по логическому условию, - в этом
  случае конструкция поиска фактически аналогична модификатору %locate,
  т.е. запрос на поиск экземпляра включается в PL/SQL код операции "как есть",
  соответственно, если он содержит в себе логические ошибки разработчика,
  не позволившие вычислить конструкцию на этапе компиляции, то такая ошибка
  может возникнуть как RUNTIME ошибка при выполнении самой операции.
  На этапе компиляции невозможно определить по какой причине не выполнился
  вычисляемый поиск, - из-за неразрешимых внешних ссылок в запросе
  (как явно заданных, так и неявно), из-за неправильных исходных данных,
  из-за RUNTIME ошибок разработчика запроса и др., поэтому в код операции
  включается невычисленный текст запроса без анализа причин ошибок
  вычисления.

1.8. Разъяснения по поводу использования команд препроцессору PL/Plus.
Препроцессор отрабатывает в три прохода:
  1) Синтаксический разбор текста операции (формирование дерева разбора),
     при этом обрабатываются inline-команды компилятора,
     прагмы создания переменных условной компиляции и макросов (define,macro,include),
     макроподстановки, операторы условной компиляции (if_def,end_if).
  2) Семантический анализ дерева разбора, полученного на этапе 1. При этом
     происходит разрешение всех семантических конструкций, т.е. описаний,
     операторов, определение вхождений всех идентификаторов (функций, процедур,
     переменных и пр.), проверка соответствия типов и т.д. При этом также выполняются
     команды условной компиляции if_def - end_if (inline команды, define, macro,
     include уже не выполняются), а также остальные прагмы, в т.ч. команды управления
     опциями компилятора, причем эти команды уже подчиняются общей структуре дерева
     разбора, так что прагмы if_def - end_if могут оказаться в разных уровнях.
  3) По полученному дереву формируется текст операции на pl/sql. Все команды
     компилятора отрабатывают еще раз. При этом стартовое состояние флагов
     компиляции (если они изменялись на этапе 2) может быть отличным от того,
     какое было при старте этапа 2. Опции препроцессора избирательны к этапам
     его работы, так что команды управления опциями компиляции должны это учитывать.
     Итак опции компилятора:
        WRITE_LOG  - этап 3,
        CALCULATE  - этап 3,
        OPTIMIZE   - declarations, descriptions - этап 2, this, code - этап 3,
        SUBSTITUTE - этап 3,
        CACHE      - этап 3,
        USE_COMMIT - этап 3,
        CHECK_TYPE - этап 2,
        LOCK_THIS  - этап 3,
        CHECK_OBJ  - обрабатывается при генерации интерфейсного пакета операции,
        CREATE     - этап 3,
        PL_SQL     - этап 2,
        ARCHIVE    - этапы 2,3,
        TBL_ORDER  - этап 3,
        THIS_NULL  - этап 3,
        TYPED_JOINS- этапы 2,3,
        ALL_PARAMS - обрабатывается при генерации исходного текста операции,
     Другие прагмы:
	HINT       - этап 3,
	INITIALIZE - этап 2,
	GET_THIS   - этап 3,
	SET_THIS   - этап 3,
	SET_DEBUG  - этапы 2,3,
	DEBUG      - этап 2,
	ERROR      - этап 2,
	MACRO      - этап 1,
	DEFINE     - этап 1,
	INCLUDE    - этап 1,
	IF_DEF     - этапы 1,2,3,
	END_IF     - этапы 1,2,3,
        DEFOPTIONS - этапы 2,3

1.9. Схема работы оператора INSERT <Переменная> INTO <Коллекция>
  (или <Коллекция>%INSERT(<Переменная>)):
        Тип Переменной  Тип Коллекции   Действие
        CLASS           CLASS           COPY(<Переменная>,<Коллекция>)
        ref CLASS       CLASS           SET_COLLECTION(<Переменная>,<Коллекция>)
        ref ref CLASS   CLASS           SET_COLLECTION(GET_REF(<Переменная>),<Коллекция>)
        CLASS           ref CLASS       COPY(COPY(<Переменная>,<CLASS>),<Коллекция>)
        ref CLASS       ref CLASS       COPY(<Переменная>,<Коллекция>)
        ref ref CLASS   ref CLASS       SET_COLLECTION(<Переменная>,<Коллекция>)
где
   COPY - создание нового экземпляра из переменной-структуры,
   SET_COLLECTION - перемещение существующего экземпляра, на который указывает
     переменная-ссылка, в новую коллекцию,
   GET_REF - получение значения по ссылке (разыменование на один уровень).

1.10. Разъяснение по поводу использования перекрытых функций и процедур.
В версии 6.1.Х подбор вызова подходящей перекрытой функции или процедуры
осуществляется ВСЕГДА (точнее, это определяется глобальным системным
параметром PLP_OVERLAPPING в таблице SETTINGS). В более ранних версиях
подбор вызова по параметрам осуществляется только в режиме расширенного
синтаксиса, если же этот режим не включен, то всегда используется первый
вызов (при этом, если получается, передаваемые значения параметров
приводятся принудительно к типам параметров первого вызова). Это следует
иметь в виду при переносе операций с версии 6.1.Х на более ранние.
Сама же процедура подбора вызова функций и процедур по списку фактических
параметров реализована по принципу максимального совпадения типов
параметров. Приоритет преобразований (в порядке убывания) при подборе
параметров:
  - полное совпадение типов,
  - развертывание ссылок,
  - преобразование типов без вызова функций преобразования (неявное преобразование),
  - преобразование типов с вызовом функций преобразования,
  - выбор вызова функции или процедуры,
  - несовместимость типов.
В версии ТЯ 7.1 в связи с реализацией новой целевой платформы для кода операций -
java платформы, в которой отсутствуют механизмы неявных преобразований
типов, градация приоритетов преобразований расширена:
  - полное совпадение типов,
  - развертывание ссылок, приведение пустых значений, приведение STRING/MEMO,
    NUMBER/INTEGER, структур-курсоров, приведение ссылок вверх по иерархии;
  - приведение ссылок вниз по иерархии, приведение числовых ссылок и коллекций
    к числу, приведение строковых ссылок к строке, приведение строк к CLOB/LONG;
  - приведение чисел и строк, приведение числовых ссылок и коллекций к строке,
    приведение строковых ссылок к числу, приведение строк к RAW/ROWID/LONG RAW;
  - приведение строк и чисел, приведение DATE/TIMESTAMP;
  - преобразование типов с вызовом функций преобразования
    (строк к DATE/BOOLEAN/TIMESTAMP/INTERVAL, чисел к BOOLEAN);
  - выбор вызова функции или процедуры;
  - несовместимость типов.


1.11. Оптимизирована схема кэширования экземпляра THIS и управления
кэша THIS с помощью прагм GET_THIS, SET_THIS. При отключенном режиме
кэширования (сброшенном флаге "Оптимизация") при компиляции этих
прагм вызовы служебных процедур по работе с кэш-переменной this
не добавляются и выдается предупреждение о некорректном использовании
прагм (ранее такие вызовы могли приводить к ошибкам в результирующем
пакете операции). Глобально режимом кэширования управляет системный
параметр PLP_CACHE_THIS (в таблице SETTINGS), если в этом параметре
указано значение NO, то режим кэширования будет отключен независимо
от настроек оптимизации самой операции. При включенном режиме
кэширования экземпляра this конструкция вычисления this%class использует
вычисленное ранее значение в локальной переменной plp$class$. Это сделано
для того, чтобы сократить запросы к БД для определения типа текущего
экземпляра. Для того, чтобы явно выполнить запрос модификатору %class
нужно указать первым параметром значение true. Общее поведение системы
регулируется системным параметром PLP_CACHE_CLASS (в таблице
SETTINGS), который по умолчанию установлен в значение YES, т.е. включен.
                Пример:
        begin
          s := this%class; -- кэшируется по умолчанию (по настройке PLP_CACHE_CLASS)
          s := this%class(true); -- не кэшируется через plp$class$
          s := this%class(false); -- кэшируется через plp$class$
        end;
Начиная с версии ТЯ 6.4 усовершенствован механизм кэширования в if-end if
блоках операций, изменена парадигма использования функций кэширования в сторону
внесения системных вызовов по сбросу кэша внутрь if блоков.

1.12. Изменен принцип использования прагмы IF_DEF - условной компиляции.
Для операторов IF - END IF, DECLARE - BEGIN - END, которые по сути являются
неделимыми, однако содержащие относительно независимые логические части,
условная компиляция может теперь воздействовать на эти логические части
в случае, когда прагма IF_DEF используется внутри этих операторов и не
захватывает оператор целиком.
		Пример:
	if a=1 then
		<Code1>
		pragma if_def(aaa);
	elsif a=2 then
		<Code2>
		pragma end_if;
	end if;
в случае отсутствия переменной условной компиляции aaa, будет получен код:
	if A = 1 then
		<Code1>
		null;
	end if;
хотя раньше генерился такой код	
	if A = 1 then
		<Code1>
	elsif A = 2 then
		null;
	end if;

1.13. Расширены возможности использования синонимов в PL/Plus в режиме
расширенного синтаксиса. Теперь Pl/Plus поддерживает обработку синонимов,
содержащих ссылки на внешние БД (DB-LINKS). Синонимы могут использоваться
только в режиме расширенного синтаксиса. Распознаются синонимы следующих
объектов Oracle -  пакеты, таблицы, представления. Синонимы должны быть
созданы в схеме-владельце IBSO. Обращения объектам, внешним по отношению
к схеме IBSO (т.е. объекты других схем, в т.ч. других БД, доступных через DB-LINK,
причем в последнем случае связь с другой БД должна нормально устанавливаться,
чтобы ссылаемый через синоним объект распознавался), в PL/Plus возможно только
через синоним на схеме IBSO.

1.14. Поддержка автономных транзакций на уровне PL/Plus. Включение режима
осуществляется с помощью оператора pragma autonomous_transaction; и действует
только в пределах функции или процедуры, где он объявлен. При этом
операторы commit и rollback не снимают блокировки, выставленные в
основной транзакции. Также, если автономная транзакция производила
изменения данных, то она обязана быть завершена оператором управления
транзакцией (commit/rollback).

1.15. Разъяснение по вызову операций из других операций. При вызове
операций в них неявно передаются два параметра this и plp$class.
Параметр this идентифицирует экземпляр, над которым выполняется
операция, plp$class определяет тип экземпляра (точнее, как его
должна интерпретировать операция). Пустое значение plp$class
предписывает операции самой определить тип экземпляра, непустое
значение устанавливается:
- при вызове конструкторов в режиме создания нового экземпляра
  (определяет ТБП, в котором создавать новый экземпляр),
- при вызове статических операций;
- при вызове перекрытых операций, т.е. при вызове операции родительского
  типа по текущей ссылке this.
а) Конструкторы могут вызываться в двух режимах - в режиме создания
нового экземпляра (при вызове по ссылке this, при вызове с префиксом
не родительского типа или не перекрытого конструктора, при вызове по
коллекции), либо в режиме редактирования существующего (вызов по ссылке,
не являющейся this, или при вызове перекрытого конструктора с префиксом
родительского типа):
		Пример:
	[NEW#AUTO];			-- создание экземпляра
                                           (передается this=>null, plp$class=>'<ТБП операции>')
	this.[NEW#AUTO]; 		-- создание экземпляра
                                           (передается this=>null, plp$class=>'<ТБП операции>')
	coll.[NEW#AUTO]; 		-- создание экземпляра в коллекции coll
                                           (передается this=>coll, plp$class=>'$$$_<ссылаемый коллекцией ТБП>')
	coll->(::[CHILD_CLASS])[NEW#AUTO];-- создание экземпляра в коллекции coll дочернего типа
                                           (передается this=>coll, plp$class=>'$$$_CHILD_CLASS')
	[OTHER_CLASS]::[NEW#AUTO];  	-- создание экземпляра в типе OTHER_CLASS
                                           (передается this=>null, plp$class=>'OTHER_CLASS')
	[PARENT_CLASS]::[NEW#OTHER]; 	-- создание экземпляра в родительском типе PARENT_CLASS
                                           (передается this=>null, plp$class=>'PARENT_CLASS')
	[PARENT_CLASS]::[NEW#AUTO]; 	-- редактирование экземпляра this перекрытой
                                           родительской операцией, т.е. если вызов
                                           осуществляется из одноименной операции
                                           (операции с тем же коротким  именем, что и
                                           вызывающая операция, в данном случае - NEW#AUTO)
                                           (передается this=>this, plp$class=>'$$$#PARENT_CLASS')
	other_ref.[NEW#AUTO]; 	-- редактирование экземпляра other_ref
                                   (передается this=>other_ref, plp$class=>null)
  Следует отметить, что сложные конструкторы (т.е. не имеющие признак "простой
  конструктор") могут использоваться только для создания экземпляров собственного
  типа. Связано это с тем, что такие конструкторы создают экземпляр при выходе
  из операции из переменной-структуры, которая несовместима с другими типами,
  кроме собственного.
б) В вызов групповых (статических) операций всегда передается пустое
значение ссылки (this) независимо от формата вызова, в качестве plp$class
передается ТБП самой операции (если указан префикс типа), либо ТБП
ссылки, по которой вызывается операция.
в) Списочные операции вызываются по переменной, описанной PL/SQL
таблицей ссылок, и эта переменная передается в эту операцию как this,
plp$class заполняется только при вызове перекрытой операции.
г) Остальные типы операций (которые по сути являются разновидностями
простых операций) вызываются непосредственно по той ссылке, к которой
применены. При этом в качестве this передается ссылка, по которой
операция вызвана, а в plp$class передается пустое значение (если
вызов происходит не по ссылке this). При вызове простых операций
(кроме деструкторов) по ссылке this в вызываемую операцию, помимо
самой ссылки this, в параметре plp$class передается значение текущего
типа, с которым работает операция (переменная plp$class$).
Вызов простых операций с указанием префикса типа интерпретируется
следующим образом: если префиксирующий тип является родительским
или совпадающим с типом вызывающей операции, тогда в вызываемую операцию
передается текущее значение ссылки this (т.е. осуществляется перекрытый
вызов в родительском типе), если нет, то в качестве this передается
пустое значение, в качестве же plp$class передается указанный
префиксирующий тип.
		Пример:
	[EDIT#AUTO];			-- this=>this, plp$class=>plp$class$ (тип экземпляра в операции)
	this.[EDIT#AUTO]; 		-- this=>this, plp$class=>plp$class$
	[PARENT_CLASS]::[EDIT#AUTO]; 	-- this=>this, plp$class=>'$$$#PARENT_CLASS' (перекрытый вызов)
	[OTHER_CLASS]::[EDIT#AUTO];  	-- this=>null, plp$class=>'OTHER_CLASS'
	other_ref.[EDIT#AUTO]; 	        -- this=>other_ref, plp$class=>null
Передача текущего значения типа экземпляра в операции (plp$class$) в вызываемые
реализовано в версии ТЯ 6.3, в более ранних версиях в вызываемые операции
тип передавался пустым. В такой реализации сокращены накладные расходы
на выполнение дополнительных запросов по определению типа экземпляра внутри
простых операций.
  Дополнительно следует отметить, что при перекрытом вызове в качестве
параметра plp$class передается строка с ID перекрывающего типа и дополнительным
префиксом '$$$#', чтобы вызванная операция могла понимать, что ее позвали
в перекрытом режиме. Перекрытый вызов должен удовлетворять следующим
условиям:
- вызываемая операция - простая (т.е. не является групповой, фильтром,
  списочной операцией);
- префикс типа совпадает или является родительским по отношению к вызывающей
  операции;
- для конструкторов дополнительно короткое имя вызываемой операции должно
  совпадать с коротким именем вызывающей.
  Следует различать понятие перекрытого вызова операций (приведенное выше)
и понятие собственно перекрытых операций. Перекрытые операции производят
анализ типа экземпляра, для которого вызываются, и при необходимости делают
перевызов перекрывающей операции в случае несовпадения типа экземпляра
с типом перекрытой операции. Перекрытые и перекрывающие операции должны
удовлетворять следующим условиям:
- операции должны быть простого типа (в т.ч. конструкторы), т.е. работающие
  с экземплярами;
- должны иметь одинаковые короткие имена, одинаковый тип возвращаемого
  значения (исключение составляют конструкторы, которые возвращают
  ссылку на свой тип, который различается у перекрытых операций), одинаковый
  список параметров и их типов;
- операции принадлежат разным типам в иерархии типов от общего родительского
  типа.
                Пример устранения рекурсии путем перекрытого вызова:
  Пусть есть тип [PARENT_CLASS],
    в нем определены простые операции [EDIT],[EDIT1]
  Пусть есть тип [CHILD_CLASS],
    в нем также определены простые операции [EDIT],[EDIT1], перекрывающие
    операции родительского типа.
  Сценарий взаимодействия операций друг с другом таков:
  [PARENT_CLASS].[EDIT]: при вызове для экземпляра типа [CHILD_CLASS]
     (и порожденных от него) автоматически вызывает перекрывающую операцию
     [CHILD_CLASS].[EDIT], для экземпляров других типов выполняет свои
     действия.
  [PARENT_CLASS].[EDIT1]: при вызове для экземпляра типа [CHILD_CLASS]
     (и порожденных от него) автоматически вызывает перекрывающую операцию
     [EDIT1], для экземпляров других типов выполняет какие-то действия,
     в т.ч. вызывает операцию [EDIT],т.е. имеет такой код:
        [PARENT_CLASS]::[EDIT];  -- перекрытый вызов операции своего типа
        this.[EDIT];
  [CHILS_CLASS].[EDIT]: выполняет какие-то действия, в т.ч.
     вызывает операцию [EDIT1] родительского типа:
        [PARENT_CLASS]::[EDIT1];-- перекрытый вызов операции родительского типа
  Таким образом, при выполнении операции [EDIT] для экземпляра типа
  [CHILD_CLASS] получаются следующие последовательности вызовов:
  1) Запускается операция [CHILD_CLASS].[EDIT] для заданного экземпляра.
  2) Вызывается  [PARENT_CLASS]::[EDIT1] со значением plp$class='SSS#PARENT_CLASS',
     т.е. делается перекрытый вызов. Т.к. ей задан свой тип PARENT_CLASS, то
     она выполняет свой код и доходит до вызова [PARENT_CLASS].[EDIT];
  3) В [PARENT_CLASS].[EDIT] передан параметр plp$class='SSS#PARENT_CLASS',
     из которого операция понимает, что ей нужно отработать собственный код. После
     чего происходит возврат назад в [PARENT_CLASS]::[EDIT1].
  4) Вызов this.[EDIT] зовет операцию [PARENT_CLASS].[EDIT], передает
     ей this и текущий тип экземпляра plp$class$, который равен дочернему
     типу CHILD_CLASS, т.к. исходно вызывалась операция для экземпляра
     дочернего типа ([CHILD_CLASS].[EDIT]).
  5) Вызываемая операций [PARENT_CLASS].[EDIT] понимает, что она вызвана
     для экземпляра дочернего типа, и, соответственно делает ее автоматический
     перевызов, т.е. переходит к п.1, и так до бесконечности. В случае же
     перекрытого вызова (п.3) такого не происходило.
  В версии ТЯ 7.0 перекрытые вызовы можно инициировать не только с
помощью префикса типа, но и с помощью синтаксиса переопределения
типа в операторе ссылки при вызове по ссылке this. Таким
образом, в ТЯ 7.0 появилась возможность выполнения перекрытых вызовов
валидаторов операций, чего нельзя было сделать в прежних версиях
(т.к. префикс типа инициировал перекрытый вызов только тела операции).
Вызов операции считается перекрытым, если переопределяющий тип
ссылки является родительским по отношению к типу операции, если
же он является дочерним, то такой вызов означает просто вызов
операции дочернего типа.
		Пример:
	[PARENT_CLASS]::[EDIT#AUTO]; 	-- перекрытый вызов тела родительской операции
	this->(::[PARENT_CLASS])[EDIT#AUTO];-- перекрытый вызов тела родительской
                                            -- операции (аналог предыдущего вызова)
	this=>(::[PARENT_CLASS])[EDIT#AUTO];-- перекрытый вызов валидатора родительской
                                            -- операции (аналога в прежних версиях нет)


1.16. При использовании функции RTL.GET_OBJECT для получения значений
системных реквизитов (ID,CLASS_ID,STATE_ID,COLLECTION_ID) она
преобразуется в вызов соответствующей функции интерфейсного
пакета того типа, на который указывает ссылка, передаваемая_
в качестве первого параметра.

1.17. Появилась возможность использования переменных с именами,
    совпадающими с зарезервированными словами с помощью использования_
    префикса '~':
        ~type  integer;

1.18. Реализована возможность использования PL/Plus конструкций и
    элементов при генерации текстов представлений и анонимных PL/SQL
    блоков через PL/Plus вставки. Поддерживаются два вида вставок -
    для выражений (скобки-комментарии "/*PL+*/" и "/*PL-*/") и для_
    последовательностей описаний/операторов (скобки-комментарии
    "-- begin pl/plus" и "-- end pl/plus"). Такие текстовые
    преобразования производит функция generate_view пакета method.
    Пример использования:
выражение
      cur := cur||/*PL+*/::[FT_MONEY]([CUR_SHORT]='RUR')||lf$/*PL-*/;
будет преобразовано в
      cur := cur||'1301'||RTL.LF$;
    или
текст
    declare
    -- begin pl/plus
    function get_user_id return ref [USER] is
    begin
        return [USER]%locate(u exact where u.[name]={:name});
    exception when no_data_found then return null;
    end;
    -- end pl/plus
    begin
        stdio.put_line_buf(get_user_id);
    end;
будет преобразован в
    declare
    begin
    -- PL+
        function GET_USER_ID return varchar2 is
    plp$ID_1    varchar2(16);
        begin
    begin
            select  a1.id id
            into plp$ID_1
            from Z#USER a1
            where a1.COLLECTION_ID is NULL
              and (a1.C_NAME = :name);
    exception
        when NO_DATA_FOUND then raise rtl.NO_DATA_FOUND;
        when TOO_MANY_ROWS then raise rtl.TOO_MANY_ROWS;
    end;
            return plp$ID_1;
        exception
        when RTL.NO_DATA_FOUND then
            return null;
        end;
    -- PL-
    begin
        stdio.put_line_buf(get_user_id);
    end;
Скобки-комментарии "-- begin pl/plus" и "-- end pl/plus" также
можно использовать и для вычисления выражений, когда такое
вычисление не может быть реализовано одним выражением, которое
требуется в случае "/*PL+*/" и "/*PL-*/" (например, в выражении
используются макросы, которые требуется импортировать отдельной
командой pragma include). В этом случае Pl/Plus конструкция
должна быть реализована как набор описаний (declarations),
при этом должна быть описана переменная с именем R$, выражение
для инициализации которой и будет результатом указанной pl/plus
вставки:
выражение
    cur := cur||
    -- begin pl/plus
    pragma include([CLASS]::[METHOD]);
    r$ string := ::[FT_MONEY]([CUR_SHORT]=&NAT_CODE)||lf$;
    -- end pl/plus
    ;
будет преобразовано (если в операции [CLASS]::[METHOD] определен
макрос NAT_CODE со значением 'RUR') так:
    cur := cur||
    -- PL+
      '1301'||RTL.LF$
    -- PL-
    ;
Следует отметить, что скобки-комментарии "/*PL+*/" и "/*PL-*/" имеют более
высокий приоритет, чем скобки-комментарии "-- begin pl/plus" и "-- end pl/plus",
поэтому при совместном использовании обоих типов комментариев вторые
комментарии могут не распознаваться, если после них использованы комментарии
первого типа.

1.19. Разъяснения по поводу использования PL/Plus псевдо-функций:
CUBE, ROLLUP, GROUPING_SETS, SET, ANALYTIC
   - псевдо-функции для реализации запросов с группировками
     и аналитикой.
ROWNUM
   - при использовании в запросах транслируется в SQL псевдо-столбец ROWNUM,
     при использовании в процедурном коде транслируется в VALMGR.ROWCOUNT
     (возвращает SQL%ROWCOUNT).
BULK_ROWCOUNT
   - транслируется в SQL%BULK_ROWCOUNT массив при выполнении forall
     DML операторов (INSERT/UPDATE/DELETE).
BULK_EXCEPTIONS
   - транслируется в SQL%BULK_EXCEPTIONS массив при выполнении forall
     DML операторов (INSERT/UPDATE/DELETE) в режиме exceptionloop (save exceptions).
     При этом возникает исключение RTL.DML_ERRORS, в обработчике которого
     возможна обработка такого массива (его элементы содержат два числовых
     поля с именами ERROR_INDEX и ERROR_CODE, в которые заносятся номер
     записи исходного массива, при обработке которой произошла ошибка,
     и номер самой ошибки Oracle, соответственно).
CAST_TO
   - функция приведения типов выражений - тип выражения, передаваемого вторым
     параметром, приводится к типу, указанному первым параметром (причем первым
     параметром можно указывать и пользовательские PL/SQL типы).
USER
   - в операциях возвращает имя пользователя, зарегистрировавшего свою сессию
    (для двухуровневых сессий пользователей, совпадает с именем пользователя
    Oracle, под которым сессия создана, для трехуровневых сессий это не так),
    в представлениях возвращает sys_context('<IBSO owner>_SYSTEM','USER') или
    sys_context('<IBSO owner>_SYSTEM','USR') (для представлений, используемых
    при администрировании доступа).
OWNER
   - возвращает строковую константу с именем пользователя-владельца IBSO (см.п.4.12).
GOWNER
   - возвращает строковую константу с именем глобального владельца IBSO (см.п.4.12).
USER_CONTEXT
   - возвращает строковую константу с именем пользовательского контекста <IBSO owner>_USER.
GLOBAL_CONTEXT
   - возвращает строковую константу с именем пользовательского контекста <IBSO owner>_GLOBAL.
PLP_CALC
   - вычисляет строковое выражение, передаваемое первым параметром, возвращает
     строковое представление результата в виде строковой константы (если вторым
     параметром указать значение false, тогда результат не будет форматироваться
     в строку, а будет возвращен как есть). По сути функция аналогична исполняемому
     безымянному макросу.
NEXT_VALUE
   - при использовании в запросах первым параметром может быть передана
     строковая константа, которая задает либо имя последовательности
     (тогда функция транслируется как получение нового значения последовательности
     в виде выражения <Sequence name>.nextval), либо непосредственно выражение
     для получения атрибутов последовательности (<Sequence>.nextval - новое значение
     или <Sequence>.currval - текущее значение);
   - если при использовании в запросах первым параметром указать
     любое строковое выражение (кроме строковой константы), определяющее имя
     последовательности или выражение для получения атрибутов последовательности,
     тогда в запрос будет помещен вызов функции rtl.next_value (до версии ТЯ 6.5.1
     такой режим использования next_value был недоступен); этот режим следует
     использовать в SQL-операторах INSERT, чтобы инициализировать различные
     значения одной и той же последовательности для вставляемой записи (непосредственно
     выражение <Sequence>.nextval всегда возвращает одно значение для текущей записи
     независимо от того, сколько раз оно в этой записи используется);
   - в процедурном коде вызов транслируется в rtl.next_value с произвольным строковым
     параметром, определяющим имя последовательности или выражение для получения
     атрибутов последовательности.
GET_OBJECT
   - функция получения значений системных реквизитов, если параметром передается
     ссылка, тогда транслируется в вызов функции интерфейсного пакета ссылаемого типа,
     иначе транслируется в rtl.get_object.
GET_PARENT
   - функция получения информации о владельце коллекции (значение ссылки на родительский
     экземпляр и его тип - функция заполняет поля ID и CLASS_ID); если параметром
     передается типизованная коллекция, тогда транслируется в вызов функции get_parent
     из интерфейсного пакета типа - элемента коллекции, иначе транслируется в
     rtl.get_parent.
TO_TZ - приведение timestamp выражения к заданной временной зоне:
     <timestamp expr> at time zone <timezone>.
TO_INTERVAL - приведение interval выражения к заданному типу интервала:
     <interval expr> day to second
     или
     <interval expr> year to month.
В версии ТЯ 7.2 и выше добавлены следующие псевдо-функции:
SYSTEM_CONTEXT
   - возвращает строковую константу с именем системного контекста <IBSO owner>_SYSTEM.
GET_VALUE
   - функция получения значений реквизита экземпляра по ID и строковому
     квалифилификатору: если параметром передается ссылка, тогда транслируется
     в вызов функции get$value интерфейсного пакета ссылаемого типа,
     иначе транслируется в rtl.get_value.
SET_VALUE
   - процедура установки значений реквизита экземпляра по ID и строковому
     квалифилификатору: если параметром передается ссылка, тогда транслируется
     в вызов процедуры set$value интерфейсного пакета ссылаемого типа,
     иначе транслируется в rtl.set_value.


1.20. В операциях определены следующие макросы:
METHOD$ID     - уникальный идентификатор (ID) операции,
METHOD$CLASS  - короткое имя ТБП, которому принадлежит операция,
METHOD$NAME   - наименование операции,
METHOD$SNAME  - короткое имя операции,
METHOD$PACK   - имя пакета PL/SQL операции,
METHOD$       - имя операции в PL/Plus нотации
                ('[<короткое имя ТБП>]::[<короткое имя операции>]');
BASE$EXECUTE  - вызов тела базовой операции в расширении (передаются
                одноименные параметры расширения)
BASE$VALIDATE - вызов валидатора базовой операции в расширении (передаются
                одноименные параметры расширения)
BASE$SETVARS  - установка глобальных переменных базовой операции
                из глобальных переменных расширения
BASE$GETVARS  - установка глобальных переменных расширения
                из глобальных переменных базовой операции
Макросы BASE$... реализованы начиная с версии ТЯ 6.4 и определены только
в расширениях, в остальных операциях эти макросы содержат в себе просто
null-оператор. Начиная с версии 6.5 эти макросы также определены для
операций, наследующих форму другой операции. Для таких операций в вызов
макросов BASE$EXECUTE и BASE$VALIDATE нужно передавать параметром ссылку,
по которой вызывается операция с наследуемой формой (для расширений
параметр указывать не нужно, т.к. вызов всегда осуществляется по
ссылке this). Начиная с версии 6.5 в макросы METHOD$... при компиляции
представлений заносится информация о компилируемом представлении
(в прежних версиях информация была обезличенной).
  В версии ТЯ 7.0 реализовано предупреждение PL/Plus при попытке
определения макроса размером, превышающего допустимый (10000).
Это относится также и к перечисленным выше макросам (BASE$...).
При возникновении такого предупреждения фактическое использование
макросов невозможно.

1.21. Не рекомендуется использовать обращения к реквизитам экземпляра
THIS или использовать модификаторы к ссылке THIS при инициализации
значений переменных при их объявлении, т.к. эти значения могут
выбираться из буферных кэш-переменных, которые инициализируются
только в исполняемом коде операции и на этапе объявления переменных
еще не заполнены.
		Пример:
        Неправильно:
	  s string := this%class;
        begin
          if s='SMTH' then ...
          ...
        end;
        Правильно:
	  s string;
        begin
	  s := this%class;
          if s='SMTH' then ...
          ...
        end;

1.22. Разъяснение по поводу формирования системных колонок
в представлениях (добавление системных колонок в типы - см.п.3.10)
в режиме добавления системных колонок (который является умолчательным):
а) Простые представления:
  CLASS_ID добавляется всегда:
    - если колонка есть в базовом типе (в котором определено представление),
    - если колонки нет в базовом типе, то в качестве значения колонки
      выбирается строковая константа с ID базового типа.
  STATE_ID добавляется в следующих случаях:
    - если колонка есть в базовом типе (в котором определено представление).
  COLLECTION_ID добавляется в следующих случаях:
    - если колонка есть в базовом типе (в котором определено представление).
    - если колонка есть в одном из родительских типов, то в версиях ТЯ до 6.4
      эта колонка добавлялась безусловно из ближайшей по иерархии родительской
      таблицы, а в версиях, начиная с 6.4, родительская колонка добавляется
      только в случае, если она есть также и у дочерних типов (т.е. существуют
      физические массивы дочерних типов).
б) Сложные представления:
  - системные колонки добавляются всегда;
  - если какие-то колонки отсутствуют в составляющих представлениях (т.е. входящих
    в состав сложного представления), тогда в качестве значений системных колонок:
    - для колонки CLASS_ID выбирается тип составляющего представления;
    - для остальных колонок выбираются пустые значения.
в) PL/Plus представления:
  - если в выборке присутствуют выражения с явно указанными алиасами ID, CLASS_ID,
    STATE_ID, COLLECTION_ID, тогда используются именно явно заданные выражения.
  - если выражения для системных колонок явно не указаны, тогда для простых
    select-курсоров они формируются  автоматически следующим образом:
      - в качестве базового типа принимается тип, который указан первым
        в списке IN;
      - если системные колонки присутствуют в таблице базового типа, то
        они и выбираются;
      - если системные колонки находятся в таблицах родительских типов, и
        эти таблицы присутствуют в выборке (по другим условиям join-соединений),
        то они выбираются;
      - если системные колонки находятся в таблицах родительских типов, и
        эти таблицы не присутствуют в выборке, то колонки выбираются в соответствии
        с п.а) (как для простых представлений).
   - для сложных select-курсоров, каковыми являются выборки с групповыми
     операторами UNION/MINUS/INTERSECT или выборки из подзапросов или
     внешних таблиц и представлений, выражения для системных колонок
     должны быть всегда указаны явно, т.к. для таких курсоров они не
     могут быть сформированы автоматически.

1.23. Разъяснение по поводу использования операторов управления
транзакциями (commit/rollback) внутри открытых курсоров. Если
операторы commit/rollback выполняются при открытом курсоре, то
такой курсор на момент выполнения commit/rollback автоматически
дублирует свою выборку (моментальный снимок - snapshot) в rollback
сегменте Oracle для поддержки консистентности выбираемых данных
(если фиксируется транзакция, изменяющая данные исходной выборки).
Реальное освобождение места в rollback сегменте произойдет только
при закрытии курсора. Соответственно, чем больше commit/rollback
операторов выполнится внутри открытого курсора, тем больше будет
копий исходных данных в rollback сегменте, тем больше вероятность
получить ошибку ORA-01555 (snapshot too old). Поэтому если требуется
делать промежуточные фиксации изменений, то нужно позаботиться, чтобы
все открытые курсоры на момент commit/rollback были закрыты,
чего можно достичь с помощью предварительной выборки данных в PL/SQL
массивы или опции one by one оператора FOR.

1.24. В версии ТЯ 6.5 реализована поддержка использования системных
реквизитов (ID,CLASS_ID,STATE_ID,COLLECTION_ID) на формах операций
по квалификаторам %id, %class, %state, %collection, которые указываются
у соответствующих контролов формы.

1.25. Разъяснение по поводу использования меток, обозначающих циклы
(т.е. меток, непосредственно предшествующих оператору цикла).
Такие метки в коде PL/SQL также переносятся непосредственно к оператору
цикла, который в случае использования циклов по типам, выборкам и курсорам
оформляется в виде отдельного DECLARE/BEGIN-END блока, т.о. метка
переносится внутрь этого блока и становится недоступной вне его.
Поэтому переход на эту метку вне таких циклов невозможен.
		Пример:
        begin
          ...
          <<label1>>
          <<label2>>
          for u in [USER] loop
            ...
            loop
              ...
              exit label2 when u=stdlib.userid; -- выход из внешнего цикла,
                                                -- отмеченного label2
              exit label1; -- выход из цикла по label1 невозможен, т.к. label1
                           -- не является меткой цикла
            end loop;
            ...
          end loop;
          ...
          goto label1;  -- переход возможен - метка label1 доступна
          goto label2;  -- переход невозможен - метка цикла итератора label2 не доступна,
                        -- т.к. входит внутрь неявного блока begin/end цикла
          ...
        end;

1.26. Разъяснение по поводу развертывания полей структур и списков
выборок модификатором %rowtype (см. plplus.doc - п.1.2.13.16.2).
Поля структур модификатором разворачиваются в соответствии с их порядком при
определении самой структуры. Порядок полей производных от ТБП структур определяется
в соответствии с п.3.2 (см.ниже). Списки выборок (select/into/return списки) при
разворачивании по ссылке-алиасу ведут себя в соответствии с Rowtype типом
(см.п.3.2.1.1). Следует отметить, что в случае наличия у типа таблицы,
порядок следования колонок в таблице и порядок расположения реквизитов
в типе могут не совпадать, что может приводить к неправильному соответствию
порядка полей структур, основанных на ТБП (см.п.3.2), при использовании
модификатора %rowtype для их развертывания, в частности, при присвоении
просто структуры ТБП (п.3.2.2.1) и rowtype структуры (п.3.2.1.1).
Несовпадение полей также возникнет в случае, если структура ТБП
содержит в себе подструктуры, т.к. структура типа (п.3.2.2.1) по умолчанию
развертывается до составляющих ее реквизитов (среди которых есть свои
структуры), а rowtype структура (п.3.2.1.1) разворачивается до скалярных
составляющих всех подструктур. Для инвариантного преобразования структур
между собой следует использовать модификатор %init (см. plplus.doc - п.1.2.13.16.1).
Также можно воспользоваться дополнительными опциями модификатора %rowtype,
которые позволяют выделить нужные наборы полей и подходящий порядок их
следования (см. plplus.doc - п.1.2.13.16.2):
  'INNER' - разворачивает вложенные подструктуры структуры типа (п.3.2.2.1)
      и упорядочивает поля в соответствии с полями rowtype структуры (п.3.2.1.1);
  'NOSYS' - отключение системных реквизитов (т.к. их список может не совпадать для
      простой и rowtype структур);
  'SELF,NOMAP', переопределение типа - выделение только собственных реквизитов/полей
      в случае иерархически устроенных типов.
		Пример:
        Пусть есть тип [PARENTCLASS] c реквизитом [PARENTATTR] (порядковый номер 1).
        Пусть есть тип [CLASS], порожденный от [PARENTCLASS], c реквизитами:
            [ATTR1]  - порядковый номер 2;
            [ATTR2]  - порядковый номер 3.
        В типе могут быть экземпляры и существует таблица с колонками:
            С_ATTR2  - колонка в позиции 1, соответствующая рекизиту [ATTR2];
            С_ATTR1  - колонка в позиции 2, соответствующая рекизиту [ATTR1].
        declare
	  v1 [CLASS];
          v2 [CLASS]%rowtype;
          v3 [CLASS]%rowtable;
        begin
          v1%rowtype := v2%rowtype; -- некорректное использование %rowtype, т.к.:
             -- а) список системных реквизитов может не совпадать;
             -- б) v1 содержит родительский реквизит [PARENTATTR], а v2 - нет;
             -- в) порядок следования полей, соответствующих собственным реквизитам - разный.
          v1%init(v2); -- корректное заполнение v1 из v2
          v1%rowtype('self,nosys,inner') := v2%rowtype('nosys'); -- корректный перенос
             -- собственных полей из v2 в v1 с правильным упорядочиванием
          for i in 1..v3%id.count loop
            v1%rowtype := v3%rowtype(i); -- некорректное использование %rowtype, т.к.:
               -- порядок следования полей (родительских и собственных) - разный.
            v1%rowtype(::[PARENTCLASS]) := v3%rowtype(::[PARENTCLASS],i);
               -- корректный перенос родительских и системных реквизитов.
            v1%rowtype('self,nosys,inner') := v3%rowtype('self,nosys',i);
               -- корректный перенос собственных реквизитов.
          end loop;
        end;

1.27. При разработке операций следует обращать внимание на генерируемые
препроцессором предупреждения, чтобы точно понимать, что получается
именно то, что задумано. Есть предупреждения чисто информационного
свойства (например, PLP-ID_SUBSTITUTE, PLP-RUNTIME_DECLARATION),
а есть предупреждения, которые могут отражать вероятные проблемы.
В первую очередь это касается предупреждений по совместимости типов
(PLP-ASSIGN_ERROR, PLP-HIERARCHY_ERROR, PLP-TYPES_INCOMPATIBLE).

1.28. Разъяснение по использованию pragma EXCEPTION_INIT. Указанную
прагму следует использовать сразу же после описания переменной-исключения.
Если не придерживаться этого правила, то на версии Oracle10g это
будет приводить к ошибкам компиляции на уровне PL/SQL.

1.29. В версии ТЯ 7.0 реализована поддержка динамического использования
архивных данных секционированных таблиц в операциях и представлениях
словаря данных. Расширен архивный режим работы операций, определяемый
опцией компиляции, управляющей использованием архивов. Режим использования
архивов определяется прагмой archive или соответствующими опциями компиляции.

  Допустимо использование следующих режимов:
  1) pragma archive(true);
     pragma archive(true,'actual'); pragma archive(false,'actual');
     pragma archive(true,true);     pragma archive(false,true);
     COMPILER option, position 12 = '1'
     Задается режим использования только актуальных данных
     (актуальных секций - режим по умолчанию):
       - в вызовы интерфейсных пакетов типов везде передается
         значение null в качестве значения для параметра key_;
       - все выборки, поиски, курсоры  (операторы FOR/LOCATE/SELECT),
         SQL-операторы UPDATE/DELETE используют обращения только
         к актуальным секциям.
  2) pragma archive(true,'all');
     pragma archive(true,false);
     COMPILER option, position 12 = '2'
     Задается режим использования архивных данных с использованием
     текущих значений ключей архивации:
       - в вызовы интерфейсных пакетов типов везде передается
         значение -1 в качестве значения для параметра key_;
       - все выборки, поиски, курсоры  (операторы FOR/LOCATE/SELECT),
         SQL-операторы UPDATE/DELETE (только для Oracle partitions)
         используют обращения ко всем секциям с добавлением условия
         на значение колонки KEY большее или равное текущему ключу
         разделения для заданной таблицы типа.
  3) pragma archive(false);
     pragma archive(false,'all');
     pragma archive(false,false);
     COMPILER option, position 12 = '0'
     Задается режим использования всех архивных данных:
       - в вызовы интерфейсных пакетов типов везде передается
         значение 0 в качестве значения для параметра key_;
       - все выборки, поиски, курсоры  (операторы FOR/LOCATE/SELECT),
         SQL-операторы UPDATE/DELETE (только для Oracle partitions)
         используют обращения ко всем секциям без добавления условия
         на колонку KEY (либо с добавлением условия на значение колонки
         KEY большее или равное нулю).
  Для PL/Plus представлений по умолчанию используется режим 1, режим
  2 может быть включен путем добавления свойства Archive в представление
  (т.е. включение подстроки '|Archive' в criteria.properties).

  Операции-триггеры и операции-реквизиты (функциональные реквизиты)
создаются в двух вариантах:
  - с использованием режима актуальных секций 1;
  - с использованием режима архивных секций 2 с тем исключением,
    что для собственного типа используется значение дополнительного параметра
    plp$key, передаваемого в операцию явно (это реализует логику работы
    интерфейсных пакетов типов, т.к. эти операции вызываются явно именно из
    интерфейсных пакетов, где ключ архивации передается параметром).
  Варианты транслируются в одноименные pl/sql процедуры и функции,
  перегруженные по параметру plp$key (при необходимости код операций
  может анализировать значение параметра plp$key, т.е. иметь runtime
  информацию о том, в каком режиме работает операция).

  Препроцессором PL/Plus также допускается явное указание значения ключа
архивации для наложения условия в поисках и выборках, а также для получения
значений реквизитов и модификаторов по ссылкам путем указания значения
для параметра key_ (осуществляемым через вызовы соответствующих функций
и процедур интерфейсных пакетов типов).
  Явно указываемые значения номеров секций архивных таблиц (либо подключение
всех секций таблиц опцией 'all') перекрывают общие режимы 1-3 для
заданных типов. То же относится и к значениям ключей архивации - явно заданные
значения перекрывают значения режимов 2-3. Исключением является
указание параметра key_ для ссылки this в случае включенной оптимизации
кэш-переменной this (общий режим архивации перекрывает явно заданное
значение - об этом выдается предупреждение препроцессора), соответственно,
процедуры Get$Obj$This/Set$Obj$This используют ключи режимов 1-3 и
игнорируют заданные значения ключа архивации при ссылке this.

  Параметр key_ может быть задан в операторе ссылки в качестве числового
значения. Если он задан, то должен быть указан последним в списке параметров
для оператора ссылки (который может принимать первым константу true/false
для указания типа соединения outer/inner join, вторым ТБП, переопределяющим
целевой тип ссылки). В прежних версиях ТЯ ссылка также могла принимать
значение для key_, однако его нельзя было задать одновременно с указанием
выражения для переопределения типа (в котором дополнительно можно указать
либо номер секции, либо все секции).

  Параметр key_ может быть задан в операторах-модификаторах в качестве числового
значения. Если он задан, то должен быть указан последним в списке параметров
для соответствующего модификатора (которые для ссылок и коллекций могут
принимать как минимум 2 параметра - первым константу true/false для указания
типа соединения outer/inner join, вторым ТБП, переопределяющим целевой тип
ссылки). В прежних версиях ТЯ возможности указать значение ключа архивации
для модификаторов не было. Параметр key_ поддерживается для следующих
модификаторов:
  %id([<outer>,][<CLASS>,][<key>]) - при разыменовании в другой тип
  %class([<outer>,][<CLASS>,][<key>])
  %classname([<outer>,][<CLASS>,][<key>])
  %classparent([<outer>,][<CLASS>,][<key>])
  %entity([<outer>,][<CLASS>,][<key>])
  %state([<outer>,][<CLASS>,][<key>])      - при получении значения
  %statename([<outer>,][<CLASS>,][<key>])
  %collection([<outer>,][<CLASS>,][<key>]) - при получении значения
  %parent([<outer>,][<CLASS>,][<PARENTCLASS.ATTR>,][<key>])
  %parentclass([<outer>,][<CLASS>,][<key>])
  %value([<outer>,][<CLASS>,]<qual>[,<%class>][,<key>])
  %lock([<wait>,][<CLASS>,][<%class>,][<timeout>,][<info>,][<key>]) - по ссылке
  %delete([<CLASS>,][<key>]) - только по ссылке
  %scn([<outer>,][<CLASS>,][<%class>,][<key>])
  %request([<%class>,][<info>,][<key>])
  %check([<%class>,][<key>])
  %size(<maxrownum>[,<key>])
  %attrs([<set>,][<ref>,][<quallist>,][<key>])

  Реализована возможность soft-смещения текущих значений ключей архивации
для секционированных типов путем присвоения числового значения модификатору
%key. При этом изменяются значения ключей архивации только в системном
контексте и в буфере пакета valmgr (хранимое значение в class_tables
не изменяется). Значение большее или равное нулю устанавливается текущим
для типа, которым определена ссылка для %key, пустое значение перечитывает
текущее хранимое значение из class_tables, отрицательное значение устанавливает
текущее значение ключа архивации, равное ключу секции, номер которой
отсчитывается вниз от актуального по модулю заданного значения.
  Дополнительным параметром в %key можно передать логический признак
распространения заданного значения по иерархии типов (значение true -
используется по умолчанию).

  При использовании явно указываемых через параметр key_ значений ключей
архивации в операторах ссылки и в модификаторах выборок, поисков, курсоров
(операторы FOR/LOCATE/SELECT), SQL-операторов UPDATE/DELETE (только для Oracle
partitions) для базовых типов (из основного списка IN, а не присоединяемых
по ссылкам или коллекциям) по умолчанию используется принцип распространения
значений ключей по иерархии типов (как в интерфейсах типов - см.п.5.16).
Распространения ключей не происходит при использовании типизованных ссылок
(т.е. заданное значение ключа используется только в том типе, которым
определена ссылка).

1.30. В версии ТЯ  и выше реализована возможность объединения основной
операции и ее расширения в один PL/SQL пакет.
  Основные преимущества объединения операций в один пакет:
- устраняется неопределенность с глобальными переменными пакетов
  основной операции и расширения - они теперь находятся в одном
  пакете;
- устраняется разрыв в отслеживании состояния кэша экземпляра
  this (в разных пакетах используется свой кэш в каждом пакете;
  в едином пакете, кэш тоже един);
- отсутствие лишних взаимозависимостей пакетов и межпакетных
  вызовов.
Объединение пакетов реализовано следующим образом:
- глобальные описания базовой операции и расширения объединяются
  как есть;
- к глобальным описаниям добавляется список глобальных переменных
  расширения (по определению расширения этот список в себя включает
  все глобальные переменные базовой операции);
- локальные описания базовой операции и расширения объединяются
  как есть;
- тексты VALIDATE и EXECUTE формируются на основе текста расширения,
  в которых код VALIDATE и EXECUTE базовой операции оформляются
  в виде вложенных процедур/функций с именами BASE$VALIDATE и
  BASE$EXECUTE, соответственно;
- имя общего пакета формируется по имени базовой операции, в который
  включаются все объединенные глобальные описания, а также процедуры
  и функции VALIDATE/EXECUTE, сформированные по именам как расширения,
  так и базовой операции (которые реализованы перевызовом VALIDATE/EXECUTE
  расширения);
- т.о. все операции, вызывающие базовую операцию или ее расширение,
  перенаправляются на один пакет.
Возможная проблема при таком объединении - использование одинаковых
имен переменных/функций/процедур в глобальных и локальных описаниях
базовой операции и расширения.
  Для расширений, у которых не создается собственный пакет (т.е.
создается общий пакет с именем базовой операции) в поле methods.package_name
записывается пустое значение.
  В функцию создания расширений method_mgr.set_extension добавлен
умолчательный параметр p_standalone (тип varchar2 default null),
управляющий режимом генерации расширений при указании следующих значений:
  - 'Y','1' - для расширения создается собственный пакет (режим
              создания расширений от прежних версий ТЯ);
  - другое непустое значение - собственный пакет для расширения не
              создается, создается один пакет по имени базовой операции;
  - пустое значение (значение по умолчанию) - режим создания определяется
              системной настройкой PLP_STANDALONE_EXTENSION (см.п.4.19).


- реализованы обращения к реквизитам экземпляров по ссылке через
  именованные функции-реквизиты интерфейсных пакетов типов (см.п.3.3);

1.31 Разъяснения по использованию системного параметра PLP_EXTENSION_SYS_SWITCH.
Как будет происходить выполнение такого кода:

     ref Т2 -> ([T1])[OP];

+------------------------+-----------------+-------------------+
|                        |Исходная операция|Расширение операции|
+------------------------+-----------------+-------------------+
|«Родительский» тип (Т1) |        OP       |      OP_EXT       |
+------------------------+-----------------+-------------------+
|«Дочерний» тип (Т2)     |        OP       |                   |
+------------------------+-----------------+-------------------+

при PLP_EXTENSION_SYS_SWITCH = 1:

  Т1.ОР_ЕХТ. Выполнится системный код, прикладной код не выполнится;
  Т2.ОР. Выполнится системный код, выполнится прикладной код.

при PLP_EXTENSION_SYS_SWITCH <> 1:
   
  Т1.ОР_ЕХТ. Выполнится системный код, выполнится прикладной код до &BASE$EXECUTE;
  Т1.ОР. Выполнится системный код, прикладной код не выполнится;
  Т2.ОР. Выполнится системный код, выполнится прикладной код;
  Т1.ОР. Продолжит выполнение системный код, прикладной код не выполнится;
  Т1.ОР_ЕХТ. Выполнится прикладной код после &BASE$EXECUTE.


        2. Компиляция PL/Plus запросов.

2.1. Разъяснение по поводу использования прагмы RESTRICT_REFERENCES. В версии
Oracle 8 и выше при использовании функций в запросах эту прагму указывать не
обязательно, т.к. Oracle отслеживает выполняемые функцией действия (в случае
динамических запросов это можно сделать только на этапе выполнения), и в случае
выполнения недопустимых действий, генерит исключение. На текущий момент не совсем
понятно, делаются ли указанные проверки в случае явного указания прагмы, возможно,
она как-то все-таки влияет на механизм проверки, упрощая и ускоряя его, хотя
последнее не замечено.
  Препроцессором Pl/Plus используются следующие правила для вызовов глобальных
функций в SQL-выражениях:
  а) вызовы функций, у которых указана прагма restrict_references (WNDS),
     включаются в текст запроса безусловно. Поэтому, если
     значения таких функций не зависят от выбираемых записей
     в запросе (т.е. не используют обращения к колонкам выбираемых записей),
     то рекомендуется пере присвоить значение функции буферной переменной
     и в запросе использовать эту переменную (это может значительно ускорить
     время выполнения запроса, т.к. значения функции вычисляются на каждую
     выбираемую запись в запросе). Если прагма restrict_references (WNDS)
     задана только в локальных описаниях, то соответствующая функция PL/SQL
     пакета операции такой прагмой обладать не будет.
  б) вызовы функций, у которых не указана прагма restrict_references (WNDS),
     в случае отсутствия зависимости от выбираемых записей в запросе
     (т.е. не используют обращения к колонкам выбираемых записей)
     автоматически выносятся из SQL-выражения, т.е. заменяются на используемую
     временную буферную переменную, которой предварительно присваивается значение
     функции. Если зависимость от выбираемых записей все-таки задана,
     то в версиях ТЯ до 6.4 возникает ошибка компиляции, а в версиях
     ТЯ 6.4 и выше выдается предупреждение и вызов функций включается
     в SQL-выражение.

2.2. Разъяснение по поводу использования order by совместно с групповыми
операторами (UNION/MINUS/INTERSECT). Сортировка в таком запросе относится
ко всей выборке в целом, а не к последнему запросу, соответственно,
выражения сортировки могут обращаться только к полям всей выборки, а не
ее составляющих.

2.3. Не рекомендуется использовать в Pl/Plus имена ID, CLASS_ID, STATE_ID,
COLLECTION_ID и начинающиеся с префикса С_ для имен переменных и параметров
процедур и функций. Особенно это критично при использовании таких переменных
в PL/Plus запросах, т.к. эти запросы транслируются в обращения к именам
колонок таблиц, которые могут совпасть с указанными именами (в этом случае
имена колонок переопределяют имена переменных в запросах). Категорически
не рекомендуется использовать имена ID, CLASS_ID, STATE_ID, COLLECTION_ID
для именования реквизитов в типах, т.к. это может существенно нарушить
логику получения значений соответствующих модификаторов и поддержку
системных колонок в типе, если в нем будет создана таблица.

2.4. Изменен и расширен механизм использования внешних соединений (outer joins)
в FOR/LOCATE/SELECT выражениях. Операторы ссылок, модификаторы и реквизиты
могут принимать первым параметром логическую константу (false - inner join, true -
outer join). Порядок взаимодействия этих параметров следующий - параметр при
операторе ссылки имеет приоритет перед параметром при реквизите, если параметр
при ссылке отсутствует, то параметр при реквизите распространяется и на join,
предшествующий этому реквизиту. Если явно тип соединений не прописан, тогда
используется следующая умолчательная схема проставления типов соединений -
в SELECT, GROUP BY, ORDER BY, RETURN списках используется внешнее соединение,
в условиях WHERE, CONNECT, START, HAVING, LOCK используется строгое (внутреннее)
соединение. В конструкции WHERE, содержащем ветвление по условию ИЛИ (OR),
при определенных условиях используется внешнее соединение (см.п.2.5).
Внутреннее соединение также всегда используется (независимо от конструкции
SQL-выражения) для иерархического связывания таблиц (связь по ID потомок-
родитель). Если одинаковые выражения с join-ами, используются в разных
конструкциях, имеющих разное умолчательное поведение при связывании таблиц,
тогда приоритет имеет внутреннее соединение (inner join).
Если в выражениях явно используется определение типа соединения (первый
логический параметр оператора ссылки или модификатора), то приоритет
имеет явное указание. Если используется несколько явных определений
типа соединения, тогда будет использован последний тип соединения в
соответствующей синтаксической конструкции, причем порядок самих
конструкций используется следующий: SELECT - RETURN - LOCK - ORDER BY -
GROUP BY - HAVING - WHERE - CONNECT - START.

2.5. Определение типа соединения (inner join - outer join) по ссылкам в
разных ветках условия ИЛИ (OR). По умолчанию используется внешнее
соединение (outer join). Если соединение используется во ВСЕХ ветках ИЛИ или
используется вне условия ИЛИ (в условии по И), тогда используется
внутреннее соединение (inner join). Если же в разыменовании ссылки
указывается явный тип соединения (первым параметром true-false у оператора
ссылки или модификатора), тогда используется именно он.
		Пример:
	locate d in [MAIN_DOCUM] where d.date_prov is not null and -- outer join
	(d.[PROV_USER]=stdlib.user_id or d.[PROV_USER].[USERNAME]='SYSTEM');
	locate d in [MAIN_DOCUM] where d.date_prov is not null and -- inner join
	(d.[PROV_USER]=stdlib.user_id or d.[PROV_USER]->(false)[USERNAME]='SYSTEM');
	locate d in [MAIN_DOCUM] where d.date_prov is not null and -- inner join
	(d.[PROV_USER].[USERNAME]=USER or d.[PROV_USER].[USERNAME]='SYSTEM');
	locate d in [MAIN_DOCUM] where d.date_prov is not null and -- outer join
	(d.[PROV_USER].[USERNAME]=USER or d.[PROV_USER]->(true)[USERNAME]='SYSTEM');
	locate d in [MAIN_DOCUM] where d.[PROV_USER].[NAME] is not null and -- inner join
	(d.[PROV_USER]=stdlib.user_id or d.[PROV_USER].[USERNAME]='SYSTEM');

2.6. При формировании списка таблиц и их соединений при разыменовании по
ссылкам и коллекциям используются следующие принципы:
- для используемых типов в списке источников данных для PL/Plus и SQL-запросов
  безусловно добавляется базовая (собственная) таблица без дополнительных
  условий (кроме возможного условия на коллекцию, если над типом определены
  коллекции - см.п.2.18). Для типов, у которых отсутствуют признак наличия
  экземпляров и собственная таблица, в качестве базовой выступает таблица
  ближайшего вверх по иерархии родительского типа, имеющего собственную
  таблицу.
- при обращении к реквизитам родительских типов, родительская таблица
  безусловно добавляется в список таблиц, также добавляется условие AND (И)
  для соединения по ID c собственной таблицей типа в верхнюю ветвь общего
  условия WHERE с заданным типом соединения (явно или неявно - см.пп.2.4).
- при обработке условий по AND (И) новые таблицы по ссылкам и коллекциям
  безусловно добавляются в список таблиц в порядке разыменования ссылочных
  реквизитов. Условия соединения добавляются в верхнюю ветвь общего условия
  WHERE также по AND (И) с заданным типом соединения (явно или неявно - см.пп.2.4).
- при обработке условий по OR (ИЛИ) новые таблицы по ссылкам и коллекциям
  всегда добавляются в список таблиц в порядке разыменования ссылочных
  реквизитов, только если эти разыменования порождают разные таблицы, либо
  разыменование происходит по одним и тем же реквизитам (и в той же
  последовательности) в обеих ветвях OR (фактически это означает вынесение
  условия за пределы OR), либо разыменование используется в только в одной
  из ветвей OR. Если при разыменовании по разным реквизитам (в разных ветвях
  OR) получается соединение с одной и той же таблицей, то новая таблица может
  не добавляться, тогда будет переиспользоваться уже существующая, полученная из
  другой ветви OR (т.е. добавится одна таблица на оба разыменования в каждой из
  ветвей); при этом условие соединения с этой таблицей добавится не на верхний
  уровень WHERE, а в каждую из ветвей OR, причем по соответствующему ссылочному
  реквизиту. Начиная с версии ТЯ 6.5, описанная нормализация списка используемых
  таблиц для разных ветвей OR производится только в режиме оптимизации кода
  операций (опция code прагмы optimize).
		Пример:
    a)  locate exact d in [MAIN_DOCUM] where rownum=1 and
          d.[ACC_DT].[MAIN_V_ID] like shabl1 and d.[ACC_KT].[MAIN_V_ID] like shabl2;
    b)  locate exact d in [MAIN_DOCUM] where rownum=1 and
          (d.[ACC_DT].[MAIN_V_ID] like shabl1 or d.[ACC_KT].[MAIN_V_ID] like shabl2);
                Преобразуется в:
    a)  select  a1.id into D
        from Z#AC_FIN a3, Z#AC_FIN a2, Z#MAIN_DOCUM a1
        where a1.C_ACC_DT=a2.id and a1.C_ACC_KT=a3.id
          and (ROWNUM = 1 and a2.C_MAIN_V_ID like SHABL1 and a3.C_MAIN_V_ID like SHABL2);
    b1) с оптимизацией кода:
	select  a1.id into D
        from Z#AC_FIN a2, Z#MAIN_DOCUM a1
        where ROWNUM = 1 and (
              (a1.C_ACC_DT=a2.id and (a2.C_MAIN_V_ID like SHABL1))
           or (a1.C_ACC_KT=a2.id and (a2.C_MAIN_V_ID like SHABL2)));
    b2) без оптимизации кода (ТЯ 6.5):
        select  a1.id into D
        from Z#AC_FIN a3, Z#AC_FIN a2, Z#MAIN_DOCUM a1
        where a1.C_ACC_DT=a2.id(+) and a1.C_ACC_KT=a3.id(+)
          and (ROWNUM = 1 and a2.C_MAIN_V_ID like SHABL1 or a3.C_MAIN_V_ID like SHABL2);

2.7. Выражения для ТБП и коллекций, по которым строятся выборки, в качестве
первого параметра могут принимать либо числовую константу (определяющую
номер архивной секции считая от текущего вглубь архива, 0 означает текущая
секция) либо строковую константу со значением 'ALL', означающую отсутствие
указания архивной секции и добавления умолчательного условия на ключ
секционирования:
        Locate rec in Obj.[ARC_MOVE](0)  where rec.[DOC] = P_DOC;
        -- поиск выписки только по актуальной секции.
        Locate rec in Obj.[ARC_MOVE]('ALL')  where rec.[DOC] = P_DOC;
        -- поиск выписки по всем архивным и актуальной секции.
Явное указание области поиска позволяет получить результирующий код
независимо от внешних настроек (флага "Условие архивации" в свойствах операции
и настройки PLP_ACTUAL_PARTITION_ONLY - см.также 4.3, 4.10).

2.8. Добавлена возможность указания типа соединения таблиц в выборкe
(внутреннего или внешнего - outer), а также переопределения типов в
PL/Plus модификаторах по аналогии с оператором ссылки. Т.о. все модификаторы,
применяемые по ссылке, могут принимать первым параметром логическую
константу, определяющую тип соединения (false - inner join, true - outer join),
а вторым (или первым, если логическая константа опущена) выражение для типа,
который переопределяет тип ссылки, к которой применен модификатор.
Переопределить можно только на тип, находящийся в родственной связи
child-parent или parent-child c типом самой ссылки.
		Пример:
    for c in [CLIENT] where c%class(true,::[CL_BANK])='CL_BANK_N' loop
	null;
    end loop;

2.9. Расширено использование параметров указания типа соединения (inner/outer joins) и
переопределения типа для модификатора %ID в случае использования в pl/plus-запросах,
позволяющее использовать связывание иерархических типов между собой. Как замечание
можно отметить, что если связывание происходит непосредственно от основной таблицы
(не по ссылке), тогда всегда используется внутреннее соединение независимо от того,
где используется такая конструкция (см. п.2.4).
		Пример:
        for (select t(
            DECODE( t%id(true,::[CL_PRIV] )
                  , t%id,  ::[CL_PRIV]%classname
                  , DECODE( t%id(true,::[CL_CORP] )
                          , t%id,  ::[CL_CORP]%classname)
                  , 'Другие')
        ) in ::[CLIENT])
        loop exit; end loop;
                Преобразуется в:
	declare
		cursor c_obj is
			select  DECODE(a2.ID,a1.ID,'Физические лица'
                                       ,DECODE(a3.ID,a1.ID,'Юридические лица')
                                       ,'Другие') A$1
			from Z#CL_CORP a3, Z#CL_PRIV a2, Z#CLIENT a1
			where a1.id=a2.id(+) and a1.id=a3.id(+);
		T	c_obj%rowtype;
	begin
		for plp$c_obj in c_obj loop
			T := plp$c_obj;
			exit ;
		end loop;
	end;

2.10. Добавлена прагма TYPED_JOINS, которая определяет режим использования
типизованных ссылок. Когда включается режим типизованных ссылок (с помощью
указания значения true в качестве параметра), то все обращения по любым ссылкам
(а также модификаторам) интерпретируются как типизованные. Если режим
выключается (false в качестве параметра), то типизация ссылки или модификатора
может быть указана только явно (символом '%'). По умолчанию используются
обычные (не типизованные ссылки). В версии ТЯ 6.5 и выше типизованный модификатор
%ID (%%ID) также предписывает делать соединение с ссылаемым типом. Синтаксис
типизованных ссылок (%->, %=>) и типизованного оператора-модификатора (%%)
при использовании в выборках предписывает всегда использовать соединение
с той таблицей, которой определена ссылка, даже если разыменовываемые реквизиты
не находятся в собственной таблице (например, в родительской таблице по отношению
к типу ссылки):
		Пример:
        declare
          ac ref [AC_FIN];
          v_name string;
          v_id  ref [FT_MONEY];
        begin
          -- реквизит [AC_FIN].[FINTOOL] определен как ссылка на [FT_MONEY]
          locate exact ac in [AC_FIN]
           where ac.fintool->name  like v_name and ac.fintool%class='FT_MONEY'  and rownum=1;
          locate exact ac in [AC_FIN]
           where ac.fintool%->name like v_name and rownum=1; -- условие %class='FT_MONEY'
              -- не нужно, т.к. соединение с типом FT_MONEY задано типизованной ссылкой
          select a(a.fintool%id,a.fintool%%id) in [AC_FIN] where rownum=1
            into v_id,v_id;
        end;
                Преобразуется:
declare
        AC	number;
        V_NAME	varchar2(128);
	V_ID	number;
begin
        begin
                        select  a1.id
                        into AC
                        from Z#AC_FIN a1, Z#FINTOOL a2
                        where a1.C_FINTOOL=a2.id
                          and (a2.C_NAME like V_NAME and a2.CLASS_ID = 'FT_MONEY' and ROWNUM = 1);
        exception
                when NO_DATA_FOUND then raise rtl.NO_DATA_FOUND;
                when TOO_MANY_ROWS then raise rtl.TOO_MANY_ROWS;
        end;
        begin
                        select  a1.id
                        into AC
                        from Z#AC_FIN a1, Z#FT_MONEY a2, Z#FINTOOL a3
                        where a1.C_FINTOOL=a2.id and a2.id=a3.id
                          and (a3.C_NAME like V_NAME and ROWNUM = 1);
        exception
                when NO_DATA_FOUND then raise rtl.NO_DATA_FOUND;
                when TOO_MANY_ROWS then raise rtl.TOO_MANY_ROWS;
        end;
        begin
                        select  a1.C_FINTOOL, a2.ID
                        into V_ID, V_ID
                        from Z#FT_MONEY a2, Z#AC_FIN a1
                        where a1.C_FINTOOL=a2.id(+)
                          and (ROWNUM = 1);
        exception
                when NO_DATA_FOUND then raise rtl.NO_DATA_FOUND;
                when TOO_MANY_ROWS then raise rtl.TOO_MANY_ROWS;
        end;
end;

2.11. При формировании описания курсора main для определения
пользовательских представлений допустимо использование опции
others, в которой можно задать дополнительное условие проверки,
которое будет добавлено в ветку проверки прав доступа для
субъекта доступа при формировании результирующего текста view.
Блок others в курсор main автоматически добавляется если задано
условие проверки поэкземплярного доступа в свойствах представления
(закладка "Флаги", кнопка "Доступ к экземплярам..."), при этом
основная ссылка курсора main распознается как через переменную-алиас
курсора, так и через мнемонический алиас "A1." (в простых
представлениях -  "A1_1."). Одновременное использование и блока
others в тексте курсора и условия поэкземплярного доступа в
свойствах представления приведет к ошибке.
		Синтаксис:
        type main is <PL/Plus subquery> others <condition>;
где <PL/Plus subquery> - основной текст выборки,
    <condition> - дополнительное условие.
                Пример:
        type main is
            select u(u.[name]:name) in [USER]
            others u.[depart]%access_ref;
                Результат:
/* CREATE OR REPLACE VIEW VW_RPT_XXXXXXX AS */
SELECT
A1.Id ID, 'USER' Class_Id,
a1.C_NAME NAME
		from Z#USER a1
 WHERE
  ( SYS_CONTEXT('IBS_SYSTEM','ADMIN')='1' OR EXISTS
    ( -- доступ к представлению
      SELECT 1 FROM Criteria_Rights M_R, Subj_Equal SE
       WHERE M_R.Obj_Id ='91903558' ---$$$---
         AND M_R.Subj_Id=SE.Equal_Id AND SE.Subj_Id=SYS_CONTEXT('IBS_SYSTEM','USER')
    )
    AND ( -- условие others
	exists (select 1 from object_rights_ex o, subj_equal e
         where e.subj_id=SYS_CONTEXT('IBS_SYSTEM','USER')
           and o.subj_id=e.equal_id and o.obj_id=a1.C_DEPART
           and o.right_class_id='USER' and o.class_id='DEPART')
	
    )
  )

2.12. В PL/Plus представлениях добавлена возможность управления
выбором значения для колонки-ссылки, по которой осуществляется навигация
(проваливание) при просмотре данных в Навигаторе. Подробности
описаны в plplus.txt - п.2.1 изменений на 20.11.2006,
п.2.3 изменений на 01.03.2006, п.2.5 изменений на 10.07.2005.

2.13. Разъяснение по колонке "Состояние" в PL/Plus представлениях.
Колонка "Состояние" создается только для выбираемого значения
модификатора %statename (который применяется только по ссылке)
в верхнеуровневом списке выбираемых значений основного курсора
main. Значение %statename во вложенных подзапросах и курсорах,
а также при объединении запросов (операторами UNION/MINUS/INTERSECT)
интерпретируется как обычная строка, т.к. для формирования колонки
"Состояние" требуется значение ID состояния (т.е. %state) и исходная ссылка,
которые не выводятся в верхнеуровневый список выборки из вложенных
подзапросов.

2.14. Разъяснение по использованию опции one by one в итераторе
FOR. Если в итераторе используется блокировка данных (опцией lock),
то совместно с опцией one by one блокировка происходит по одному
экземпляру по мере их извлечения итератором (без опции one by one
вся выборка блокируется сразу при входе в цикл). Опция one by one
также определяет порядок сортировки по идентификатору (ID) экземпляра,
(при этом игнорируется задаваемый порядок выборки - order by, если он
указан), а также определяет хинт FIRST_ROWS (получение первой записи)
оптимизатору Oracle, если явно не указан никакой другой хинт для заданного
цикла (например, прагмой hint). Использование цикла с one by one полезно
в том смысле, что соответствующий PL/SQL курсор для такой выборки будет
всегда закрытым, что особенно важно при больших модификациях базы данных
внутри цикла, когда при открытом курсоре может произойти переполнение
системных буферов ORACLE (ROLLBACK-сегментов), чего не происходит при
закрытом курсоре (см. также п.1.23). Идеологически опция работает следующим
образом - к заданному условию добавляется условие на сравнение с ID,
устанавливается сортировка по ID, выполняется запрос по получившемуся курсору,
извлекается первая запись (собственно, поэтому и используется по умолчанию
хинт FIRST_ROWS), после чего курсор закрывается. Обрабатывается тело цикла
итератора, затем снова открывается курсор, извлекается следующая запись
(это обеспечивается дополнительным условием на ID и сортировкой по ID),
курсор закрывается. Если курсор ничего не извлек, то осуществляется выход
из цикла.

2.15. Разъяснение по использованию конструкций вида PL/Plus
insert as select с автоматической генерацией новых значений
последовательностей (для ID, коллекций и автоматических реквизитов).
Если в конструкции insert as select в коде PL/Plus в select-листе
явно указаны не все значения для ID, коллекций или автоматических
реквизитов, тогда для них используются автоматические выражения
по получению следующих значений соответствующих последовательностей
вида <sequence>.NEXTVAL (для ID и коллекций - это SEQ_ID.NEXTVAL).
В версии ТЯ 6.5.1 и выше если одна и та же последовательность
используется в автоматических выражениях более одного раза
(например, SEQ_ID - для инициализации как ID, так и реквизитов-коллекций),
то для дублирующих выражений используется уже не <sequence>.NEXTVAL,
а вызов функции rtl.next_value('<sequence>'). Связано это с тем,
что выражение <sequence>.NEXTVAL для одной и той же строки выборки
возвращает одно и то же значение, независимо от того, сколько
раз оно используется в выражениях для строки выборки. Вызовы
rtl.next_value генерят всегда разные значения, в т.ч. и при
использовании в выражениях для одной и той же строки выборки.
Эту особенность нужно иметь в виду при использовании insert as select
при указании как явных, так и неявных выражений для инициализации
автоматических значений. В версии ТЯ 6.5.1 о неявных выражениях
можно не заботиться, т.к. на уровне генерации кода дублирования
значений последовательностей не будет. Дополнительно следует
отметить, что использовать директиву distinct в select-листе
нельзя, т.к. список выборки может быть дополнен автоматическими
выражениями вида <sequence>.NEXTVAL, которые несовместимы
c distinct, а также не имеет смысла, т.к. даже явные выражения
должны обеспечивать уникальность значений (которые при вставке
новых записей контролируются соответствующими ограничениями
целостности на уровне БД).

2.16. Разъяснение по использованию пользовательских условий
на соединение (joins) таблиц. Если некая колонка таблицы,
по которой производится соединение, индексирована и в запросе
необходимо задействовать этот индекс, тогда условие на
колонку не должно содержать использование функций от этой
колонки, в т.ч. функций неявного преобразования типов.
		Пример:
        for m in [MAIN_DOCUM] where upper(m%state)='PROV'
        loop exit; end loop;
        -- индекс по состоянию использоваться не будет, т.к. указана функция upper
        -- (его и не нужно использовать, т.к. для состояния 'PROV' индекс не селективен
        for m in [MAIN_DOCUM] where m%state='FORM'
        loop exit; end loop;
        -- индекс по состоянию будет использоваться, т.к. нет никаких преобразований
        -- (для состояния 'FORM' индекс имеет хорошую селективность).
        for ( select m(m) in [MAIN_DOCUM], (OBJECT_STATE_HISTORY%rowtype:o)
           where m.[date_prov]>=d1 and m.[date_prov]<d2
             and o.[time]>=d1 and o.[time]<d2
             and o.[obj_id]=m%id  -- условие соединения
        ) loop exit; end loop;
        -- индекс по OBJECT_STATE_HISTORY.OBJ_ID (по истории состояния документов)
        -- в версии ТЯ 6.5 и выше использоваться не будет, т.к. тип колонки
        -- OBJ_ID в этом случае будет строковый (см.п.6.12, колонка же Z#MAIN_DOCUM.ID -
        -- числовая), так что в условии на соединение таблиц будет выполняться
        -- неявное приведение типов, эквивалентное выражению: to_number(o.[obj_id])=m%id
        for ( select m(m) in [MAIN_DOCUM], (OBJECT_STATE_HISTORY%rowtype:o)
           where m.[date_prov]>=d1 and m.[date_prov]<d2
             and o.[time]>=d1 and o.[time]<d2
             and o.[obj_id]=to_char(m%id)  -- условие c явным приведением типов
        ) loop exit; end loop;
        -- индекс по OBJECT_STATE_HISTORY.OBJ_ID (по истории состояния документов)
        -- в версии ТЯ 6.5 и выше уже будет использоваться, т.к. условие на соединение
        -- таблиц содержит явное приведение типов без использования функций над OBJ_ID
В связи с описанной особенностью использования индексов по условиям, использующим
неявное приведение типов, рекомендуется использовать только явные преобразования типов в
join-выражении, позволяющем использовать индекс (если это действительно необходимо).
То же относится и к ситуации с изменением типов колонок, участвующих
в индексированных поисках, - рекомендуется в запросах, использующих условия
для поиска по таким колонкам, использовать явное приведение типов.

2.17. Разъяснение по использованию операторов SELECT ... INTO и LOCATE EXACT
(упрощенный вариант SELECT INTO) при получении значений скалярных выражений.
В случае, когда запрос возвращает более одной записи (и, соответственно,
возникает исключение TOO_MANY_ROWS) значения в переменные приемники списка
INTO сначала заполняются первой извлеченной строкой, а уж потом возникает
ошибка (в отличие от NO_DATA_FOUND, когда переменные-приемники не
модифицируются).

2.18. Разъяснение по наложению условия на значения колонки COLLECTION_ID
на таблицах типов, используемых в списке источников данных в PL/Plus-запросах:
- при наличии признака all (поиск по всем экземплярам) для заданного типа,
  условие на COLLECTION_ID не накладывается никогда;
- при наличии признака collections (поиск по коллекциям) для заданного
  типа накладывается условие COLLECTION_ID is not null, при отсутствии
  дополнительных признаков (поиск экземпляров, не входящих в коллекции)
  накладывается условие COLLECTION_ID is null в случае соблюдения
  любого из следующих дополнительных условий:
  -- колонка COLLECTION_ID присутствует в базовой таблице типа,
  -- колонка COLLECTION_ID присутствует в таблице любого из дочерних
     типов,
  -- колонка COLLECTION_ID присутствует в родительской таблице типа,
     над которым определена физическая или временная коллекция;
  при этом условие накладывается на колонку базовой или ближайшей
  родительской таблицы, в последнем случае родительская таблица
  добавляется также в список источников данных с дополнительным
  условием на соединение по ID с базовой таблицей.
Условия, при которых создается колонка COLLECTION_ID в таблицах
типов описаны в п.3.10.

2.19. В версии ТЯ 7.2 и выше реализовано предупреждение при генерации
текстов SQL-операторов insert/update/delete по подзапросу, т.к.
выполнение DML-операций по подзапросам обладает рядом ограничений,
которым произвольные запросы, как правило, не удовлетворяют.

2.20. В версии ТЯ 7.2 и выше реализовано соединение таблиц
при разыменовании ссылок, определенных как функциональные реквизиты
(через вызов функций интерфейсных пакетов типов), однако следует
иметь в виду, что такое соединение не очень эффективно, так
что рекомендуется определить SQL-значение для таких реквизитов,
чтобы избежать соединения через функцию.

2.21. В версии ТЯ 7.2 и выше реализовано переупорядочивание списка
параметров функций с именованными параметрами при использовании
в SQL-выражениях.

2.22. В версии ТЯ 7.2 и выше реализовано использование скобок в
операторах UNION/MINUS/INTERSECT в SQL-запросах (ранее скобки
разворачивались в дополнительные подзапросы).


        3. Типы данных.

3.1. Предустановленные системные типы:
PL/Plus     PL/SQL        SQL            Comment
STRING      VARCHAR2(128) VARCHAR2(128)  строка
NUMBER      NUMBER        NUMBER         число
DATE        DATE          DATE           дата
BOOLEAN     BOOLEAN       VARCHAR2(1)    логика
MEMO        VARCHAR2(2000)VARCHAR2(2000) мемо-строка
INTEGER     PLS_INTEGER   NUMBER         целое число (от -2147483648 до 2147483647).
EXCEPTION   EXCEPTION     -              исключение (в SQL использоваться не может)
BOOLSTRING  VARCHAR2(1)   VARCHAR2(1)    строка длины 1, строковое представление логики
                                         ('1' соответствует true, '0' - false, '' - null)
REFSTRING   VARCHAR2(128) VARCHAR2(128)  строка для хранения ID экземпляров, в т.ч. метаклассов
REFERENCE   VARCHAR2(128) VARCHAR2(128)  обобщенная ссылка (в т.ч. и на метакласс)
COLLECTION  NUMBER        NUMBER         обобщенная коллекция
OBJECT      RTL.OBJECT_REC  -            структура системных реквизитов ТБП
ROWID       ROWID         ROWID          системный адрес записи в БД
RAW         RAW(2000)     RAW(2000)      бинарная строка (работа через utils, utl_raw)
LONG        LONG          LONG           long строка
LONG RAW    LONG RAW      LONG RAW       long raw бинарная строка (работа через utils, utl_raw)
BLOB        BLOB          BLOB           бинарные данные (до 2GB) (работа через dbms_lob)
CLOB        CLOB          CLOB           строковые данные (до 2GB) (работа через dbms_lob)
BFILE       BFILE         BFILE          бинарный файл данных (до 2GB) (работа через dbms_lob)
TIMESTAMP   TIMESTAMP(9)  TIMESTAMP_UNCONSTRAINED - дата со временем (до наносекунд)
TIMESTAMP_TZ TIMESTAMP(9) TIMESTAMP_TZ_UNCONSTRAINED - дата со временем (до наносекунд) в абсолютной временной зоне
             WITH TIME
             ZONE
TIMESTAMP_LTZ TIMESTAMP(9) TIMESTAMP_LTZ_UNCONSTRAINED - дата со временем (до наносекунд) в локальной временной зоне
             WITH LOCAL
             TIME ZONE
INTERVAL     INTERVAL     DSINTERVAL_UNCONSTRAINED - интервал времени дни-секунды (до наносекунд)
             DAY(9) TO SECOND(9)
INTERVAL_YM  INTERVAL     YMINTERVAL_UNCONSTRAINED - интервал времени годы-месяцы
             YEAR(9)TO MONTH
BINARY_FLOAT  BINARY_FLOAT  BINARY_FLOAT   стандартное (IEEE-754) 4-байтовое число
                                           с плавающей точкой
BINARY_DOUBLE BINARY_DOUBLE BINARY_DOUBLE  стандартное (IEEE-754) 8-байтовое число
                                           с плавающей точкой

Типы TIMESTAMP/INTERVAL могут использоваться для версии Oracle9i и выше.
Типы BINARY.. могут использоваться для версии Oracle10g и выше.

Разъяснение по поводу использования типа integer в PL/Plus. Этот тип
отображается в pls_integer PL/SQL, который эквивалентен 4-байтовому целому
числу (от -2147483648 до 2147483647). Т.е. это совсем не тот integer, который
есть в SQL (до 38 знаков), и это нужно учитывать при написании кода операций.
Сделано это в целях оптимизации целочисленных вычислений и индексирования
pl/sql таблиц, которые выполняются значительно быстрее, чем вычисления
чисел с плавающей точкой (таковыми являются все числовые типы, кроме
pls_integer).

3.2. Реализованы следующие производные типы для ТБП, которые могут использоваться
в конструкциях PL/Plus (см.ниже):
   1.1. Rowtype тип, представляющий собой планарную структуру,
        соответствующую таблице типа (если таковая имеется), где
        все вложенные подструктуры развернуты до скалярных реквизитов
        (в эту структуру не входят родительские реквизиты, если только
        они не являются дублированными). При этом PL/SQL типы
        приводятся к SQL типам (INTEGER - NUMBER, BOOLEAN - BOOLSTRING,
        размеры строк, большие 4000, ограничиваются значением 4000).
        В структуру также входят и поля, соответствующие системным
        реквизитам (ID,CLASS_ID,COLLECTION_ID,STATE_ID), которые есть
        в собственной таблице типа (если таковая имеется, см.п.3.10).
        Обращения к полям такой структуры аналогичны обращениям к полям
        обычной PL/SQL структуры ТБП (тип 2.1 - см. ниже), однако если
        конечный реквизит не будет скалярным, то такое разыменование
        будет ошибочным. Также будет ошибочным обращение к реквизитам
        родительских типов (если они не продублированы в дочернем).
        Последовательность полей и их имена в планарной структуре (Rowtype типа)
        соответствуют колонкам собственной таблицы типа. При наличии таблицы
        системные поля ID,CLASS_ID, а также COLLECTION_ID, STATE_ID (при их
        наличии, см.п.3.10) находятся в начале структуры в указанном порядке,
        при отсутствии таблицы порядок полей определяется так же, как и для
        обычной структуры (т.е. порядковыми номерами собственных реквизитов,
        см. тип 2.1), а системные поля отсутствуют.
   Определение типа:   [CLASS]%rowtype
                Пример:
        declare
          m [MAIN_DOCUM]%rowtype;
        begin
          stdio.put_line_buf(m.[KL_KT].[1].[2].[MAIN_V_ID]);
        end;
                Преобразуется:
        declare
                M  Z#MAIN_DOCUM#INTERFACE.CLSROW#MAIN_DOCUM;
        begin
                STDIO.PUT_LINE_BUF(Z#AC_FIN#INTERFACE.get_str(M.C_KL_KT#1#2,'MAIN_V_ID'));
        end;
   1.2. Таблица NESTED TABLE rowtype типа:
   TYPE type_name IS VARRAY(0) OF [CLASS]%rowtype;
   Этот тип, главным образом, предназначен для выполнения BULK операций
и создания реквизитов - вложенных массивов.
   При создании на уровне словаря IBSO вложенного массива, т.е. типа 1.2,
для элементов массива (типа 1.1) и самого вложенного массива создаются
SQL-типы Oracle (с именами Z#CLASS#TYPE и Z#CLASS#TABLE для типов 1.1 и 1.2,
соответственно, где CLASS - ID ТБП, от которого создаются производные типы),
в этом случае NESTED TABLE тип 1.2 может использоваться в SQL запросах напрямую
или через CAST преобразование.
При создании вложенных массивов в словаре IBSO нужно иметь в виду следующее:
- В версии Oracle8i в SQL-типах нельзя модифицировать структуру
  реквизитов, поэтому после создания этих типов категорически не рекомендуется
  изменять структуру и типы реквизитов в том типе, по которому задан вложенный
  массив.
- В версии Oracle9i допустима ограниченная модификация - только в сторону
  добавления новых реквизитов и изменения типа существующих (в плане увеличения
  размеров для строк или точности для чисел), причем если добавление новых
  реквизитов осуществляется в конец к существующим. Если тип модифицируется
  так, что потребуется добавление-удаление системных колонок (STATE_ID или
  COLLECTION_ID, либо создание таблицы), которые добавляются всегда в начало
  списка реквизитов, то такое действие не допустимо, поэтому этот момент
  нужно решить заранее - на архитектурном уровне.
- Если все-таки нежелательная модификация структуры реквизитов типа была
  произведена и привела к невозможности модификации существующих SQL-типов
  Oracle, тогда проблема может быть решена только через полное пересоздание
  SQL-типа (т.е. удаление типа со старой структурой и создание с новой - для
  этого есть служебная процедура), однако при этом прикладной разработчик
  должен будет сам позаботиться о сохранении-восстановлении данных,
  которые содержались в массиве со старой структурой типа (если таковые
  имелись), т.к. новые массивы будут созданы пустыми.
   2.1. PL/SQL тип, соответствующий ТБП. Этот тип существовал всегда,
        приводится для общности. В версии 6.0 в структуру типа
        (если тип - структура) добавлены также системные поля (ID,CLASS_ID,
        COLLECTION_ID,STATE_ID). Доступ к системным полям структуры 2.1
        (равно как и rowtype-структуры 1.1, которая есть и у скалярных типов),
        осуществляется через операторы-модификаторы %ID,%CLASS,%COLLECTION,
        %STATE, соответственно. Поля PL/SQL структуры типа упорядочиваются
        в соответствии с заданным порядковым номером реквизита в типе (при
        совпадении порядковых номеров реквизитов последовательность полей
        структуры определяется алфавитным порядком коротких имен реквизитов).
        Системные поля ID,CLASS_ID,COLLECTION_ID,STATE_ID всегда находятся
        в начале структуры в указанном порядке.
   Определение типа:   [CLASS]
   2.2. PL/SQL таблица (index by binary_integer) PL/SQL типа, соответствующего
        ТБП (тип 2.1):
   TYPE type_name IS TABLE OF [CLASS];
        Описания этих таблиц появилось начиная с версии 6.0. В версии Oracle8i
        этот тип нельзя объявлять, если структура ТБП содержит подструктуры или
        другие массивы.
   2.3. Rowtable тип - планарная структура PL/SQL таблиц (index by binary_integer).
        Эта структура содержит набор полей, развернутых до скалярных типов,
        а сами поля структуры определены как PL/SQL таблицы SQL-типов
        (образованных по принципу rowtype-типа 1.1) скалярных реквизитов,
        им соответствующих. Порядок разыменования полей тот же, что и для
        rowtype типа. В эту структуру входят, в отличие от rowtype-типа, поля
        всех реквизитов, в т.ч. родительских. Последовательность полей и их имена
        соответствуют колонкам таблиц типа (как собственной, так и родительских),
        причем сначала идут поля, соответствующие собственной таблице,
        затем идут поля ближайшей родительской таблицы, далее поля следующей
        по уровню иерархии родительской таблицы - вплоть до самого верхнеуровневого
        родителя. Структура Rowtable также содержит все системные поля ID,CLASS_ID,
        COLLECTION_ID,STATE_ID, которые всегда находятся в начале структуры
        в указанном порядке и доступны через модификаторы %ID,%CLASS,%COLLECTION,
        %STATE, соответственно. При отсутствии собственной таблицы типа порядок полей
        в пределах каждого из уровней иерархии определяется порядковым номером реквизита,
        (или алфавитным порядком коротких имен реквизитов при совпадении порядковых
        номеров).
   Определение типа:   [CLASS]%rowtable
                Пример:
        declare
          ut [USER]%rowtable;
        begin
          select u(u%id,u.name,u.username) in [USER] all
            into ut%id,ut.name,ut.username;
        end;
                Преобразуется:
        declare
                UT Z#USER#INTERFACE.CLSTBL#USER;
        begin
                select  a1.ID, a1.C_NAME, a1.C_USERNAME
                bulk collect into UT.ID, UT.C_NAME, UT.C_USERNAME
                from Z#USER a1;
        end;

3.3. SQL-типы для NESTED TABLES скалярных типов:
type TYPE_STRING_TABLE  is table of varchar2(32767)
type TYPE_MEMO_TABLE    is table of varchar2(4000)
type TYPE_REFSTRING_TABLE  is table of varchar2(128)
type TYPE_DEFSTRING_TABLE  is table of varchar2(256)
type TYPE_BOOLSTRING_TABLE is table of varchar2(1)
type TYPE_DATE_TABLE       is table of date
type TYPE_NUMBER_TABLE     is table of number
type TYPE_RAW_TABLE        is table of raw(2000)
type TYPE_LONGRAW_TABLE    is table of raw(32767)
type TYPE_BLOB_TABLE       is table of blob
type TYPE_CLOB_TABLE       is table of clob
type TYPE_BFILE_TABLE      is table of bfile
type TYPE_TIMESTAMP_TABLE      is table of timestamp_unconstrained
type TYPE_TIMESTAMP_TZ_TABLE   is table of timestamp_tz_unconstrained
type TYPE_TIMESTAMP_LTZ_TABLE  is table of timestamp_ltz_unconstrained
type TYPE_INTERVAL_TABLE       is table of dsinterval_unconstrained
type TYPE_INTERVAL_YM_TABLE    is table of yminterval_unconstrained
synonym TYPE_REFERENCE_TABLE for TYPE_NUMBER_TABLE
synonym TYPE_LONG_TABLE for TYPE_STRING_TABLE
synonym TYPE_LONG#RAW_TABLE for TYPE_LONGRAW_TABLE

3.4. Автоматическое переопределение типов NESTED TABLE в PL/Plus на SQL-типы:
TYPE name IS VARRAY(0) OF REF[class]       <-->  TYPE_NUMBER_TABLE
TYPE name IS VARRAY(0) OF [class_ARR]      <-->  TYPE_NUMBER_TABLE
TYPE name IS VARRAY(0) OF REF[kernelclass] <-->  TYPE_REFSTRING_TABLE
TYPE name IS VARRAY(0) OF STRING{(size)}   <-->  TYPE_MEMO_TABLE
TYPE name IS VARRAY(0) OF MEMO             <-->  TYPE_MEMO_TABLE
TYPE name IS VARRAY(0) OF REFSTRING        <-->  TYPE_REFSTRING_TABLE
TYPE name IS VARRAY(0) OF BOOLSTRING       <-->  TYPE_BOOLSTRING_TABLE
TYPE name IS VARRAY(0) OF BOOLEAN          <-->  TYPE_BOOLSTRING_TABLE
TYPE name IS VARRAY(0) OF DATE             <-->  TYPE_DATE_TABLE
TYPE name IS VARRAY(0) OF NUMBER{(sz{,pr})}<-->  TYPE_NUMBER_TABLE
TYPE name IS VARRAY(0) OF INTEGER          <-->  TYPE_NUMBER_TABLE
TYPE name IS VARRAY(0) OF RAW{(size)}      <-->  TYPE_RAW_TABLE
TYPE name IS VARRAY(0) OF BLOB             <-->  TYPE_BLOB_TABLE
TYPE name IS VARRAY(0) OF CLOB             <-->  TYPE_CLOB_TABLE
TYPE name IS VARRAY(0) OF BFILE            <-->  TYPE_BFILE_TABLE
TYPE name IS VARRAY(0) OF LONG             <-->  TYPE_STRING_TABLE
TYPE name IS VARRAY(0) OF LONG RAW         <-->  TYPE_LONGRAW_TABLE
TYPE name IS VARRAY(0) OF TIMESTAMP{(size)}<-->  TYPE_TIMESTAMP_TABLE
TYPE name IS VARRAY(0) OF TIMESTAMP(size,1)<-->  TYPE_TIMESTAMP_TZ_TABLE
TYPE name IS VARRAY(0) OF TIMESTAMP(size,2)<-->  TYPE_TIMESTAMP_LTZ_TABLE
TYPE name IS VARRAY(0) OF INTERVAL{(sz,pr)}<-->  TYPE_INTERVAL_TABLE
TYPE name IS VARRAY(0) OF INTERVAL(size)   <-->  TYPE_INTERVAL_YM_TABLE
При использовании скалярных вложенных массивов в PL/Plus запросах, обращение
к значению элемента массива следует осуществлять по имени COLUMN_VALUE.
                Пример:
        declare
          type accs_tbl is varray(0) of ref [ac_fin];
          type recs_tbl is varray(0) of ref [records];
          v_accs accs_tbl;
          v_recs recs_tbl;
        begin
          select a(a.column_value.arc_move%id) in v_accs
            into v_recs;
        end;

3.5. Автоматическое переопределение типов для index by integer таблиц:
TYPE name IS TABLE OF [OBJECT]         <-->  RTL.OBJECT_TABLE
TYPE name IS TABLE OF REF[class]       <-->  CONSTANT.NUMBER_TABLE    (RTL.REFERENCE_TABLE,dbms_sql.number_table)
TYPE name IS TABLE OF [class_ARR]      <-->  CONSTANT.NUMBER_TABLE    (RTL.REFERENCE_TABLE,dbms_sql.number_table)
TYPE name IS TABLE OF REF[kernelclass] <-->  CONSTANT.REFSTRING_TABLE (RTL.REFSTRING_TABLE)
TYPE name IS TABLE OF STRING{(size)}   <-->  CONSTANT.STRING_TABLE    (RTL.STRING_TABLE, CONSTANT.MEMO_TABLE in SQL-bind)
TYPE name IS TABLE OF MEMO             <-->  CONSTANT.STRING_TABLE    (RTL.STRING_TABLE, CONSTANT.MEMO_TABLE in SQL-bind)
TYPE name IS TABLE OF REFSTRING        <-->  CONSTANT.REFSTRING_TABLE (RTL.REFSTRING_TABLE)
TYPE name IS TABLE OF BOOLSTRING       <-->  CONSTANT.BOOLSTRING_TABLE(RTL.BOOLSTRING_TABLE)
TYPE name IS TABLE OF BOOLEAN          <-->  CONSTANT.BOOLEAN_TABLE   (RTL.BOOLEAN_TABLE)
TYPE name IS TABLE OF DATE             <-->  CONSTANT.DATE_TABLE      (RTL.DATE_TABLE,dbms_sql.date_table)
TYPE name IS TABLE OF NUMBER{(sz{,pr})}<-->  CONSTANT.NUMBER_TABLE    (RTL.NUMBER_TABLE,dbms_sql.number_table)
TYPE name IS TABLE OF INTEGER          <-->  CONSTANT.INTEGER_TABLE   (RTL.INTEGER_TABLE)
TYPE name IS TABLE OF RAW{(size)}      <-->  CONSTANT.RAW_TABLE       (RTL.RAW_TABLE)
TYPE name IS TABLE OF BLOB             <-->  CONSTANT.BLOB_TABLE      (dbms_sql.blob_table)
TYPE name IS TABLE OF CLOB             <-->  CONSTANT.CLOB_TABLE      (dbms_sql.clob_table)
TYPE name IS TABLE OF BFILE            <-->  CONSTANT.BFILE_TABLE     (dbms_sql.bfile_table)
TYPE name IS TABLE OF LONG             <-->  CONSTANT.STRING_TABLE    (RTL.STRING_TABLE)
TYPE name IS TABLE OF LONG RAW         <-->  CONSTANT.RAW_TABLE       (RTL.RAW_TABLE)
TYPE name IS TABLE OF TIMESTAMP{(size)}<-->  CONSTANT.TIMESTAMP_TABLE    (dbms_sql.timestamp_table)
TYPE name IS TABLE OF TIMESTAMP(size,1)<-->  CONSTANT.TIMESTAMP_TZ_TABLE (dbms_sql.timestamp_with_time_zone_table)
TYPE name IS TABLE OF TIMESTAMP(size,2)<-->  CONSTANT.TIMESTAMP_LTZ_TABLE(dbms_sql.timestamp_with_ltz_table)
TYPE name IS TABLE OF INTERVAL{(sz,pr)}<-->  CONSTANT.INTERVAL_TABLE     (dbms_sql.interval_day_to_second_table)
TYPE name IS TABLE OF INTERVAL(size)   <-->  CONSTANT.INTERVAL_YM_TABLE  (dbms_sql.interval_year_to_month_table)

3.6. При определении типов полей структуры rowtable действуют
те же правила, что и для index by таблиц, кроме:
TYPE name IS TABLE OF STRING{(size)}   <-->  CONSTANT.MEMO_TABLE
TYPE name IS TABLE OF MEMO             <-->  CONSTANT.MEMO_TABLE
TYPE name IS TABLE OF BOOLEAN          <-->  CONSTANT.BOOLSTRING_TABLE

3.7. Поддержка DATETIME типов Oracle9i (TIMESTAMP,INTERVAL).
На уровне трансляции PL/Plus - PL/SQL действуют следующие соответствия:
	timestamp	-	timestamp(9)
	timestamp(n)	-	timestamp(n)
	timestamp(n,1)	-	timestamp(n) with time zone
	timestamp(n,2)	-	timestamp(n) with local time zone
	[timestamp_tz]	-	timestamp(9) with time zone
	[timestamp_ltz]	-	timestamp(9) with local time zone
	interval	-	interval day(9) to second(9)
	interval(n,m)	-	interval day(n) to second(m)
	interval(n)	-	interval year(n) to month
	[interval_ym]	-	interval year(9) to month	
	timestamp_unconstrained		- timestamp(9)
	timestamp_tz_unconstrained	- timestamp(9) with time zone
	timestamp_ltz_unconstrained	- timestamp(9) with local time zone
	dsinterval_unconstrained	- interval day(9) to second(9)
	yminterval_unconstrained	- interval year(9) to month
Стандартные функции для работы c DATETIME типами:
	EXTRACT - извлечение отдельных полей из timestamp или interval
	CURRENT_DATE - текущая дата
	CURRENT_TIMESTAMP - текущая дата и время
	DBTIMEZONE - серверный часовой пояс
	FROM_TZ - установка часового пояса в timestamp
	NUMTODSINTERVAL - преобразование числа к interval day to second
	NUMTOYMINTERVAL - преобразование числа к interval year to month
	SESSIONTIMEZONE	- часовой пояс сессии пользователя
	SYSTIMESTAMP - системная дата и время
	TO_TIMESTAMP - преобразование строки к timestamp
	TO_TIMESTAMP_TZ - преобразование строки к timestamp with time zone
	TO_DSINTERVAL - преобразование строки к interval day to second
	TO_YMINTERVAL - преобразование строки к interval year to month
	TZ_OFFSET - часовой пояс региона
	TO_TZ - установка часового пояса в выражении timestamp
	TO_INTERVAL - изменение типа интервала выражения для интервала
	constant.TIMESTAMP_FORMAT - стандартный формат преобразования
		timestamp к строке (для функции TO_CHAR)

Описание этих функций можно найти в документации Oracle, кроме функций
TO_TZ, TO_INTERVAL, которые являются псевдо-функциями и реализуют
специальный синтаксис Oracle для приведения типов:

TO_TZ - приведение timestamp выражения к заданой временной зоне:
  синтаксис:
     TO_TZ(<timezone>,<timestamp_expr>)
  который преобразуется так:
     <timestamp_expr> at time zone <timezone>
  где
     timestamp_expr - выражение типа timestamp (это может быть как выражение,
         так и функция, реквизит и т.д.);
     timezone - строковая константа, указывающая временную зону, например:
         '+06:00' - сдвиг +6 часа от нулевого часового пояса (гринвича),
         'Asia/Novosibirsk' - имя временной зоны (из V$TIMEZONE_NAMES),
         'DBTIMEZONE' - временная зона сервера БД,
         'SESSIONTIMEZONE'  - временная зона сессии пользователя;
       либо логическая константа:
         false - временная зона сервера БД,
         true  - временная зона сессии пользователя.

TO_INTERVAL - приведение interval выражения к заданному типу интервала:
  синтаксис:
     TO_INTERVAL(<interval_type>,<interval_expr>)
  который преобразуется так (в зависимости от параметра interval_type:
     (<interval expr>) day to second
     или
     (<interval expr>) year to month
  где
     interval_expr - выражение для получения полного интервала, т.е. которое
       содержит все - годы, месяцы, дни и секунды (таким выражением, например,
       является разница двух timestamp-ов, готовые interval типы не годятся,
       т.к. они уже нормализованы на определенный интервал);
     interval_type - строковая константа, определяющая тип выражения:
         'DAY TO SECOND' - приведение к интервалу дни-секунды (причем может
                           быть указана точность для DAY/SECOND),
         'YEAR TO MONTH' - приведение к интервалу годы-месяцы (причем может
                           быть указана точность для YEAR),
       либо логическая константа:
         false - приведение к интервалу годы-месяцы,
         true  - приведение к интервалу дни-секунды.

3.8. Описание переменной-массива ATTR_LIST, используемой в прикладных триггерах,
для обмена информацией об измененяемых значениях реквизитов. Она описывается
через предопределенные типы пакета valmgr (а именно, valmgr.qual_table):
    type qual_info is record(
        qual string(700),    -- квалификатор реквизита
        base string(16),     -- базовый тип реквизита
        class string(16),    -- собственно тип реквизита
        refclass string(16), -- ссылаемый (целевой) тип реквизита (для ссылочных типов)
        oldv string(4000),   -- строковое представление старого значения реквизита
        newv string(4000)    -- строковое представление нового значения реквизита
	);
    type qual_table is table of qual_info;

3.9. Для описания параметров и переменных операций используется
комбинация в виде указания ТБП и флага параметра, который
может задавать производные заданного ТБП. Результирующий
тип параметра получается исходя из следующих правил (имя
CLASS - задаваемый тип параметра-переменной) в зависимости от
значения флага (см.п.3.2):
  A - [CLASS]%rowtype;              -- Rowtype тип
  B - [CLASS]%rowtable;             -- Rowtable тип
  C - varray(0) of [CLASS]%rowtype; -- Вложенный массив Rowtype типа
  D - [CLASS];                      -- Собственно тип
  R - ref [CLASS];                  -- Ссылка на тип
  T - table of [CLASS];             -- Индексированный массив типа
Для флагов С и Т (массивов) в операции дополнительно объявляются
соответствующие декларации типов (через которые и определяются
параметры-массивы):
  type CLASS_TBLROW is varray(0) of [CLASS]%rowtype; -- флаг C
  type CLASS_TABLE  is table of [CLASS];             -- флаг Т
Эти типы публичные и могут использоваться в других операциях.
Флаги A,B,C появились начиная с версии ТЯ 6.4.

3.10. Разъяснение по поводу формирования системных колонок
(равно как и системных полей в соответствующих rowtype-структурах -
см.п.3.2.1.1):
  ID, number/varchar2(128), добавляется всегда при наличии экземпляров
      в типе или в дочерних типах (при наличии таблицы), фактический тип
      колонки таблицы (или поля структуры) определяется свойствами ТБП -
      метаклассы и ТБП, в которых определен ключевой реквизит, имеют
      строковый ID, у остальных - числовой (в ТЯ 7.1 и выше этому же
      правилу подчиняется и тип возвращаемого значения модификатором %ID);
  CLASS_ID, varchar2(16), добавляется в следующих случаях:
    - при наличии дочерних типов,
    - при наличии собственных состояний в типе,
    - если непосредственный родительский тип секционирован;
  STATE_ID, varchar2(16), добавляется в следующих случаях:
    - при наличии собственных состояний в типе,
    - при наличии STATE_ID в дочерних типах, если
      тип является вершиной иерархического дерева типов (т.е.
      сам тип не имеет родителя);
  COLLECTION_ID, number, добавляется в следующих случаях:
    - при наличии в любом типе колонок - массивов, элементами которых
      является данный тип (т.е. существуют физические массивы данного типа),
    - при наличии типа - массива, объявленного как "временный массив",
      элементами которого является данный тип,
    - при наличии COLLECTION_ID в дочерних типах, если
      тип является вершиной иерархического дерева типов (т.е.
      сам тип не имеет родителя).

3.11. Разъяснения по поводу присвоения массивов.
  а) До версии 6.3 проверка корректности таких присвоений была
     возложена на парсер Oracle. В PL+ никаких действий по этому
     поводу не предпринималось.
  b) В версии 6.3 и выше реализовано копирование элементов из
     одного массива в другой в случае, когда массивы совместимы
     по типу элементов, но несовместимы по типу самого массива.
     При этом копирование реализовано один к одному, т.е. копирование
     как самих значений, так и индексов.
  с) Формально автоматический код копирования элементов корректен
     только для переноса данных между index by массивами с целочисленными
     индексами.
  d) Для других типов переноса элементов массивов могут быть следующие
     ошибки на этапе выполнения:
     - ошибка преобразования символа в число при переносе данных index by
       массивов со строковыми индексами (строковый индекс не всегда может
       быть преобразован к целочисленному).
     - ошибки проверки границ массивов при переносе данных в NESTED TABLE
       или VARRAY массивы из других NESTED TABLE или VARRAY массивов,
       при переносе из index by массивов с нулевым или отрицательными
       индексами.
  e) При генерации кода для копирования элементов массивов парсером PL/Plus
     выдается предупреждение, которое призвано обратить внимание разработчика
     на написанный им код (по аналогии с некорректным присвоением ссылок,
     которое также чревато runtime ошибками).
  f) Это предупреждение как раз и означает, что могут быть проблемы с
     выполнением указанного кода. Поэтому разработчику следует либо предпринять
     какие-то дополнительные действия (например, инициализировать границы для
     NESTED TABLE или VARRAY массива-приемника), чтобы такое присвоение могло
     быть успешным, либо избавиться от такого присвоения и написать свой цикл
     присвоения элементов массивов. При этом разработчик обладает всей
     необходимой информацией, какие данные и какие индексы могут быть
     в заданных массивах, и насколько нужно или не нужно раздвигать их границы
     (на этапе компиляции такой информации нет).

3.12. Не рекомендуется использовать напрямую в PL/Plus типы системных PL/SQL
пакетов и SQL типы Oracle напрямую. Рекомендуется использовать PL/Plus описания,
которые в необходимых случаях будут отображены в нужные PL/SQL и SQL типы
(см. пп.3.4 - 3.6). Придерживаться этого правила необходимо исходя из
соображений совместимости с разными версиями как ТЯ, так и Oracle, т.к.
схема отображения типов может изменяться. Причем отображение типов может
изменяться исходя из описаний самих типов, это касается в первую очередь
ссылок. В версиях ТЯ ниже 6.5 отдельные типы выделялись для ссылок на системные
типы, в ТЯ 6.5 и выше к таким типам также приравниваются типы, в которых
определены ключевые реквизиты:
TYPE name IS VARRAY(0) OF REF[class]       <-->  TYPE_NUMBER_TABLE
TYPE name IS VARRAY(0) OF REF[kernelclass] <-->  TYPE_REFSTRING_TABLE
TYPE name IS TABLE OF REF[class]       <-->  CONSTANT.NUMBER_TABLE    (RTL.REFERENCE_TABLE)
TYPE name IS TABLE OF REF[kernelclass] <-->  CONSTANT.REFSTRING_TABLE (RTL.REFSTRING_TABLE)
Также в версии ТЯ 6.5 обобщенный тип отображен на тип RTL.OBJECT_REC:
[OBJECT]  <--> RTL.OBJECT_REC
TYPE name IS TABLE OF OBJECT <-->  RTL.OBJECT_TABLE;

3.13. Реализованы стандартные числовые типы (IEEE-754) под Oracle10g:
BINARY_FLOAT  - 4-байтовое число с плавающей точкой,
                диапазон +-3.4Е38, 7 значащих цифр;
BINARY_DOUBLE - 8-байтовое число с плавающей точкой,
                диапазон +-1.7Е308, 15 значащих цифр.
Помимо указанного допустимого числового диапазона существуют также
  следующие значения:
+-Inf - бесконечность (возникает, например, при попытке присовить значение вне
        допустимого числового диапазона, в частности, при делении ненулевого числа
        на ноль). Любое арифметическое действие с Inf в результате даст Inf.
        Значение Inf может использоваться при сравнении (=,<>,>,<) или проверяться
        оператором is {not} infinite. Доступны следующие типизованные системные
        константы для бесконечности - binary_float_infinity и binary_double_infinity.
Nan - нечисло (возникает, например, при умножении Inf на 0 или при делении
      Inf на Inf). Любое арифметическое действие с Nan в результате даст Nan.
      Значение Nan может использоваться на равенство (=,<>) или проверяться
      оператором is {not} nan. Доступны следующие типизованные системные константы
      для нечисла - binary_float_nan и binary_double_nan.
Эти типы рекомендуется использовать для сложных числовых вычислений, т.к. они
обрабатываются в native командах сервера, что существенно быстрее обработки
ораклового типа NUMBER, который обрабатывается процедурно.

Стандартные функции для работы c BINARY типами:
TO_BINARY_FLOAT  - преобразование к типу TO_BINARY_FLOAT.
TO_BINARY_DOUBLE - преобразование к типу BINARY_DOUBLE.
NANVL  - преобразование НЕЧИСЛА (NAN), по аналогии с NVL.

BINARY типы при взаимодействии с нечисловыми типами ведут себя как числа,
а при взаимодействии с числами используется следующий приоритет
умолчательных преобразований (в порядке убывания):
  BINARY_DOUBLE
  BINARY_FLOAT
  NUMBER
  PLS_INTEGER
Таким образом, если в числовом выражении используются разные числовые
типы, то при вычислении такого выражения все типы приводятся к числу
с наивысшим приоритетом и результатом будет также число с наивысшим
приоритетом.

3.14. В версии ТЯ 7.0 добавлены гранты на системные вложенные массивы
скалярных типов (TYPE_BOOLSTRING_TABLE, TYPE_REFSTRING_TABLE,
TYPE_DEFSTRING_TABLE, TYPE_MEMO_TABLE, TYPE_DATE_TABLE, TYPE_NUMBER_TABLE,
TYPE_RAW_TABLE) всем системным ролям - ролям Пользователя, Администратора
модели, Администратора доступа.

3.15. В версии ТЯ 7.2 и выше реализовано автоматическое переопределение
типов для index by string таблиц:
TYPE name IS TABLE OF REF[class]       index by string <-->  CONSTANT.NUMBER_TABLE_S
TYPE name IS TABLE OF [class_ARR]      index by string <-->  CONSTANT.NUMBER_TABLE_S
TYPE name IS TABLE OF REF[kernelclass] index by string <-->  CONSTANT.REFSTRING_TABLE_S
TYPE name IS TABLE OF STRING{(size)}   index by string <-->  CONSTANT.STRING_TABLE_S
TYPE name IS TABLE OF MEMO             index by string <-->  CONSTANT.STRING_TABLE_S
TYPE name IS TABLE OF REFSTRING        index by string <-->  CONSTANT.REFSTRING_TABLE_S
TYPE name IS TABLE OF BOOLSTRING       index by string <-->  CONSTANT.BOOLSTRING_TABLE_S
TYPE name IS TABLE OF BOOLEAN          index by string <-->  CONSTANT.BOOLEAN_TABLE_S
TYPE name IS TABLE OF DATE             index by string <-->  CONSTANT.DATE_TABLE_S
TYPE name IS TABLE OF NUMBER{(sz{,pr})}index by string <-->  CONSTANT.NUMBER_TABLE_S
TYPE name IS TABLE OF INTEGER          index by string <-->  CONSTANT.INTEGER_TABLE_S
TYPE name IS TABLE OF INTEGER     index by string(512) <-->  CONSTANT.INDEX_TABLE_S


        4. Инициализация - контексты и настройки.

4.1. В системе определены следующие контексты с именами, основанными на
имени владельца схемы (IBSO owner):
<IBSO owner>_SYSTEM - системный контекст, заполняется пакетом RTL при
    инициализации сессий пользователей, пользователям доступен только
    на чтение;
<IBSO owner>_SETTS - глобальный системный контекст, заполняется пакетом
    RTL по мере считывания системных настроек (settings) пользовательскими
    сессиями. Назначение контекста - оптимизация получения значений общих
    настроек системы, доступен в версии ТЯ 7.2 и выше, в связи с чем
    вся логика работы с настройками системы перенесна из пакета stdio в rtl;
<IBSO owner>_USERS - глобальный системный контекст, заполняется пакетом
    RTL при аутотентификации пользовательских сессий. Доступен в версии
    ТЯ 7.3 и выше (см.п.4.18);
<IBSO owner>_KEYS - системный контекст, заполняется пакетом VALMGR при
    инициализации сессий пользователей значениями ключей секционирования
    архивированных типов, пользователям доступен только на чтение
    (создается и заполняется в новых версиях ТЯ - 7.0 и выше, для Oracle9i
    и выше контекст является глобальным);
<IBSO owner>_OPTIONS - глобальный системный контекст прав использования
    опций прикладных подсистем (заполняется пакетом opt_mgr в соответствии
    с установленными лицензионными настройками начиная с версии ТЯ 6.6);
<IBSO owner>_USER   - локальный пользовательский контекст, заполняется
    пакетом EXECUTOR, процедура set_context;
<IBSO owner>_GLOBAL - глобальный пользовательский контекст, заполняется
    пакетом VALMGR, процедура set_context.
  Контексты прав доступа:
<IBSO owner>_RIGHTS  - права доступа на типы и представления;
<IBSO owner>_ORIGHTS - права доступа к экземплярам;
<IBSO owner>_ERIGHTS - права доступа к экземплярам через реквизит.
Контексты прав ORIGHTS/ERIGHTS являются локальными и управляются
пакетом EXECUTOR (при необходимости заполнение их происходит во
время инициализации пользовательских сессий), контекст RIGHTS до
версии 7.2 также являлся локальным и управлялся пакетом EXECUTOR,
а начиная с версии 7.2 и выше, он стал глобальным и управляется
пакетом SECADMIN.
  Операции и представления могут использовать все указанные контексты
на чтение, однако использовать контексты прав не рекомендуется, т.к.
процедура их инициализации зависит от настроек системы (RIGHTS_CONTEXT,
OBJECT_RIGHTS_CONTEXT, OBJECT_RIGHTS_EX_CONTEXT, см.п.4.2). Значения
фтрибутов пользовательских контекстов операции могут как читать, так и
записывать через соответствующие процедуры.
  Читать значения атрибутов контекстов можно системной функцией SYS_CONTEXT,
которой параметрами передаются имя контекста и имя атрибута контекста,
возвращает функция значение заданного атрибута (если атрибут контекста
не задан, то sys_context возвращает null).
  Предоставляется возможность заполнения пользовательских контекстов
<IBSO owner>_USER, <IBSO owner>_GLOBAL через процедуру set_context
пакетов EXECUTOR и VALMGR, соответственно (которые доступны в режиме
расширенного синтаксиса):
executor.set_context( p_name varchar2, p_value varchar2);
  valmgr.set_context( p_name varchar2, p_value varchar2,
                      p_username  varchar2 default null,
                      p_client_id varchar2 default null);
где p_name - имя атрибута, а p_value - его значение,
  p_username - имя пользователя, для которого устанавливается заданное
  значение контекста (пустое значение означает установку для всех
  пользователей), p_client_id - дополнительный атрибут глобального
  контекста, присваиваемый задаваемому значению (по умолчанию перед
  запуском операций в Навигаторе клиентский идентификатор сбрасывается
  для текущей сессии в пустое значение, поэтому если предполагается
  устанавливать какое-то непустое значение идентификатора, то операция,
  использующая задаваемое значение с непустым client_id, должна позаботиться
  об установке этого значения в своей сессии процедурой
  dbms_session.set_identifier). Параметры p_username/p_client_id могут
  устанавливаться только для глобального пользовательского контекста,
  локальный пользовательский контекст доступен только в собственной
  сессии и вне ее никому не виден.
Для очистки пользовательских контекстов могут использоваться процедуры:
executor.clear_user_context;
- очистка локального пользовательского контекста <IBSO owner>_USER;
  valmgr.clear_context(p_client_id varchar2 default null,
                       p_name      varchar2 default null);
- очистка глобального пользовательского контекста <IBSO owner>_GLOBAL.
  Таким образом, можно инициализировать пользовательский контекст
некоторыми значениями, отражающими прикладную логику, а затем через
функцию SYS_CONTEXT эти значения можно использовать в SQL-запросах
операций и представлениях.
  В версиях ТЯ 7.0 и выше на платформе Oracle9i и выше пользовательский
контекст <IBSO owner>_GLOBAL реализован именно как глобальный
контекст, т.е. значения, установленные одной пользовательской
сессией, доступны и другим на одном и том же узле кластера в среде
Real Application Cluster (без RAC, соответственно, на всем
экземпляре). В этом случае процедурой valmgr.set_context можно
установить также дополнительные атрибуты глобального контекста -
имя пользователя и клиентский идентификатор - путем указания
дополнительных параметров (в том же порядке: пользователь,
индентификатор).

4.2. Технологическим ядром IBSO происходит инициализация следующих значений
контекстов:
<IBSO owner>_SYSTEM - системный контекст - со следующими атрибутами:
  OWNER     - имя схемы-владельца (см.п.4.12),
  GOWNER    - имя глобального владельца IBSO (см.п.4.12),
  AUDITOR   - имя схемы-ревизора,
  VERSION   - версия ТЯ IBSO,
  STATUS    - статус сессии пользователя (0 - не зарегистрирована,
              1 - зарегистрирована, 2 - заблокирована)
  LOCK_SERVERS - текущее к-во менеджеров блокировок
  LOCK_INFO - номер (от 0) менеджера блокировок в текущей сессии пользователя
  RTL0      - номер узла (от 0) OPS/RAC сессии пользователя
  ID и USERID - идентификатор сессии пользователя,
  USR и USER- имя пользователя IBSO (субъекта доступа) клиентской сессии,
  PROFILE   - профиль пользователя системы доступа,
  OSUSER    - сетевое имя пользователя (в локальной сети),
  USERNAME  - имя компьютера, с которого произошло соединение с базой,
  MODULE    - имя модуля, с помощью которого произошло соединение с базой,
  SESID     - дополнительный идентификатор сессии пользователя (utils.session_id)
  ADMIN     - признак привилегированного пользователя (администратор - 1,
              остальные - 0)
  ALLOBJECTS - признак доступа ко всем экземплярам (используется в
              представлениях, где задается проверка доступа к типу
              или к экземплярам)
  USER_CONTEXT - признак полной инициализации сессии пользователя:
                 1 - сессия зарегистрирована и полностью инициализирована;
                 0 - сессия не зарегистрирована или инициализирована не
                     полностью (инициализирован только системный контекст)
  INIT_SESSION - признак прав инициализации пользовательских сессий:
                 0 - нет прав на инициализацию сессий;
                 1 - есть права инициализации сессий (агент сервера приложений - СП,
                     например, APP_SRV);
                 2 - сессия инициализирована в 3L-режиме (т.е. пользовательская
                     сессия инициализирована агентом СП)
  OPEN_SESSION - признак прав создания-удаления пользовательских сессий:
                 0 - нет прав на создание-удаление сессий;
                 1 - есть права на создание-удаление сессий
  UID - уникальный идентификатор пользователя как субъекта доступа системы
        (заполняется для версий ТЯ 7.2 и выше).
  В этот же контекст (для версий ТЯ ниже 7.0) заносятся текущие значения
  ключей секционирования архивных таблиц c именами атрибутов в формате '<ID типа>.KEY'
  и общий признак инициализации ключей архивации (атрибут PARTITION_KEYS).
  В версии 7.0 и выше эти значения заносятся в другой системный контекст
  (<IBSO owner>_KEYS), который на платформе Oracle9i и выше является глобальным.
<IBSO owner>_USER - пользовательский контекст, при инициализации сессии
  заполняется следующими атрибутами:
  SYS_DATE - дата опердня (из системных настроек - таблицы SETTINGS),
  SYS_NAME - наименование банка - владельца схемы (из таблицы SETTINGS),
  STDLIB.USERID - значение ссылки на текущего пользователя в прикладной
    подсистеме (инициализируется значением функции STDLIB.USERID).
Контексты прав (заполняются в зависимости от системных настроек
RIGHTS_CONTEXT, OBJECT_RIGHTS_CONTEXT, OBJECT_RIGHTS_EX_CONTEXT):
Если системная настройка RIGHTS_CONTEXT установлена в значение 1,
то происходит заполнение <IBSO owner>_RIGHTS контекста правами
доступа на типы и представления для текущего пользователя (в локальном
контексте) или для всех субъектов доступа (в глоюальном контексте
версий 7.2 и выше).
  Если системная настройка RIGHTS_CONTEXT установлена в значение 1,
а также установлена настройка OBJECT_RIGHTS_CONTEXT в значение 1,
то происходит заполнение <IBSO owner>_ORIGHTS контекста правами
доступа к экземплярам для текущего пользователя.
  Если системная настройка RIGHTS_CONTEXT установлена в значение 1,
а также установлена настройка OBJECT_RIGHTS_EX_CONTEXT в значение 1,
то происходит заполнение <IBSO owner>_ERIGHTS контекста правами
доступа к экземплярам через реквизит для текущего пользователя.
  Контексты прав доступа используются при проверке прав в условиях
доступа в представлениях. Поэтому при изменении значений этих настроек
необходимо пересоздать все пользовательские представления, чтобы
проверка доступа и заполнение контекста были синхронизованы.
  Для версий ТЯ ниже 7.2 при использовании для соединения пользователей
трехуровневой архитектуры рекомендуется отключать заполнение контекстов
прав доступа (для этого достаточно сбросить в 0 значение настройки
RIGHTS_CONTEXT), т.к. все пользовательские запросы в такой архитектуре
требуют переинициализации контекстов на каждый свой вызов, в отличие
от двухуровневой архитектуры, когда инициализация делается только один
раз при соединении пользователя. Для версии 7.2 (и выше) и трехуровневой
архитектуры отключать заполнение глобального контекста доступа настройкой
RIGHTS_CONTEXT нет необходимости, рекомендуется отключить только
локальные контексты настройками OBJECT_RIGHTS_CONTEXT и OBJECT_RIGHTS_EX_CONTEXT
(установить значение 0).

4.3. Добавлена обработка глобальной настройки PLP_ACTUAL_PARTITION_ONLY,
которая регулирует умолчательный режим (при установленном значении флага
"Условие архивации" в свойствах операции) генерации интерфейсных пакетов
типов, пакетов операций, представлений. При значении настройки YES, пакеты
и представления создаются таким образом, чтобы использовать только
актуальные секции всех таблиц ТБП, имеющих архивные секции. При значении
настройки NO, наоборот, код пакетов и представлений генерится так, что
используется обращение ко всему набору архивов с дополнительным условием
на выбор архивных секций через ключ архивации, который может динамически
изменяться, тем самым определяя набор подключенных архивных секций.
При изменении значения этой настройки потребуется перекомпиляция всех
интерфейсных пакетов типов, операций и представлений, в которых используется
обращение к архивным ТБП (чтобы синхронизовать код пакетов и вьюх в соответствии
с новым значением). Пользовательские операции и представления используют
настройку PLP_ACTUAL_PARTITION_ONLY только в том случае, если в них
не задан явно режим использования архивов (например, с помощью pragma archive).
Если режим использования архивов задан явно, то используется именно
заданный режим, общая настройка PLP_ACTUAL_PARTITION_ONLY при этом
не учитывается. Для системных пакетов (интерфейсов типов) и вьюх (objects,
col2obj, collections и др.) используется только общая настройка,
на уровне отдельных объектов она не переопределяется.
В версии ТЯ 7.0 и выше настройка PLP_ACTUAL_PARTITION_ONLY упразднена,
режимы работы операций и представлений определяется только самими
операциями и представлениями (см.пп.1.29,4.10,5.16).

4.4. Добавлены настройки в профили пользователей, позволяющие выполнять
прикладные функции во время инициализации контекста (настройка 'USER_CONTEXT')
и во время регистрации пользовательской сессии (настройка 'USER_LOCK_OPEN'),
содержащие имя PL/SQL функции, которую следует вызывать во время указанных
событий. Т.о. в разных профилях можно использовать разные функции инициализации.
Различие параметров USER_CONTEXT и USER_LOCK_OPEN в том, что первая функция
выполняется при инициализации сессии (при первом обращении к пакету EXECUTOR),
т.е. до выполнения функции регистрации LOCK_OPEN (соответственно, в ней нельзя
полностью использовать весь функционал IBSO, можно только тот, который не
требует регистрации сессии), а вторая после регистрации сессии (вообще говоря -
на каждый вызов LOCK_OPEN). Если настроек в собственном профиле
пользователя нет, тогда они берутся из умолчательного профиля DEFAULT.
При инициализации пользовательского контекста (<IBSO owner>_USER) возвращенные
значения функций пользовательской инициализации будут присвоены
атрибутам 'USER_CONTEXT' и 'USER_LOCK_OPEN' (в соответствии с именами
настроек), так что по значению этих атрибутов можно судить об успешности
выполнения этих функций (если функции завершатся по ошибке, тогда в значения
этих атрибутов заносится текст возникшей ошибки). Указанные функции должны
быть без параметров и в своем теле могут использовать вызовы EXECUTOR.SET_CONTEXT
(VALMGR.SET_CONTEXT) для установки дополнительных атрибутов пользовательского
контекста.

4.5. Реализован механизм инициализации в типах. В свойствах типа можно
указать процедуру инициализации (это должна быть групповая операция без
параметров), которая будет выполняться Навигатором при загрузке представления
этого типа или при вызове с клиента любой операции в этом типе. Операция
инициализации будет выполняться в сессии пользователя только один раз для
указанного типа. Выполнить эту процедуру еще раз можно только после сброса
состояния инициализации типа по событию с кодом 4.

4.6. При работе штатными средствами (АРМами IBSO) инициализация контекстов
и выполнение процедур регистрации выполняется явно путем вызова соответствующих
процедур технологического ядра. Для инициализации сессий пользователей
при соединении других средств работы с БД (например, отчетов или утилит
БД) инициализация сессий может быть обеспечена через механизм вызова
процедур инициализации в триггере на соединение, который срабатывает
в момент открытия пользовательской сессии независимо от средства работы
с БД, установившей соединение. Для этого у зарегистрированного в системе
доступа IBSO должен быть установлен признак "Автоматическое заполнение
контекстов", а также должен быть создан триггер на соединение в схеме
менеджера аудита AUDM.
Контексты Oracle могут нормально использоваться для версии Oracle
8.1.6.1 и выше при установленном параметре compatible=8.1.0 и выше.

4.7. В версии ТЯ 6.5 реализован механизм кэширования метаданных словаря IBSO.
Кэшируются значения таблиц classes, class_tables, class_attributes. Реализовано
в пакете LIB, соответственно, все его функции работы со словарем используют
этот кэш. PL+ парсер также работает через пакет LIB. Для обновления значения
кэша метаданных задействовано событие 14.

4.8. В версии ТЯ 7.0 реализовано сохранение информации о версии сервера БД
в пакете INST_INFO (константы DB_VERSION и DB_RELEASE).

4.9. В системе определены следующие системные роли с именами, основанными на
имени владельца схемы (IBSO owner):
<IBSO owner>_USER - роль Пользователя, позволяет работать в АРМе "Навигатор",
     позволяет просматривать данные и выполнять операции, доступные пользователю;
<IBSO owner>_ADMIN - роль Администратора модели, позволяет работать в АРМе
     "Администратор словаря данных", позволяет разрабатывать и модифицировать
     элементы прикладной модели данных;
<IBSO owner>_UADMIN - роль Администратора доступа, позволяет работать в АРМе
     "Администратор доступа", позволяет изменять структуру прав доступа
     к информационным ресурсам пользователей с ролью Пользователя;
<IBSO owner>_PICKER - роль Администратора проектов, позволяет работать в АРМе
     "Администратор проектов", позволяет перенос описаний прикладной модели
     между разными схемами IBSO;
<IBSO owner>_UPICKER - роль Администратора проектов, позволяет работать в АРМе
     "Администратор проектов", позволяет перенос прав доступа;
<IBSO owner>_REVISOR - роль Ревизора, позволяет работать в АРМах "Ревизор",
     "Навигатор", "Администратор доступа" в режиме просмотра (без возможности
     модификации данных).

4.10. В версии ТЯ 7.0 системная настройка PLP_ACTUAL_PARTITION_ONLY,
управлявшая ранее умолчательным режимом использования архивов (см.п.4.3)
упразднена. Управление умолчательным режимом осуществляется через значение
атрибута ACTUAL_PARTITIONS системного контекста <IBSO owner>_KEYS:
  '1',пусто - использование только актуальных данных (значение
              по умолчанию);
  '0' - использование архивных секций в соответствии со значениями
        текущих ключей архивации.
  По умолчанию включен режим использования только актуальных
секций таблиц, однако он может быть динамически изменен процедурой
valmgr.switch_archiving (которая изменяет значение атрибута ACTUAL_PARTITIONS).
  Умолчательный режим, задаваемый атрибутом ACTUAL_PARTITIONS
глобального контекста <IBSO owner>_KEYS (см.п.4.1), управляет работой
следующих системных процедур поддержки хранения данных:
  - attr_mgr.del_class_attr (при удалении реквизитов-коллекций);
  - storage_utils.lost_collections (зачистка потерянных коллекций);
  - storage_utils.conv_ref_table (преобразование ссылочных колонок);
  - method_mgr.delete_collection (удаление коллекций);
  - method_mgr.clear_object_refcing (зачистка кривых ссылок);
  - method_mgr.move_object (изменение ID экземпляра);
  - valmgr.first_referencing_on (поиск обратных ссылок).
  - storage_utils.create_refcing_triggers (создание триггеров по ссылкам);
  - storage_utils.create_refced_triggers (создание триггеров по обратным
    ссылкам);
  - storage_utils.create_triggers (обе процедуры в одной).
  Триггеры поддержки целостности и дублирования данных (последние три
процедуры) работают в том режиме, который был включен на момент их создания.
  Режим использования архивных данных в операциях и представлениях
регулируется свойствами самих операций (опция компиляции pragma archive) -
и представлений (новое свойство Archive).
  Системные представления поиска владельцев коллекций для каждого
типа создаются в двух вариантах - VW_C2O_<Class> (поиск по актуальным
данным) и VW_C2P_<Class> (поиск по архивным данным с учетом текущих
значений ключей архивации).

4.11. В ТЯ 7.1 реализован новый механизм инициализации сессий для
отчетов (alter session set current_schema...), который
позволяет отказаться от создания синонимов для отчетов.
Новый режим инициализации сессий пользователей управляется
в разрезе профилей пользователей настройкой 'CREATE_SYNONYMS'.
Возможные значения настройки:
  YES - синонимы создаются по существующим зависимостям отчетов,
  NO, отсутствие настройки - синонимы не создаются, при инициализации
      сессий выполняется alter session set current_schema=<Owner>
Настройка подчиняется принципу наследования, т.е. если в собственном
профиле пользователя настройка отсутствует, то она берется из
профиля DEFAULT.

4.12. В ТЯ 7.1 реализована возможность разделения схем хранения данных
прикладных таблиц и метаданных словаря IBSO. Реализованы
новые режимы перестроения таблиц с переносом данных из
одной схемы хранения в другую. Реализованы следующие
схемы хранения (по именам констант пакета INST_INFO):
GOWNER - глобальный пользователь, который определяет
         общую идентификацию схем IBSO для конечных
         пользователей, в схемах аудита, менеджера
         аудита и других;
OWNER  - схема хранения метаданных (таблиц словаря
         IBSO), хранимых процедур и триггеров как
         самого ТЯ, так и ФЯ (функционального ядра,
         генерируемых процедурами ТЯ);
DOWNER1- схема хранения прикладных данных (таблиц и
         индексов);
DOWNER2- дополнительная схема хранения прикладных данных
         (таблиц и индексов).
Константы OWNER и GOWNER сохраняются в системном контексте (см.п.4.2),
а также доступны в PL/Plus через псевдо-функции (см.п.1.19).

4.13. Убрана обработка системной настройки METHOD_INTERFACE при
генерации интерфейсных пакетов операций. Оставлен единый режим,
который определялся значением METHOD_INTERFACE=2.

4.14. Расширен размер колонки для значений настроек хранения
(таблица storage_parameters). Настройка хранения ANALYZE_OPTION
может хранить кастомизированные опции для сбора статистики (через
пакет dbms_stats).

4.15. Реализована возможность управления адресной рассылкой событий
обновления кэша (см.п.5.17). Настройка CLS_USE_CACHE_PIPES (в settings)
при значении 'YES' (значение по умолчанию, т.е. используется при
отсутствии настройки) включает использование адресной рассылки.
При включенной адресной рассылке системная настройка CLS_NO_CACHE_PIPES
задает список типов (через запятую), для которых адресная рассылка
не используется. В этот список рекомендуется включать кэшируемые типы,
которые используются в процедуре пользовательской инициализации сессий
(т.е. эти типы инициализируются для всех пользовательских сессий,
соответственно, им адресная рассылка не нужна), при этом тип SYSTEM
автоматически включен в этот список (его указывать не нужно).

4.16. Реализовано опциональное создание индексов в режиме
ONLINE (без блокировки таблицы, по которой строится индекс).
Режим управляется системной настройкой STORAGE_FORCE_ONLINE
(в settings).

4.17. Реализована системная настройка PLP_DEF_TARGET (в settings),
управляющая умолчательным режимом компиляции операций, возможные значения:
  0, отсутствие настройки - генерация PL/SQL-кода операций,
  1 - генерация одновременно PL/SQL-кода и JAVA-кода операций,
  2 - генерация JAVA-кода операций.

4.18. В версии ТЯ 7.3 принципиально изменен алгоритм аутотентификации
сессий пользователей. Эта функция вынесена из-под контроля сервиса lock_info
и возложена на саму регистрирующуюся сессию. Информация о регистрации
сессий вынесена из памяти выделенного процесса и теперь размещена в специально
созданном для этого глобальном контексте <IBSO owner>_USERS, управляемом
пакетом rtl. Эта же информация дублируется и в таблице
rtl_users, которая необходима как в плане совместимости с предыдущими
версиями, так и для опций RAC (Real Application Cluster) и ADG (Active
Data Guard - Physical ReadOnly Standby). Также реализован режим хранения
информации о зарегистрированных сессиях только в таблице RTL_USERS,
без использования глобального контекста. Этот режим рекомендуется использовать
в конфигурации RAC Oracle11g, т.к. в этом случае запись в контекст происходит
очень медленно из-за проблем синхронизации контекста на разных узлах RAC.
Режим управляется системной настройкой SES_CONTEXT_LIMITS, которая при
значении 0 отключает использование глобального контекста (подробности
см. lockinfo.txt чч. 8,12). По умолчанию (при отсутствии настройки)
использование глобального контекста в среде RAC отключено, в остальных
случаях - включено, в среде ADG включено всегда (независимо от настройки).


4.19. Системная настройка PLP_STANDALONE_EXTENSION (в settings) определяет
режим создания по умолчанию для расширений операций (версии ТЯ 7.2 и выше):
  - 'Y','1', пустое значение - для расширения создается собственный пакет;
  - другое значение - создается единый пакет по имени базовой операции (см.п.1.30).


        5. Разное.

5.1. Для поддержки механизма событий в пакет rtl добавлены процедуры посылки
событий (которые доступны в режиме расширенного синтаксиса):
procedure send_events(p_code integer, p_event string default null,
                      p_user string default null, p_uid integer default null);
- где p_code - код события,
    p_event - текст сообщения или информация для события (интерпретация 
      определяется кодом события),
    p_user - задает фильтр на поиск сессий, которым будет отсылаться событие,
      формат задаваемого значения:
    [<node>.]<username>[:<session list>], где
      <username> задает фильтр на имя пользователя oracle (пустое значение
        означает поиск всех пользователей);
      <node> задает номер узла RAC (без единицы), для которого требуется
        получить список сессий (пустое значение означает поиск на других
        узлах, т.е. на всех, кроме собственного; отсутствие указания номера
        RAC означает поиск на всех доступных узлах RAC, включая собственный);
      <session list> задает список исключений, состоящий из идентификаторов
        зарегистрированных пользовательских сессий, которые следует исключить
        из результирующего списка сессий для рассылки (если список исключений
        задан, т.е. разделитель ':' присутствует, и пуст,
        тогда в список исключений включается собственная сессия);
      пустое значение параметра означает отсутствие фильтра как на имя
      пользователя, так и на номер узла RAC (поиск по всем узлам);
    p_uid - ID зарегистрированной сессии пользователя (AUDSID), которой 
      посылается событие.
procedure send_event (p_uid integer, p_code integer, p_event string default null);
- более низкоуровневая процедура - посылает события только по ID сессии.
Реализованы следующие типы событий (коды):
0 - инициализация значений ID статических экземпляров и инициализация
    интерфейсного пакета ТБП (внутренних кэш-переменных пакета), ID
    которого указывается в p_event (если он не пуст);
1 - инициализация значений ключей архивации и системного контекста
    <IBSO owner>_KEYS, а также инициализация интерфейсного пакета ТБП
    (внутренних кэш-переменных пакета), ID которого указывается в p_event
    (если он не пуст);
2 - инициализация контекстов - системного и пользовательского, инициализация
    контекста доступа опциональна - она выполняется, если p_event<>'0';
3 - выполнение PL/SQL блока, текст указывается в p_event;
4 - сброс флагов инициализации типов (p_event - ID типа, если пуст, тогда
    сбрасывается состояние всех типов);
5 - блокировка контекста пользователя - все значения атрибутов всех контекстов
    сбрасываются в null, без дальнейшей возможности их пере инициализации
    (p_event несущественен);
6 - сброс состояния пакетов (сбрасываются все значения всех переменных всех 
    пакетов) и переинициализация системного контекста (p_event несущественен);
7 - переинициализация флага возможности редактирования прикладных данных и
    текущего приоритета запускаемых операций (вызывается при изменении системных
    настроек PLP_READ_ONLY и CURRENT_PRIORITY, p_event несущественен);
8 - привязка сессии к серверу LOCK_INFO, в p_event указывается порядковый номер
    сервера (в пределах от 0 до значения настройки LOCK_SERVERS без единицы);
9 - событие закрытия сессии, т.е. принудительное выполнение rtl.close;
10- событие сброса кэша системных настроек SETTINGS (в P_EVENT
    передается имя настройки, если не указывается, сбрасывается весь кэш
    настроек);
11- событие сброса кэша настроек профилей PROFILES (в P_EVENT передается
    имя профиля и имя настройки, разделенные точкой, если не указывается,
    сбрасывается весь кэш настроек);
12- событие сброса кэша интерфейсных пакетов типов (в P_EVENT передается
    ID типа, ID экземпляра, признак очистки родительских интерфейсных пакетов
    - константа TRUE или FALSE, - разделенные точкой);
13- событие вызова прикладной операции (в P_EVENT передается вызов
    операции в формате <%PLPCALL%>);
14- событие сброса значений кэша метаданных для заданного в p_event
    ID типа (если задано пустое значение - сбрасывается весь кэш). Событие
    инициируется в триггерах и процедурах изменения метаданных;
15- событие сброса кэша нумератора или календаря, используется для оповещения
    других сессий о том, что были изменены данные об этих объектах (для сброса 
    кэша нумератора в P_EVENT передается ID нумератора, для сброса кэша 
    календаря в P_EVENT передаётся строка '.'||ID календаря);
16- событие включения режима "только чтение" для сессии (в P_EVENT передаётся
    значение '1' - режим включен, или '0' - режим выключен). 
Все остальные коды интерпретируются как посылка сообщения с текстом p_event,
однако использовать положительные коды не рекомендуется, т.к. этот диапазон
резервируется под предопределенные события в системе.
    Чтобы событие обработалось в клиентской сессии достаточно выполнить
процедуру rtl.read (эта процедура вызывается во многих местах при активной работе
пользователя, а также при его не активности периодически выполняется Навигатором),
которая вычитает весь буфер посланных этой сессии событий. Результат отработки
событий и сообщения помещаются в буфер клиентской сессии.

5.2. Разъяснения по поводу поддержки системных индексов:
  - системные (технологические) индексы создаются исключительно для поддержки
    целостности данных, в прикладных целях они также могут использоваться,
    однако нужно иметь в виду, что имена индексов создаются автоматически и
    зависят от структуры таблицы, поэтому привязки прикладной логики к их
    именам быть не должно;
  - индексы создаются по всем колонкам-ссылкам и коллекциям, если не указано
    свойство "Не создавать ограничения целостности" для соответствующей колонки,
    делается это для поддержки целостности по ссылкам и уникальности по коллекциям,
    также создается индекс и по колонке COLLECTION_ID (если она есть);
  - индексы не создаются по колонкам, которые участвуют в прикладных индексах
    в качестве первой колонки (в этом случае для поддержки целостности
    используются прикладные индексы);
  - индексы не создаются по колонкам, которые продублированы из родительских
    типов (даже если это колонки-ссылки или коллекции), т.к. необходимая
    целостность данных поддерживается на колонках родительской таблицы, данные
    в дочернюю переносятся триггером;
  - в версии ТЯ 6.0 и выше при создании прикладного индекса, использующего
    автоматически индексируемую колонку в качестве первой, системный индекс
    по этой колонке удаляется за ненадобностью (в этом случае для поддержки
    целостности используется созданный прикладной индекс).
Замечания по поводу использования function based индексов:
  - при использовании формулы для колонки-ссылки в первой позиции индекса,
    системный индекс для той же колонки не удаляется;
  - в function based индексах допустимо использование только таких функций,
    которые определены как deterministic (имеют детерминированное значение,
    т.е. для одного и того же набора значений параметров всегда возвращают
    один и тот же результат)
  - использование function based индексов возможно только в сессиях, в которых
    установлен параметр query_rewrite_enabled в значение true. Т.о., если
    предполагается использование таких индексов, то нужно позаботиться о выставлении
    этого параметра. Это можно сделать на уровне экземпляра Oracle, можно
    добавить установку этого параметра в профили пользователей в настройку
    ALTER_SESSION (по аналогии с параметрами оптимизатора), либо явно выполнить
    SQL команду в пользовательской функции инициализации сессии или типа, где
    такой индекс используется (это можно сделать через rtl.execute_sql):
        alter session set query_rewrite_enabled=true

5.3. Хинт deterministic выставлен всем функциям ТЯ, используемым в выборках, а также
функциям интерфейсных пакетов типов. На данный момент во всех версиях Oracle
(9.2.0.7 и ниже) существует баг, суть которого в том, что хинт deterministic
игнорируется при выполнении запросов. Т.е. несмотря на описание, которое
гласит, что при использовании в SQL-запросах deterministic функций используется
оптимизация вызова таких функций по набору фактических значений (утверждается,
что для одного и того же набора значений параметров функция выполняется один
раз, а затем при тех же значениях параметров используется уже вычисленное
значение, реально же функция вычисляется на каждый ее вызов, независимо от
значений параметров). В Oracle10g (начиная с 10.2.0.2) этот хинт уже работает.

5.4. Разъяснение по поводу использования динамических запросов
DBMS_SQL и native dynamic SQL (execute immediate). Основные различия:
- DBMS_SQL имеет дополнительные накладные расходы на binding используемых
  в запросах переменных, т.к. под них выделяются дополнительные буфера,
  тогда как в native этого нет, т.е. связывание значений при выполнении
  запросов в native происходит быстрее.
- С другой стороны native всегда выполняет разбор (парсинг) запросов,
  тогда как в DMBS_SQL отпарсить запрос можно только один раз, зато
  исполнять можно сколько угодно раз. При большом количестве запусков
  однотипного запроса DBMS_SQL может быть значительно эффективней,
  чем native за счет экономии на разборе запросов.
- По разному обрабатываются определенные пользователем исключения.
  Native не может различать исключения, определенные пользователем,
  если они не привязаны к номеру ошибки.
- Функции пакета RTL - EXECUTE_SQL и EXEC_SQL_OUT при задании параметров,
  для связывания, начиная со второй bind-переменной работают в режиме
  DBMS_SQL, иначе работают в режиме execute immediate.
		Пример:
        declare
          i integer;
          s varchar2(100) := 'begin if :v1=''1'' then raise rtl.no_data_found; end if; end;';
        begin
          begin
            stdio.put_line_buf('execute immediate call');
            i := rtl.execute_sql(s,':v1','1');
          exception
            when rtl.no_data_found then
              stdio.put_line_buf('rtl.no_data_found catched');
            when others then -- попадаем сюда
              stdio.put_line_buf('rtl.no_data_found not catched');
          end;
          begin
            stdio.put_line_buf('DBMS_SQL call');
            i := rtl.execute_sql(s,null,null,':v1','1');
          exception
            when rtl.no_data_found then -- попадаем сюда
              stdio.put_line_buf('rtl.no_data_found catched');
            when others then
              stdio.put_line_buf('rtl.no_data_found not catched');
          end;
        end;

5.5. Разъяснение по поводу использования большого количества колонок
в таблицах ТБП. Не рекомендуется создавать в таблицах ТБП большое
количество колонок (более 200) по следующим причинам:
- размеры интерфейсных пакетов таких типов становятся очень
  большими, просто загрузка таких пакетов в память пользовательских
  процессов может быть достаточно ресурсоемкой (в части времени
  загрузки и занимаемого объема памяти);
- процедура создания интерфейсных пакетов типов реализована
  в PL/SQL, в котором размер строк ограничен (32K), что чревато
  проблемами переполнения используемых при генерации пакетов
  строковых буферов (которые не могут превышать размер 32К);
- алгоритмы функций получения-установки реквизитов реализованы
  через if-elsif операторы, которые перебирают возможные значения
  квалификаторов реквизитов для заданного типа. Т.к. язык PL/SQL
  является интерпретаторным языком, то такой перебор сотен значений
  может отнимать значительные вычислительные ресурсы сервера,
  сравнимые с выполнением SQL-запросов.

5.6. Расширены функции отладки в пакете RTL. Добавлен дополнительный
канал вывода отладочной информации в файл (константа DEBUG2FILE),
вывод в файл DEBUG_FILE, буфер сессии DEBUG_BUF (процедура DEBUG
выводит информацию в заданный в SET_DEBUG канал, по умолчанию -
в буфер сессии DEBUG2BUF), настройка вывода в файл SET_DEBUG_FILE и
получение этих настроек GET_DEBUG_FILE.

5.7. Новая версия технологического ядра переведена на безобъектную
    технологию: упразднены системные таблицы маршрутизации
    OBJECTS, COL2OBJ, REFS. Вся логика, которую эти таблицы
    отражали, перенесена в системные VIEW и функции интерфейсных
    пакетов типов. Для более эффективной работы операций в новых
    условиях рекомендуется придерживаться следующих несложных правил
    при написании кода операций:
    - отказаться от процедур и функций пакетов LIB и RTL,
        а вместо них использовать соответствующие модификаторы:
        %lock           -   процедура rtl.lock_object;
        %state          -   rtl.object_state;
        %state (как назначаемый адресат) - процедура rtl.change_state;
        %collection     -   rtl.object_collection;
        %class(к ссылке)-   rtl.object_class;
        %class(к коллекции) -   rtl.collection_class;
        %parent(к ссылке)-  rtl.object_parent;
        %parent(к коллекции)-   rtl.collection_parent;
        %parentclass    -   rtl.object_parent_class;
        %entity(к ссылке)-  rtl.object_class_entity;
        %entity(к типу)-  rtl.class_entity;
        %classparent(к ссылке)- rtl.object_class_parent;
        %classparent(к типу)- rtl.class_parent;
        %size(0)              - lib.c_count;
        %size(1)              - lib.c_empty;
        Необходимость такой замены диктуется тем, что функции пакетов
        LIB и RTL сначала определяют тип ссылки по брутто-VIEW
        OBJECTS, а затем динамически строят запросы по соответствующим
        таблицам типов, тогда как вызовы модификаторов транслируются_
        в соответствующие вызовы интерфейсных пакетов, которые знают
        априори что и где лежит.
    - нежелательно использовать переменные типов reference(ref object),
        collection для получения значений модификаторов, т.к. в этом
        случае будут вызываться те же функции RTL. Их удобно использовать
        при пере присвоении ссылок несовместимых типов. Использовать
        модификаторы лучше к ссылкам на типы, являющимися вершинами
        типовых иерархий.

5.8. Дополнительные возможности по управлению блокировками:
  1. При запросе на блокировку экземпляра функция RTL.LOCK_OBJECT
     выдает исключение CANNOT_LOCK не сразу, а после нескольких
     попыток с некоторым ожиданием между попытками.
  2. Количество попыток считывается из параметра LOCK_RETRY
    (Администратор - Словарь - Системные справочники - Параметры).
    Если параметр или не установлен, или меньше 0, или больше 10,
    то принимается значение по умолчанию, равное 5.
  3. Время ожидания между попытками блокировки считывается из
    параметра LOCK_DELAY (Администратор - Словарь - Системные
    справочники - Параметры). Если параметр или не установлен,
    или меньше 0, или больше 10, то принимается значение по
    умолчанию, равное 1. Значение задается в секундах с точностью
    до сотых долей секунды (т.о. минимальная задержка 0.01с,
    максимальная 10с).
  4. Если задать параметры равными 0, то система будет работать
    по-старому.
  5. Ограничение количества одновременно выполняющихся критических
    операций определяется параметром LOCK_ACTIVE (Администратор -
    Словарь - Системные справочники - Параметры). Если параметр не
    установлен или равен 0, то ограничений нет. Операция считается_
    критической, если у нее установлен флаг "Ограничить число
    одновременно выполняющихся операций" на вкладке "Дополнительные
    свойства" формы редактирования операции в Администраторе.

5.9. Некоторые указания по оптимизации PL/Plus кода:
Скорость выполнения основных базовых операций PL/SQL (в порядке убывания):
- сравнение и арифметические операции с pls_integer,
- сравнение строк и чисел (не pls_integer), строковые операции,
(конкатенация), преобразование строк и чисел между собой,
- строковые функции (substr,instr,replace,lpad,rpad,ltrim,rtrim,upper,lower),
- арифметические действия с числами (не pls_integer), функции форматирования
чисел (round,trunc),
- числовые функции (power, exp, ln, log, sin, cos ...),
- sql-запросы.

5.10. Тип pls_integer (integer в PL/Plus) может эффективно использоваться
в следующих конструкциях:
- индексирование pl/sql таблиц,
- индексирование при работе со строками (поиски, instr, substr),
- счетчики (если известно, что они не превысят лимит для pls_integer),
- флаги и коды некоторых действий (т.е. исчисляемые множества).
Нельзя использовать pls_integer для хранения авто нумерующихся
значений, которые берутся из последовательностей Oracle (в частности
ID экземпляров и коллекций), т.к. значения последовательностей
могут превысить лимит для pls_integer.

5.11. Следует иметь в виду, что даже просто вызовы pl/sql процедур
и функций занимают некоторое время, что в случае, когда
исполняемый код таких процедур и функций сам по себе быстрый,
то накладные расходы на вызов могут составлять существенную часть
времени вычисления самой функции. В таких случаях такие функции
рекомендуется заменять на макросы, которые необходимые действия будут
выполнять в линейном коде, без дополнительных перевызовов.

5.12. Ряд стандартных функций (SYS_CONTEXT, SYS_GUID, UID, USERENV)
в PL/SQL выполняются достаточно медленно (медленнее, чем чисто pl/sql
функции, не выполняющие sql-запросов), т.к. они всегда выполняют sql-запрос
select ... from dual (см.п.5.9).
Эти функции эффективны при использовании именно в SQL-запросах,
в PL/SQL их нужно по возможности заменять на обращения к переменным PL/SQL.

5.13. C другой стороны, использование PL/SQL функций в SQL-запросах также
очень тяжеловесно для Oracle, т.к. вызов PL/SQL функций из SQL имеет
довольно значительный и достаточно медленный overhead. Этот overhead
особенно значителен в версии Oracle8i, вызов PL/SQL функций под Oracle9i
происходит существенно быстрее. В таких случаях нужно максимально сокращать
количество используемых вызовов PL/SQL функций:
- путем замены логики функции на подзапросы и case-выражения,
- путем использования хинта deterministic, чтобы подавить вызовы
  для одинаковых значений параметров (с надеждой на будущее, что это
  все-таки будет работать и в SQL запросах - см.п.5.3),
- соединения нескольких вызовов в один и возвращения большего количества
  информации за один вызов с последующим разбором результата в sql,
- путем заполнения контекста и использования его в запросах.

5.14. Следует избегать использования PL/SQL функций в условии where
выборки данных, т.к. объем обрабатываемых данных в where может существенно
превышать результирующий набор данных, что существенно увеличивает
накладные расходы на вызов PL/SQL функций. Особенно это касается
версии Oracle10g, в котором по-другому устроен алгоритм разбора
выражения where (Oracle8i/Oracle9i проверяет условия с PL/SQL функциями
в последнюю очередь, т.е. сначала отрабатывают непосредственные условия
и SQL-функции; Oracle10g обрабатывает PL/SQL функции наравне с SQL-функциями,
что в некоторых случаях может приводить к гораздо большему количеству
их вызовов, и, как следствие, к существенному увеличению времени
выполнения запроса за счет неоправданного большого количества вызовов
и накладных расходов на их вызов).

5.15. Разъяснение по используемому алгоритму определения перехода
при смене состояния экземпляров (модификатором %state):
<object_ref>%state [(<transition_method> [,<do_access_check>] )] := <new_state_id>
где
  object_ref - ссылка на экземпляр, состояние которого должно быть изменено;
  new_state_id - идентификатор (короткое имя) состояния, в которое должен перейти экземпляр;
  transition_method - короткое имя операции перехода в заданное состояние
                      (опционально - по умолчанию пусто);
  do_access_check - признак проверки прав доступа на заданный переход
                    (опционально - по умолчанию false, т.е. нет проверки).
Переход из одного состояния (начального) в другое состояние (конечное) происходит
следующим образом:
  1) Если начальному состоянию назначена операция проверки, то она вызывается и,
     если она завершается с исключением, переход не происходит.
  2) Ищется переход, удовлетворяющий следующим условиям (перебор переходов происходит
     в порядке возрастания свойства POSITION, т.е. порядкового номера), условия
     проверяются в указанном порядке:
     a) Начальное состояние перехода должно совпадать с состоянием экземпляра,
        которое мы хотим сменить.
     b)	Если transition_method задан и не пуст, то операцией перехода должна
        быть операция с коротким именем transition_method. Если для transition_method
        задано значение '<NULL>', то ищется переход с пустой операцией перехода
        (это действительно для версий ТЯ 7.0 и выше).
     c) Если new_state_id не пусто, то  конечным состоянием перехода должно быть
        заданное состояние new_state_id.
     d) Если переход удовлетворяет предыдущим условиям и у него задана операция
        проверки перехода, то ее вызов должен завершиться без генерации исключения.
     e) Если do_access_check задан значением true, то переход должен быть доступен
        пользователю, выполняющему переход.
  3) Если таких переходов нет, состояние экземпляра не изменяется, если же переход
     найден, то:
     a) Если у него не задана операция перехода, то экземпляр переходит в состояние,
        заданное как конечное для этого перехода.
     b) Если операция перехода задана, то она запускается на выполнение:
        - если она завершилась без ошибок (без генерации исключений) и при этом
          не сбросила флаг подтверждения перехода (через процедуру rtl.change_state_error),
          экземпляр переходит в состояние, заданное как конечное для этого перехода;
        - в противном случае, состояние экземпляра не изменяется.
  4) Изменения, вносимые в базу данных операциями проверки переходов и состояний,
     откатываются (на умолчательный SAVEPOINT, устанавливаемый перед их вызовом),
     если эти операции завершились генерацией исключения (сами исключения операций
     проверки перехватываются внутри процедур смены состояния).
  В версии ТЯ 7.0 реализован функционал по точному поиску перехода с пустой
операцией перехода (стандартный поиск при указании пустой операции
перехода означает поиск с ЛЮБОЙ операцией перехода). Для точного
поиска перехода с пустой операцией перехода нужно указать значение
'<NULL>' для короткого имени операции перехода в модификаторе %state.

5.16. В версии ТЯ 7.0 произведен реинжиниринг структуры интерфейсных
пакетов типов, направленный на возможность использования как
актуальных, так и архивных данных в одном интерфейсном пакете
Ранее текст интерфейсных пакетов позволял работу только в одном
режиме - либо только актуальные данные, либо полный набор данных
(включая архивные), поэтому для изменения режима работы требовалось
интерфейсные пакеты полностью пересоздавать (см.п.4.3).
  В новой версии ТЯ интерфейсные пакеты для секционированных типов
содержат оба варианта кода (использующего только актуальные данные
и использующего архивные данные).

  Режим выполнения функций и процедур интерфейсных пакетов
определяется параметром key_, который добавлен почти во все
базовые функции и процедуры. Значение параметра key_ интерпретируется
следующим образом:
  - key_ is null - работа только с актуальной секцией
                   (значение по умолчанию);
  - key_ < 0 - работа с архивными секциями, для условия на ключ
               архивации используются текущие значения ключей
               архивации (которые хранятся в class_tables и
               загружаются в контекст <IBSO owner>_KEYS - см.п.4.1);
  - key_ >=0 - работа с архивными секциями, для условия на ключ
               архивации используется заданное значение key_
               (значение 0 означает использование ВСЕХ архивных
               секций).
  Если тип устроен иерархически, то заданное значение key_
распространяется и на порожденные вызовы интерфейсных пакетов
по иерархии. Поэтому, для использования значений key_>0,
ключи архивации должны быть согласованными в пределах этой
иерархии (т.е. одно и то же значение ключа секционирования должно
отсекать логически согласованные данные связанных иерархически
типов). Порожденные вызовы других интерфейсных пакетов (вызовы
по ссылкам, поиск владельца коллекций, удаление элементов коллекций)
для значений key_>0 вызываются в режиме умолчательного условия
на ключ архивации (т.е. со значением key_=-1).
  Процедуры изменения данных для архивов работают только если
тип секционирован по механизму PARTITION (Oracle partitioning),
причем изменение состояний (STATE_ID) и принадлежности коллекций
(COLLECTION_ID), а также создание новых экземпляров осуществляются
только в актуальной секции.

5.17. В версии ТЯ 7.0 реализована адресная рассылка событий обновления
кэша экземпляров в интерфейсных пакетах типов при изменении кэшируемых
реквизитов экземпляров. Алгоритм реализации основан на "подписке"
на рассылку событий 0 и 12 (см.п.5.1) пользовательских сессий в момент
занесения первого экземпляра в кэш. Сама рассылка событий 0 и 12
производится в момент выполнения фиксации изменений (процедурой
cache_mgr.cache_commit, которая используется для PL/Plus оператора
COMMIT) только тем сессиям, которые подписались на рассылку, а не
для всех зарегистрированных сессий (как было прежде).
  Техническая реализация основана на использовании пайп-каналов Oracle.
Для каждого кэшируемого типа создается две пайпы - одна для списка
зарегистрировавшихся сессий, другая  - для поддержки сериализованного
доступа к этому списку (т.е. для нетранзакционной блокировки списка
сессий).
  Для поддержки механизма подписок и рассылок по подпискам  в пакете
cache_mgr опубликован следующий интерфейс (который может быть использован
и в прикладном коде для организации рассылок других событий, кроме
обновления системного кэша интерфейсных пакетов):

procedure reg_pipe_events (p_pipe varchar2, p_add boolean)
  Подписка-отписка на событие:
  p_pipe - некий строковый идентификатор объекта, на который производится
           подписка (для системного кэша - это просто ID типа), т.е. имя
           именованного списка;
  p_add  - признак подписки:
     false - удаление своей сессии из списка рассылки,
     true,null - добавление своей сессии в список рассылки (значение
             null просто добавляет без всяких дополнительных проверок
             существования своей же сессии в списке).

procedure send_pipe_events(p_pipe varchar2, p_code pls_integer, p_event varchar2)
  Рассылка заданного события для заданного списка:
  p_pipe - некий строковый идентификатор объекта, на который производилась
           подписка (для системного кэша - это просто ID типа), т.е. имя
           именованного списка;
  p_code - код события (пустое значение просто обновляет список подписчиков,
           т.е. удаляет отсутствующие сессии);
  p_event- текст сообщения или информация для события (интерпретация
           определяется кодом события).

procedure refresh_cache_pipes(p_init_classes boolean default null)
   Обновление списков сессий в пайповых кэшах:
   p_init_classes - режим обновления:
     null (по умолчанию) - обновление пайп для существующих списков рассылки
            кэшируемых типов,
     true - обновление и инициализация (если не существует) пайп для
            кэшируемых типов,
     false- обновление для любых уже существующих списков рассылки,
            т.е. не только для кэшируемых типов, но и для пользовательских
            списков.

В версии ТЯ 7.1 расширен интерфейс адресной рассылки - добавлена
возможность регистрации пользовательского события для выполнения
адресной рассылки в момент фиксации транзакции:

procedure reg_event (p_code pls_integer, p_event varchar2, p_pipe varchar2 default null);
    Регистрация события для рассылки в момент фиксации транзакции:
    p_code - код события;
    p_event- текст сообщения или информация для события (интерпретация
             определяется кодом события);
    p_pipe - имя именованного списка адресной рассылки (имя пайпы адресной рассылки),
             пустое значение - адресная рассылка не будет использоваться;

procedure reg_clear (p_code pls_integer default null);
   Очистка списка событий для рассылки при выполнении фиксации транзакции:
   p_code  - код события, которое следует очистить (пустое значение означает
             очистку всех событий).


5.18. В версии ТЯ 7.0 реализованы упрощенный режим проверки
существования пользовательских сессий и доверительный режим
получения списка сессий от сервиса lock_info. В частности,
новый (доверительный) режим используется в механизме рассылки
событий (для событий 0 и 12 отдельно реализован механизм
подписок - см.п.5.17). Также в процедуру получения списка
сессий добавлена возможность фильтрации списка сессий по
номеру узла RAC (Real Application Cluster).
Расширены интерфейсы пакетов RTL и LOCK_INFO (подробности в
rtl.txt, lockinfo.txt).

5.19. В ТЯ 7.1 доработан механизм кэширования экземпляров (п.5.17),
реализована синхронизация кэшей в дочерних типах при изменении
родительских реквизитов.

5.20. Стандартная процедура сбора статистики в версии ТЯ 7.0
и выше работает только через пакет dbms_stats.
Режим использования команды ANALYZE не используется.

5.21. Реализовано приведение временных зон при переносе данных
о некорректных логинах пользователей из журнала системного аудита
(dba_audit_trail) в журналы схемы аудита (AUD) (ТЯ 7.1 и выше).

5.22. В версии ТЯ 7.2 произведен рефакторинг интерфейсных пакетов типов:
- реализованы именованные функции для получения и установки
  значений реквизитов экземпляров (для всех скалярных реквизитов
  get/set функциям присваиваются имена g#<attr_id>/s#<attr_id>,
  для структурных реквизитов публикуются только функции для
  не вложенных структур get/set - g$<attr_id>/s$<attr_id>);
- реализована процедура set$value для установки значений
  скалярных реквизитов по переданному строкой квалификатору
  реквизита (аналог get$value, которая считывает значения).

5.23. В версии ТЯ 7.2 реализован новый режим кэширования для одного
экземпляра в интерфейсных пакетах типов (кэширование горячего экземпляра).
Этот режим задается значением -1 для колонки cached в таблице
class_tables. Новый режим характеризуется следующими свойствами:
- кэшируется один экземпляр, к которому было произведено
  последнее обращение;
- при обращении к другому экземпляру, экземпляр в кэше
  заполняется реквизитами нового экземпляра;
- статический экземпляр (если есть) кэшируется отдельно;
- кэшируемый экземпляр существует на протяжении транзакции,
  по командам завершения-отката транзакции кэш сбрасывается;
- при модификации экземпляра рассылки событий не происходит
  (это не требуется, т.к. кэш живет только в течение транзакции,
  так что другие сессии сделанные изменения увидят по завершении
  своих транзакций после выполнения commit/rollback).
Данный режим может быть эффективен для типов, работа с экземплярами
в которых построена на многочисленных (в течение транзакции) обращениях
к одному экземпляру (например, проводка документа).


        6. Ключевые и функциональные реквизиты.

6.1. Ключевые и функциональные реквизиты появились в ТЯ,
начиная с версии 6.5.

6.2. Ключевые реквизиты (строковые идентификаторы экземпляров).
Основные ограничения:
- тип - строка длиной не более 128 символов.
- ключевой реквизит может быть определен только у
  типа, не имеющего родителя, притом только один.
  (дочерние типы автоматически его наследуют).
- создать новый ключевой реквизит можно только
  у типа, не имеющего таблицу.
- у типов, имеющих таблицу, сделать ключевым можно
  только существующий строковый реквизит, который
  не является функциональным (вычисляемым).
- удалить ключевой реквизит нельзя, его нужно
  предварительно сделать обычным.
- запрещен перенос реквизита по иерархии типов.

6.3. Функциональные реквизиты (вычисляемые).
Основные ограничения:
- тип - скалярный, при этом не OLE, не массив.
  Т.е. допустимы следующие базовые типы:
        STRING     - строка
        NUMBER     - число
        REFERENCE  - ссылка
        MEMO       - текст
        DATE       - дата
        BOOLEAN    - логика
- изменить тип реквизита для существующего можно только
  у обычного (ключевой сделать функциональным нельзя
  и наоборот).
- запрещен перенос реквизита по иерархии типов.
- у типов, имеющих таблицу, колонки для функциональных
  реквизитов не создаются.
- при создании функционального реквизита создается
  операция с флагом A, с именем, коротким именем
  и возвращаемым значением совпадающими с реквизитом.
- при изменении функционального реквизита изменяются
  соответствующие атрибуты операции для реквизита.
- при удалении функционального реквизита операция
  по умолчанию также удаляется.
- при смене реквизита на обычный операция не удаляется.
Подробнее про использование функциональных реквизитов -
см. plplus.txt пп.2.11-2.13 изменений на 01.03.2006,
а также пп.2.5-2.6 изменений на 10.05.2006.

6.4. При использовании ключевых и функциональных реквизитов в
PL/Plus запросах дополнительное соединение по ссылке с целевой
таблицей по умолчанию не делается, используется непосредственно
значение самой ссылки. Соединение устанавливается в случае
использования типизованных ссылок, переопределении типов,
а также при использовании SQL выражения (plplus.txt - п.2.13
изменений на 01.03.2006), которое использует обращения к
другим реквизитам, которые требуют соединения с целевой
таблицей.

6.5. При заведении функционального реквизита в типе, имеющем
таблицу, если в таблице существовала колонка, соответствующая
этому реквизиту, то она перестает использоваться, т.е. ни
в интерфейсном пакете ТБП, ни в коде PL/Plus обращений к этой
колонке не будет.

6.6. При заведении ключевого реквизита в типе, имеющем таблицу,
при выполнении хранения производятся следующие действия:
Собственный тип (в котором как раз и определен ключевой реквизит,
т.е. это верхнеуровневый тип, - он обрабатывается первым):
- значения текущей колонки ID переносятся в колонку OLD$ID.
- значения текущей колонки, соответствующей ключевому реквизиту,
  переносятся в колонку ID, пустые значения инициализируются из SEQ_ID.
- колонка, ранее соответствовавшая ключевому реквизиту, перестает
  использоваться на уровне кода PL/Plus и интерфейсов ТБП.
- заполняется колонка class_tables.old_id_source значением OLD$ID.
При этом удаляются все существующие ссылочные ограничения, которые
указывали на эту таблицу, а также создается уникальный индекс по колонке
OLD$ID (новый системный индекс).
Затем выполняется хранение для дочерних типов, затем - ссылающихся типов.
В этих типах колонка OLD$ID не создается, трансляция старых значений
в новые осуществляется через связку ID-OLD$ID в базовой таблице
(т.е. через значение в class_tables.old_id_source).
При обратном преобразовании в базовом типе происходит следующее:
- значения текущей колонки ID переносятся в колонку с именем, соответствующим
  имени реквизита - С_<ATTR_ID> (если колонка физически существует,
  то она переиспользуется).
- создается числовая колонка ID, значения которой инициализируются из SEQ_ID.
- заполняется колонка class_tables.old_id_source значением С_<ATTR_ID>.
Преобразование ссылающихся типов происходит по той же схеме.

6.7. При заведении ключевого реквизита в типе, имеющем таблицу,
реализован также режим преобразования таблицы через перестроение:
Собственный тип:
- создается новая таблица БЕЗ колонок, соответствующих ранее
  ключевому или функциональным реквизитам.
- в колонку ID новой таблицы переносятся значения колонки,
  заданной как ключевой, пустые значения инициализируются из SEQ_ID.
- старая таблица НЕ удаляется, с нее удаляются все индексы, ограничения,
  триггеры, создается единственный индекс по ключевой колонке C_<ATTR_ID>.
- заполняется колонка class_tables.old_id_source значением OLD_TABLE.C_<ATTR_ID>.
Удалять старую таблицу ДО перестроения (или преобразования) ВСЕХ ссылающихся типов
категорически НЕ рекомендуется, т.к. тогда будет полностью утеряна информация
о старых значениях ID, соответственно, не сконвертированные ссылки уже не могут
быть преобразованы. Также не рекомендуется снова перестраивать таблицу,
т.к. при перестроении с уже преобразованной колонкой, перестроение будет
идти в обычном режиме, при этом старая таблица будет удалена, поле
class_tables.old_id_source очищено, так что конвертация ссылок станет
невозможной.
После перестроения основной таблицы нужно перестроить сначала дочерние,
а затем - ссылающиеся типы. При их перестроении информация о трансляции
старых значений ID в новые используется по значению class_tables.old_id_source
базовой таблицы.
При обратном перестроении в базовом типе происходит следующее:
- значения текущей колонки ID переносятся в колонку с именем, соответствующим
  имени реквизита - С_<ATTR_ID>.
- создается числовая колонка ID, значения которой инициализируются из SEQ_ID.
- заполняется колонка class_tables.old_id_source значением С_<ATTR_ID>.
- старая таблица удаляется.
Если в базовой таблице существовали ссылки на себя, то при обратном преобразовании
эти ссылки не могут быть преобразованы за один раз (т.к. новые ID только
создаются), поэтому после перестроения нужно дополнительно выполнить хранение
для их преобразования (п.6.6).
Перестроение ссылающихся типов происходит по той же схеме.

6.8. Простые представления, ссылающиеся на колонки, которые
преобразованы в ключевые или функциональные, формально могут
оставаться валидными до тех пор, пока такие колонки физически
присутствуют в таблицах (до первого их перестроения), однако
извлекаемые данные все равно будут неадекватными.

6.9. В связи с возможностью использования символьных идентификаторов
дополнительно изменены интерфейсы всех функций ТЯ, работающих
с экземплярами, т.е. везде, где в качестве параметров используются
ID экземпляров числовой тип заменен на строковый. В Pl/Plus
тип ссылок определяется в соответствии со свойствами типа,
т.е. на уровне PL/SQL отображаются либо в число, либо в строку.

6.10. Изменена структура и типы колонок системных представлений.
Созданы два представления для экземпляров:
  OBJECTS  - с числовым ID,
  OBJECTSS - со строковым ID (туда включены и таблицы ТЯ, соответствующие
             метаклассам).
Изменен тип колонки OBJECT_ID вьюх VW_C2O_<CLASS> и COL2OBJ с
числового на строковый.

6.11. Изменены типы колонок таблиц ТЯ, содержащих ID экземпляров,
с числового на строковый:
  OBJ_STATIC.ID
  LONG_DATA.OBJECT_ID
  OBJECT_RIGHTS.OBJ_ID
  OBJECT_RIGHTS_EX.OBJ_ID
  OBJECT_RIGHTS_LIST.OBJ_ID
Соответственно, изменены интерфейсы и логика функций администрирования
и проверки поэкземплярного доступа и трансляции правил доступа.
При смене типа колонки ID в таблице ТБП происходит также конвертация
данных в этих таблицах. При использовании таблиц поэкземплярного доступа
в подзапросах PL/Plus и условии проверки доступа в представлениях
в необходимых случаях используется явное приведение типов.

6.12. Изменен тип колонки OBJ_ID в журналах схемы аудита (AUD) с числового
на строковой. Реализованы процедуры конвертации данных (просто
конвертация - без перетрансляции):
Журнал изменения реквизитов - <owner>_VALSH.OBJ_ID
Журнал изменения состояний - <owner>_OSH.OBJ_ID
Журнал изменения коллекций - <owner>_OCH.OBJ_ID
Журнал электронного документооборота - <owner>_EDH.OBJ_ID

6.13. Сняты ограничения на использование PL/Plus SQL операторов
INSERT/UPDATE/DELETE при включенном журналировании создания
экземпляров и изменении состояний и коллекций, а также при
наличии функциональных реквизитов и включенном кэшировании.

6.14. Зафиксирован следующий порядок вызова операций для
функциональных реквизитов (внутри интерфейсного пакета ТБП):
- при чтении (вычислении):
  - для иерархически связанных типов (родитель-потомок) сначала
    происходит вычисление реквизитов родительских типов (в направлении
    от верхнеуровневого родителя к нижнеуровневому), а затем собственных
    реквизитов;
  - в пределах одного типа вызовы происходят по порядку следования
    реквизитов в этом типе;
- при установке значений (сохранении в БД) вызовы происходят в
  обратном порядке по отношению к чтению:
  - для иерархически связанных типов (родитель-потомок) сначала
    происходит установка собственных реквизитов, а затем родительских
    (в направлении от нижнеуровневого родителя к верхнеуровневому);
  - в пределах одного типа вызовы происходят в обратном порядке следования
    реквизитов в этом типе.
При разработке операций-реквизитов, во избежание недетерминированности
результата работы этих операций, алгоритм их работы следует строить так,
чтобы результат не зависел от количества вызовов операции-реквизита,
т.к. при использовании режима кэширования экземпляра this в простых
операциях количество таких вызовов зависит от структуры кода операции
(вычитывание-установка реквизитов определяются вызовами Get$Obj$This и
Set$Obj$This, которые добавляются в код по мере необходимости).



