
            Комментарии к пакету и сервисам LOCK_INFO.


            1. Введение.

  Перед работой в системе пользовательская сессия должна зарегистрировать свой
сеанс (функцией OPEN), чтобы получить доступ ко всему функционалу, в т.ч. и
сервисам LOCK_INFO. Зарегистрированной сессии пользователя присваивается
уникальный идентификатор, который устанавливается следующим образом:
  - пользовательским сессиям, работающим в двухуровневой архитектуре (клиент -
    сервер БД), в качестве ID сеанса присваивается значение AUDSID сессии
    (V$SESSION.AUDSID) Oracle, в которой осуществлено соединение с сервером
    Oracle.
  - пользовательским сессиям, работающим в трехуровневой архитектуре (клиент -
    сервер приложений, СП, - сервер БД), в качестве ID сеанса присваивается
    генерируемое системой значение в диапазоне -1073741824..-2147483647.
  - пользовательским сессиям, выполняющимся через очередь заданий Oracle
    (DBA_JOBS), в качестве ID сеанса присваивается отрицательное значение
    номера задания в очереди заданий Oracle (DBA_JOBS) - диапазон значений
    -1..-1073741823.

  Пакет поддерживает функции чтения-записи информации о блокировках в 
операциях словаря данных. Можно использовать функции пакета lock_info и для 
обмена информацией между пользователями, а также для использования механизма
логических блокировок и семафоров (например, поддержка блокировок файлов при
их совместном использовании).
  Пространство индексов ID логических блокировок-семафоров делится на 
следующие диапазоны:
  1. 0..10 - системные ID, их нельзя использовать.
  2. 11..2147483647 - ID блокировок (числовые).
  3. -1073741824..-2147483647 - значения HASH-функций строковых и числовых ID
     блокировок, которые не укладываются в диапазон 2.
  4. -1..-1073741823 - пользовательские ID блокировок.
  Диапазоны 2-3 используются при работе системы для хранения информации о
блокировках неких ресурсов системы (определяемых через заданные ID - алгоритмы
определяются функционалом, использующим эти блокировки). Следует иметь в виду,
что такие блокировки являются нетранзакционными и чисто логическими, которые
могут обрабатываться только программно, т.е. представляют собой некие 
семафоры. Снятие блокировок-семафоров диапазонов 2-3 осуществляется процедурой
CLEAR, причем если семафоры устанавливались с признаком subject = 'LOCK', то 
они снимаются процедурой CLEAR с параметром TRUE (автоматизированное рабочее 
место пользователя - Навигатор - выполняет это действие по завершении работы
верхнеуровневой, не вложенной, операции). Блокировки диапазона 4 процедурой
CLEAR не снимаются, их следует удалять только процедурой DEL.
  В системе отдельно выделен класс логических блокировок экземпляров ТБП,
которые используются в работе форм операций и которые реализуют парадигму
оптимистического блокирования. Логические блокировки экземпляров форм операций
хранятся в отдельном словаре FRM_LOCKS (см. ч.9). Эти блокировки уже имеют
транзакционную сущность и позволяют отслеживать изменения экземпляров ТБП
(подробнее см. ч.3,6).
  Процедура CLOSE завершает сеанс пользователя и снимает ВСЕ блокировки и
семафоры пользователя. При работе штатными средствами системы (например, в
Навигаторе) регистрация (OPEN) и завершение сеанса (CLOSE) делается самими
этими средствами.

  С версии ТЯ 7.3.1.0 внешние процессы LOCK_INFO не используются. Работа
сервиса осуществляется с помощью системных заданий.
  Основной сервис LOCK_INFO осуществляет контроль ресурсов зарегистрированных 
сессий, включает в себя следующие типы заданий:
  - задание  LOCK_REFRESH, отвечает за обновление списка зарегистрированных 
    сессий, удаляет "неживые" сессии, которые не подтверждают свое 
    существование;
  - задание EVENT_SERVICE, отвечает за рассылку событий между узлами кластера,
    существует только на схемах с поддержкой RAC.
  До ТЯ 7.3.1.0 основной сервис LOCK_INFO также обеспечивал работу механизма 
логических блокировок. Начиная с ТЯ 7.3.1.0 логические блокировки 
обрабатываются самим клиентским процессом, т.е. никакие дополнительные 
процессы для этого не нужны.
  Пакет lock_info также включает дополнительный сервис поддержки информации
о физических блокировках пользователей (подробнее см. ч.6).


            2. Пользовательские функции (доступные из PL/PLUS).

  В пакете lock_info определены следующие типы:
type users_info is record
(
  id         integer,    - идентификатор сессии зарегистрированного
                           пользователя;
  instance   integer,    - номер узла Real Application Cluster (RAC), считая 
                           от 0 до полного количества узлов кластера без 
                           единицы;
  sid        integer,    - sid сессии пользователя: V$SESSION.SID - для 
                           двухуровневых сессий и заданий, для трехуровневых 
                           сеансов не определен;
  userid     integer,    - уникальный идентификатор пользователя системы
                           доступа (поле присутствует только в ТЯ 7.3 и выше -
                           см. п.11);
  logontime  date,       - дата регистрации пользовательской сессии (поле
                           присутствует только в ТЯ 7.3 и выше - см. п.11);
  ses_id     string(20), - дополнительный идентификатор сессии из
                           V$SESSION.CLIENT_INFO: для трехуровневых сессий - 
                           -ID сессии пользователя, для двухуровневых - 
                           значение utils.session_id, для заданий - номер 
                           задания очереди заданий;
  os_user    string(30), - системное имя пользователя: для двухуровневых 
                           сессий - V$SESSION.OSUSER, для трехуровневых - 
                           сетевое имя, для заданий - 'JOB';
  ora_user   string(30), - username сессии, имя зарегистрированного 
                           пользователя: для трехуровневых сессий - имя 
                           пользователя системы доступа, для двухуровневых и 
                           заданий - V$SESSION.USERNAME;
  username   string(64), - для двухуровневых сессий - имя компьютера из
                           V$SESSION.MACHINE, для трехуровневых сессий и 
                           заданий - полное имя пользователя;
  info       string(128) - дополнительная информация о сессии: для 
                           двухуровневых сессий - модуль, с помощью которого 
                           вошел пользователь из V$SESSION.MODULE/PROGRAM, для
                           трехуровневых - домен\сетевое имя пользователя,
                           для заданий - информация о задании (номер задания,
                           CLASS_ID и SHORT_NAME операции - из 
                           V$SESSION.MODULE);
); - информация о зарегистрированной сессии пользователя.

type locks_info is record
(
  id        number,      - числовой индекс блокировки-семафора, SCN экземпляра
                           для логических блокировок форм в FRM_LOCKS;
  user_id   integer,     - id сессии зарегистрированного пользователя, 
                           владельца блокировки;
  user_sid  integer,     - sid сессии владельца блокировки;
  time      date,        - дата и время установки блокировки;
  object    string(128), - object id блокировки-семафора, ID экземпляра в
                           FRM_LOCKS;
  subject   string(16),  - тип блокировки-семафора ('OBJECT' - умолчательный,
                           'CURSOR' - курсор, 'METHOD' - операция, 'LOCK' -
                           логическая блокировка, возможно задание других
                           типов), для блокировок в FRM_LOCKS - поле содержит
                           CLASS_ID (принадлежность типу) экземпляра;
  info      string(256), - дополнительная информация о блокировке, для
                           FRM_LOCKS всегда содержит префикс 'FORM: ';
  einfo     string(512)  - для логических блокировок форм операций 
                           (FRM_LOCKS - см.ниже) заполняется информацией об 
                           индентификаторах пользовательских сессий, внесших 
                           последние изменения в таблицы типов; для обычных 
                           логических блокировок поле не заполняется;
); - информация о логической блокировке.

type locks_tbl is table of locks_info; - тип - таблица блокировок.
type users_tbl is table of users_info; - тип - таблица пользователей.

function  open(p_name string default NULL, 
               p_info string default NULL) return integer;
- зарегистрировать текущий сеанс пользователя, чтобы были доступны все функции
системы. Возвращает  идентификатор зарегистрированной сессии пользователя в
случае успеха, иначе 0.
  Параметры умолчательные, их лучше не задавать (они используются для
внутренних проверок). Процедуру вызывать в операциях нет необходимости, т.к.
модуль "Навигатор" регистрируется автоматически при соединении с базой данных.
Информация о зарегистрированных пользователях дублируется в таблице RTL_USERS.
  До ТЯ 7.3.2.0 Функция автоматически ставила задание для запуска процесса
LOCK_INFO в очередь заданий Oracle (через DBMS_JOB), если процесс до момента
выполнения функции не был запущен. Начиная с ТЯ 7.3.2.0 при вызове функции не
происходит автоматического запуска сервиса LOCK_INFO, задание обновления 
списка сессий запускается только в случае, если при открытии сессии происходит
превышение ограничений SESSION_PER_USER или MAX_SESSIONS.

procedure close;
- завершить сеанс работы пользователя в текущей сессии. Процедуру вызывать в
операциях не нужно, т.к. модуль "Навигатор" завершает сеанс автоматически при
отсоединении от базы данных.

function  init_user(p_user in out users_info) return boolean;
- инициализирует структуру p_user информацией из списка сессий Oracle 
(V$SESSION для текущего узла RAC, GV$SESSION для других узлов RAC) и 
возвращает TRUE в случае успеха.
  В исходной структуре должно быть обязательно заполнено поле ID, также могут 
быть заполнены поля:
  instance - номер узла RAC (без единицы): если задано пустое значение, то 
             поиск производится  по всем доступным узлам RAC, если значение 
             задано не пустое, то сессия ищется на заданном узле;
  sid      - идентификатор сессии (V$SESSION.SID): если задано не пустое
             значение, то ищется сессия с заданным идентификатором sid,
             значение id сессии только проверяется (такой поиск на порядки
             быстрее и менее ресурсоемок, чем поиск по id, особенно при 
             большом количестве сессий).
  Остальные поля заполняются функцией в случае успеха.

function  session_exists(p_uid integer, p_sid integer) return boolean;
- возвращает признак существования сессии с заданным ID в p_uid и SID в p_sid:
true - сессия существует, false - сессия отсутствует.

function  session_status(p_uid integer, p_sid integer) return string;
- возвращает статус сессии с заданным ID в p_uid и SID в p_sid: 
ACTIVE/INACTIVE - если сессия живая, пусто - если сессия отсутствует или 
удалена.

function rtl_nodes return number;
- возвращает количество узлов RAC для экземпляра Oracle.

function rtl_node  return number;
- возвращает номер узла RAC (без единицы, т.е. считая от 0) текущей сессии.

function info_open return boolean;
- возвращает TRUE, если сессия пользователя зарегистрирована (OPEN выполнен).

function info_active return boolean;
- до ТЯ 7.3.2.0: возвращает TRUE, если процесс LOCK_INFO активен и 
пользовательский сеанс (сессия) зарегистрирован; начиная с ТЯ 7.3.2.0 и выше
возвращает TRUE, если сессия пользователя зарегистрирована.

function server_test(p_instance integer default null,
                     p_node     integer default null) return boolean;
- возвращает true, если сервис активен.
  Параметр p_instance определяет тип сервиса: если значение >=0 или null - 
основной сервис контроля зарегистрированных сессий, если значение < 0 - 
дополнительный сервис поддержки информации о физических блокировках 
пользователей.
  Параметр p_node задает номер узла кластера RAC (считая от 0 до полного 
количества узлов кластера без единицы - rtl_nodes-1). Если параметр p_node 
не задаётся, то используются текущие значения сессии пользователя (см. также 
атрибуты системного контекста - plphints.txt п.4.2).

procedure clear(p_all boolean default FALSE);
- сброс информации о блокировках текущей сессии пользователя.
  Если p_all (по умолчанию FALSE) установлен в TRUE, то удаляются все семафоры 
диапазона 2-3, а также блокировки форм (FRM_LOCKS), иначе только семафоры, у 
которых subject <> 'LOCK'. Пользовательские семафоры диапазона 4 не снимаются 
(они удаляются либо с помощью процедуры close, либо процедурой del).
  Эта процедура вызывается системой при работе форм операций по завершении 
операции со значением параметра p_all = true.

procedure put(p_object  string,
              p_subject string default NULL,
              p_info    string default NULL);
- поместить информацию о блокировке-семафоре.
  p_object - ID объекта. 
  p_subject - тип объекта, по умолчанию 'OBJECT' (если задавать p_subject = 
'LOCK', тогда эти семафоры не будут сбрасываться процедурой clear с параметром
false).
  p_info - дополнительная информация, сопутствующая семафору, ее можно не 
задавать. 
  Информация заносится в таблицу пользовательских блокировок без каких-либо 
проверок, причем владельцем устанавливаемой блокировки становится сессия 
пользователя, вызвавшая процедуру (т.е. текущая сессия пользователя). 
  Процедура работает только с блокировками-семафорами.

procedure put_get(p_object  string,
                  p_subject string default NULL,
                  p_info    string default NULL);
- поместить/извлечь информацию о блокировке-семафоре.
  p_object - ID объекта.
  p_subject - тип объекта, по умолчанию 'OBJECT'.
  p_info - дополнительная информация, сопутствующая семафору.
  При этом производится проверка существования объекта в таблице 
пользовательских блокировок, и если объект не найден, то добавляется новая 
запись для текущей сессии пользователя, иначе извлекается информация о 
существующей записи и ее владельце во внутренний буфер. 
  Процедура работает только с блокировками-семафорами.

procedure put_push(p_object  string,
                   p_subject string default NULL,
                   p_info    string default NULL);
- поместить/извлечь информацию о блокировке-семафоре.
  p_object - ID объекта.
  p_subject - тип объекта, по умолчанию 'OBJECT'.
  p_info - дополнительная информация, сопутствующая семафору.
  При этом производится проверка существования объекта в таблице 
пользовательских блокировок, и если объект не найден, то добавляется новая 
запись для текущей сессии пользователя, иначе извлекается информация о 
существующей записи и ее владельце во внутренний буфер. Одновременно эта 
информация заносится в вершину стека блокировок, указатель стека увеличивается 
на 1.
  Процедура работает только с блокировками-семафорами.

procedure get(p_object  string,
              p_subject string default NULL);
- извлечь информацию о блокировке во внутренний буфер. 
  p_subject по умолчанию = 'OBJECT'. При значении p_subject = 'FORM', 
извлекается информация о логической блокировке в FRM_LOCKS экземпляра с 
ID = p_object. При значении p_subject = 'V$LOCK', извлекается информация о 
физической блокировке в v$lock, точнее, о ждущей транзакции, которую после 
вызова get будет выполнять вызывающая сессия, т.е. вызов get в этом режиме 
просто отсылает sid своей сессии сервису физических блокировок, чтобы тот 
попытался поймать эту транзакцию в v$lock, пока вызывающая сессия ее 
выполняет. При получении ответа от сервиса (read, get_lock_info, get_info) в 
буфер заносится информация о сессии пользователя, удерживающего запрошенную 
транзакционную блокировку (подробности используемого алгоритма см.ч.10).

procedure get_push(p_object  string,
                   p_subject string default NULL);
- извлечь информацию о блокировке во внутренний буфер.
  p_subject по умолчанию = 'OBJECT'. При значении p_subject = 'FORM', 
извлекается информация о логической блокировке в FRM_LOCKS экземпляра с 
ID = p_object. Одновременно эта информация заносится в вершину стека 
блокировок, указатель стека увеличивается на 1. 

procedure del(p_object  string,
              p_subject string default NULL);
- удалить информацию о блокировке.
  p_subject по умолчанию = 'OBJECT'.
  Позволяет удалять любые блокировки и семафоры (в т.ч. диапазона 4), 
принадлежащие текущей сессии пользователя. При указании p_subject='DELETE' 
можно удалить блокировку-семафор, принадлежащую другой сессии. При значении 
p_subject = 'FORM', удаляется информация о логической блокировке в FRM_LOCKS 
экземпляра с ID = p_object (только если владельцем является текущая сессия 
пользователя, чужие блокировки не удаляются).

procedure read(p_wait number default 0);
- прочитать текущее состояние и события, отправленные пользователю, во 
внутренний буфер с ожиданием abs(p_wait) секунд. 
  Если p_wait<>0, то процедура ожидает получение сообщения из сессионной пайпы 
(при получении ответа процедура выходит из цикла ожидания), если p_wait=0, то 
процедура считывает текущее состояние без ожидания. Если p_wait<0, то 
процедура не запрашивает текущие RUNTIME настройки сервисов пакета lock_info 
из системных параметров.
  Начиная с ТЯ 7.3 не имеет смысла вызывать процедуру read c параметром 
p_wait<>0 с целью получения ответа на запросы open, close, clear, put_get, 
put_push, get, get_push, т.к. обработка этих запросов более не использует
механизм обмена сообщений с сервисом, в результате функция read будет просто
ожидать ответа максимальное время, указаное параметром p_wait. Указание 
времени ожидания для функции read имеет смысл с целью вычитывания других
сообщений (например, событий, отправленных пользователю).

procedure clear_stack; 
- очистить стек блокировок.

procedure push_info;
- поместить информацию из внутреннего буфера в вершину стека блокировок, 
указатель стека увеличивается на 1.

function  pop_info return boolean;
- извлечь информацию из вершины стека блокировок во внутренний буфер, 
указатель стека уменьшается на 1. Возвращает TRUE, если информация извлечена,
иначе FALSE (стек пуст).

function  stack_info(p_idx integer default 0) return boolean;
- извлечь информацию из стека блокировок во внутренний буфер.
  Параметр p_idx означает номер записи в стеке, считая от вершины (если p_idx
не задан, то извлекается информация из вершины стека - 0 запись). Возвращает 
TRUE, если информация извлечена, иначе FALSE (p_idx превышает глубину стека, 
или стек пуст). Текущий указатель стека не изменяется.

function  info(l_info in out locks_info,
               u_info in out users_info ) return boolean;
- извлечь информацию из внутреннего буфера (который заполняется после ответа 
на запросы put_get, put_push, get, get_push, pop_info, stack_info, причем 
функция ответа на эти запросы не ожидает, а возвращает текущую информацию 
непосредственно из буфера), возвращает TRUE, если информация актуальна. При 
этом в u_info заполняются только поля id и sid, остальную информацию о 
пользовательской сессии можно получить функцией init_user.

function  get_lock(p_lock in out locks_info,
                   p_object varchar2) return boolean;
- извлечь информацию о логической блокировке в FRM_LOCKS экземпляра с
ID = p_object. Возвращает TRUE в случае успеха.

function  get_info(p_object  in out string,
                   p_subject in out string,
                   l_info    out string,
                   l_time    out date,
                   l_user    out string,
                   u_ses     out string,
                   os_user   out string,
                   ora_user  out string,
                   username  out string,
                   u_info    out string,
                   p_wait    number default 1
                  ) return boolean;
- извлечь информацию о блокировке c id=p_object типа p_subject, не 
принадлежащую текущей сессии пользователя, т.е. удерживаемую другим 
пользователем (оба параметра in/out, если установлены оба в null, то 
извлекается информация из внутреннего буфера, полученная по put_get, put_push, 
get, get_push, pop_info, stack_info, при этом функция прокручивает циклы 
ожидания ответа на соответствующий запрос, если такой запрос был 
предварительно выполнен).
  p_wait - время (в секундах) ожидания ответа сервиса, начиная с ТЯ 7.3.1.0 
параметр не используется, оставлен для совместимости.
  При значении p_subject = 'FORM', извлекается информация о логической 
блокировке в FRM_LOCKS экземпляра с ID = p_object.
  Если функция вернула true, то информация была извлечена успешно, иначе
возвращает false, и это означает, что блокировки либо не существует, либо она 
принадлежит текущему пользователю. 
  В случае успеха в p_object возвращается ID блокировки-семафора или ID 
экземпляра (в FRM_LOCKS), а в p_subject - ее тип (для семафоров) или CLASS_ID 
экземпляра (в FRM_LOCKS). Также заполняются остальные out-параметры, имеющие 
строковый тип (кроме l_time, который - дата):
  l_info - информация, сопутствующая блокировке, имеет префикс 'FORM: ' для
блокировок в FRM_LOCKS (соответствует полю locks_info.info),
  l_time - момент занесения (соответствует полю locks_info.time),
  l_user - ID сессии пользователя - владельца блокировки (соответствует полю 
locks_info.user_id),
  u_ses  - client_info сессии (соответствует полю users_info.ses_id),
  os_user- имя (сетевое) системного пользователя (соответствует полю 
users_info.os_user),
  ora_user- имя пользователя (соответствует полю users_info.ora_user),
  username- имя компьютера, с которого зашел пользователь (соответствует полю 
users_info.username),
  u_info - модуль (программа), с помощью которой зашел пользователь 
(соответствует полю users_info.info).

function get_user_info(u_info in out users_info,
                       u_idx  integer default null,
                       u_sid  integer default null,
                       p_init boolean default true
                      ) return boolean;
- получить информацию о зарегистрированной сессии пользователя с id равном 
u_idx и sid равном u_sid (если u_idx не задан, то возвращается информация о 
текущей сессии пользователя). 
  При указании непустого значения u_idx задавать значение u_sid не 
обязательно, но желательно, т.к. поиск сессии пользователя при этом 
выполняется существенно быстрее. Параметр p_init определяет режим заполнения 
структуры u_info - если задано значение true (по умолчанию), то структура 
заполняется информацией из списка сессий Oracle, если задано значение false 
(доверительный режим), то информация из списка сессий Oracle не используется,
заполняются только поля id, sid, instance, которые приходят по запросу от 
сервиса контроля зарегистрированных сессий. Возвращает TRUE в случае успеха. 

function get_lock_info(l_info in out locks_info,
                       l_idx  integer default null
                      ) return boolean;
- извлечь информацию о блокировке-семафоре с индексом равным l_idx (если l_idx
не задан, то возвращается информация о блокировке из внутреннего буфера, 
полученная по put_get, put_push, get, get_push, pop_info, stack_info, при этом
функция прокручивает циклы ожидания ответа на соответствующий запрос, если 
такой запрос был предварительно выполнен). Возвращает TRUE в случае успеха.

function get_user_list(p_users  in out users_tbl,
                       ora_user in string default NULL
                      ) return boolean;
- получить список (индексированный массив) зарегистрированных пользовательских
сессий - информация о полученных сессиях дописывается в конец таблицы p_users.
Возвращает TRUE в случае успешного выполнения запроса (т.е. существует хотя бы
одна сессия). 
  Параметры:
  ora_user - задает фильтр на поиск сессий в формате:
    [<node>.]<username>[:<session list>], где
      <username> задает фильтр на имя пользователя oracle (пустое значение
        означает поиск всех пользователей);
      <node> задает номер узла RAC (без единицы), для которого требуется
        получить список сессий (пустое значение означает поиск на других узлах,
        т.е. на всех, кроме собственного; отсутствие указания номера RAC 
        означает поиск на всех доступных узлах RAC, включая собственный);
      <session list> задает список исключений, состоящий из идентификаторов
        зарегистрированных пользовательских сессий, которые следует исключить
        из результирующего списка сессий, возвращаемых функцией (если список 
        исключений задан, т.е. разделитель ':' присутствует, и пуст, тогда в 
        список исключений включается собственная сессия)
    пустое значение параметра означает отсутствие фильтра как на имя 
    пользователя, так и на номер узла RAC (поиск по всем узлам).
  p_init - определяет режим заполнения элементов массива p_users -
    если задано значение true (по умолчанию), то информация заносится из списка
    сессий Oracle, если задано значение false (доверительный режим), то 
    информация из списка сессий Oracle не используется, заполняются только поля
    id, sid, instance, которые приходят по запросу от сервиса контроля ресурсов
    зарегистрированных сессий.

function get_lock_list(p_locks     in out locks_tbl,
                       p_user_id   integer default NULL,
                       p_time      date default NULL,
                       p_subject   string default NULL
                       p_user_sid  integer default NULL
                      ) return boolean;
- получить таблицу-список блокировок для пользователя с заданным id сессии
равным p_user_id (если p_user_id не задан, то возвращается список для текущей 
сессии пользователя) со временем установки блокировки ранее момента p_time 
(если p_time не задан, то условие на время не накладывается) и типом 
блокировки p_subject (если p_subject не задан, то условие на тип блокировки не
накладывается). При указании значения p_subject = 'FORM', извлекается 
информация только о логических блокировках экземпляров из FRM_LOCKS. 
  Если задается непустое значение p_user_id, то желательно также задать
p_user_sid (sid пользовательской сессии), чтобы идентификация сессии 
пользователя выполнялась быстрее.
  Информация дописывается в конец таблицы p_locks. Возвращает TRUE в случае 
успешного выполнения запроса.

function get_lock_list(p_locks     in out locks_tbl,
                       p_user      users_info default NULL,
                       p_time      date default NULL,
                       p_subject   varchar2 default NULL
                      ) return boolean;
- получить таблицу-список блокировок для пользователя c описанием в структуре
p_user (должно быть задано, как минимум, поле id, а также желательно, чтобы 
было заполнено поле sid). Если структура p_user не задана, то возвращается 
список блокировок текущей сессии.
  Параметры p_time и p_subject обрабатываются так же, как и в предыдущей 
функции get_lock_list.
  Возвращает TRUE в случае успешного выполнения запроса.

function  get_user_locks(p_locks     in out nocopy locks_tbl,
                         p_user_id   integer default NULL,
                         p_time      date default NULL
                        ) return boolean;
- получить таблицу-список блокировок экземпляров из FRM_LOCKS для пользователя
с заданным id сессии равным p_user_id (если p_user_id не задан, то 
возвращается список для текущей сессии пользователя) со временем установки 
блокировки ранее момента p_time (если p_time не задан, то условие на время не 
накладывается). 
  Информация дописывается в конец таблицы p_locks. Возвращает TRUE в случае 
успешного выполнения запроса.

procedure  check_obj(p_object string,
                     p_get    boolean default true,
                     p_class  string  default null)
- проверка установленной пользователем логической блокировки с ID = p_object.
  Если задано пустое значение параметра p_class (по умолчанию), то 
осуществляется проверка блокировки-семафора, иначе проверяется логическая 
блокировка в FRM_LOCKS экземпляра c ID = p_object в типе p_class.
  В случае, когда блокировка не была установлена или была установлена другим 
пользователем, возникает исключение RTL.CHECK_OBJECT.
  Параметр p_get указывает, нужно ли делать запрос get на указанную блокировку
(можно установить в false, если предварительно был сделан запрос типа get, 
put_get, put_push, get, get_push).

procedure check_lock(p_object varchar2, 
                     p_class  varchar2);
- проверка установленной пользователем логической блокировки в FRM_LOCKS
экземпляра c ID = p_object в типе p_class.
  В случае, когда блокировка не была установлена или была установлена другим 
пользователем, возникает исключение RTL.CHECK_OBJECT.

function  request(p_object  string,
                  p_info    string default NULL,
                  p_wait    number default NULL,
                  p_class   string  default null
                 ) return string(2000);
- установить логическую блокировку объекта p_object (сопутствующая информация
о блокировке задается в p_info).
  p_wait - время ожидания в секундах ответа на запрос от сервиса, начиная с 
ТЯ 7.3.1.0 параметр не используется, оставлен для совместимости.
  Если задано пустое значение параметра p_class (по умолчанию), то 
осуществляется установка блокировки-семафора типа 'LOCK' (со значением
subject = 'LOCK'), иначе устанавливается логическая блокировка в FRM_LOCKS
экземпляра c ID = p_object в типе p_class.
  Возвращает пусто, если блокировка установлена, или текст с ошибкой 
блокировки, если блокировка установлена не была. Блокировка не 
устанавливается, если она уже установлена другим пользователем, а для 
блокировок в FRM_LOCKS также не устанавливается в случае отсутствия заданного
экземпляра как такового или если экземпляр блокирован физически другой сессией
(т.е. находится на стадии изменения).
  Функция использует стек блокировок, так что при установке подряд массива 
блокировок (как в Навигаторе перед выполнением операции над списком 
экземпляров) ожидание ответа можно поставить лишь в самом последнем запросе - 
ответ будет получен сразу на все предыдущие и текущий запросы одновременно 
(при этом очищается весь стек блокировок).
  Блокировки, установленные по request снимаются при вызове процедуры CLEAR 
только с параметром true.
  Существует возможность установки логических блокировок списком. Для этого в 
параметре p_object нужно задать этот список в специальном формате - 
перечислением значений ID блокировок с разделителем-запятой (например, в 
p_object передать строку '1234,5678,91011,1213,1415,1617,1819'). При указании 
списка ID в p_object функция может вернуть строку длиной до 10000 символов.

function  request_lock(p_object  varchar2,
                       p_class   varchar2,
                       p_info    varchar2 default NULL
                      ) return varchar2(2000);
- установить логическую блокировку в FRM_LOCKS экземпляра с ID = p_object в 
типе p_class (сопутствующая информация о блокировке задается в p_info).
  Возвращает пусто, если блокировка установлена, или текст с ошибкой 
блокировки, если блокировка установлена не была. Блокировка не 
устанавливается, если она уже установлена другим пользователем, в случае 
отсутствия заданного экземпляра как такового или если экземпляр блокирован 
физически другой сессией (т.е. находится на стадии изменения).
  Существует возможность установки логических блокировок списком. Для этого в 
параметре p_object нужно задать этот список в специальном формате - 
перечислением значений ID блокировок с разделителем-запятой (например, в 
p_object передать строку '1234,5678,91011,1213,1415,1617,1819'). При указании 
списка ID в p_object функция может вернуть строку длиной до 10000 символов.

function  object_scn(p_object  varchar2,
                     p_class   varchar2
                    ) return number;
- получить текущее значение версии (SCN) экземпляра с ID = p_object в типе 
p_class. Возвращает числовое значение больше нуля в случае успеха, либо 
исключение по ошибке поиска экземпляра в заданном типе.

procedure refresh(p_instance integer default null, 
                  p_node     integer default null);
- обновление информации о зарегистрированных сессиях (полезна для обновления
списка пользовательских сессий, которые были фатально завершены). 
  Параметры p_instance, p_node поддерживаются для совместимости с предыдущими 
версиями ТЯ, в ТЯ 7.3.1.0 и выше значения параметров игнорируются.
  Если задание LOCK_REFRESH не запущено, то процедура ничего не делает.

function fill_ids(p_list varchar2, 
                  p_frm  boolean default false
                 ) return boolean;
- установка списка блокировок для запроса информации списком для процедур put,
put_get, put_push, get, get_push, del. 
  Список задается параметром p_object в специальном формате - перечислением 
значений ID блокировок с разделителем - запятой (например, в p_object указать 
строку '1234,5678,91011,1213,1415,1617,1819'). Возвращает true, если список 
был успешно разобран.
  После успешного выполнения функции можно вызвать одну из процедур работы с 
блокировками - put, put_get, put_push, get, get_push, del со значением 
параметра p_object = NULL, тогда эти процедуры обработают ВЕСЬ список, 
предварительно заполненный функцией fill_ids.
  Параметр p_frm задает тип блокировок, при значении false (по умолчанию) 
задаются блокировки-семафоры, при значении true - блокировки в FRM_LOCKS 
(список блокировок в FRM_LOCKS можно задавать только для последующего вызова 
процедур get, get_push, del, для процедур put... это не сработает).

ПРИМЕЧАНИЕ:
 Процедуры для запросов и проверок логических блокировок экземпляров в 
FRM_LOCKS (request_lock, check_lock, object_scn) выполняют динамические 
запросы к интерфейсным пакетам типов, поэтому их использовать напрямую не 
рекомендуется, для этого следует пользоваться модификаторами %request, %check,
%scn языка PL/Plus.


            3. Применение.

    Последовательность работы пользователя в системе (по использованию функций
пакета lock_info):
1. Регистрация - lock_info.open (это делает Навигатор при входе).
2. Загрузка формы операции:
  а) При первоначальной загрузке формы операции происходит вызов 
    умолчательного валидатора операции. Если операция относится к тем типам, 
    которые работают с экземплярами (простые, конструкторы, деструкторы) и 
    имеет свойство "Проверка изменения экземпляра", то перед вызовом 
    умолчательного валидатора происходит установка логической блокировки в 
    FRM_LOCKS для экземпляра, над которым операция запускается. При этом 
    физической блокировки экземпляра не происходит, а лишь сохраняется его 
    текущая версия (system change number - SCN), которая впоследствии 
    проверяется вызовами других валидаторов или исполняемого тела операции. 
    Таким образом, запуск формы лишь заявляет намерение об изменении 
    экземпляра, фактически этого не делая. Если оказывается, что подобная 
    логическая блокировка уже установлена другим пользователем (формой 
    операции в другой сессии), т.е. подобное же намерение об изменении 
    экземпляра заявлено кем-то другим, то загрузка формы прекращается и 
    выдается соответствующее сообщение о невозможности работы с экземпляром, 
    т.к. с ним уже работают другие.
  б) При последующих вызовах валидаторов вводимых значений контролов и 
    исполняемого тела операции, перед этими вызовами производится проверка 
    существования поставленной ранее (умолчательным валидатором) логической 
    блокировки. Проверяется принадлежность блокировки текущей сессии, а также 
    соответствие текущего значения SCN экземпляра тому SCN, который был 
    определен на этапе установки блокировки. Если эти условия не выполняются, 
    то это означает, что блокировка была перехвачена на физическом уровне и 
    экземпляр был модифицирован (системой реализован функционал по 
    автоматическому изменению значения SCN экземпляра при ЛЮБОЙ его 
    модификации см ч.9). 
  Это и есть основной принцип оптимистично-пессимистичной схемы блокирования: 
  - пока операция фактически не выполняется, а лишь происходит загрузка 
    исходных данных пользователем (через форму операции) в интерактивном 
    режиме (который не может быть быстрым в принципе), то физической 
    блокировки экземпляра не происходит, операция "оптимистично" надеется, что
    экземпляр не будет модифицироваться другими (тем не менее, не запрещая 
    такую возможность);
  - при запуске же операции на выполнение, происходит физическая блокировка 
    экземпляра и связанных с его модификацией данных на уровне БД (с помощью 
    модификатора %lock или блокирующих курсоров), тем самым обеспечивается 
    "пессимистичный" вариант блокировки, т.е. ресурсы захватываются в 
    единоличное пользование выполняемой операции, не давая шансов более никому
    на изменение блокированных объектов (фактически используется принцип - раз
    уж позволено выполнение операции, когда пройдены все препоны логических 
    блокировок, то уже само это выполнение может делать все, что предписано, 
    без всяких препятствий). При этом логические блокировки, даже 
    установленные другими сессиями, физической блокировке не помеха, конфликт 
    может быть только на уровне физических блокировок БД, очередность которых 
    сама БД и разрешает. Этот принцип, естественно, отражает и должен 
    следовать основному правилу OLTP систем: можно блокировать и изменять все
    необходимые данные, однако делать это нужно быстро и не держать подолгу 
    блокированные ресурсы, чтобы могли работать другие операции.
  Таким образом схема блокирования при работе операций имеет два уровня:
  - логический оптимистический на уровне логических блокировок в FRM_LOCKS, 
    осуществляемый формами операций;
  - физический пессимистический на уровне блокировок БД, поддерживаемый самой 
    БД и имеющий более высокий приоритет, чем логические блокировки.
3. Выполнение операции (работа с функциями пакета lock_info и блокировками):
  a) Перед изменением экземпляра производится его физическая блокировка, 
    например, модификатором %lock. При невозможности блокировки экземпляра
    вызывается функция get для того же экземпляра и с p_subject = 'V$LOCK', 
    чтобы послать запрос сервису поддержки физических блокировок пользователей
    на поиск владельца физической блокировки (см.ч.10), после исчерпания всех 
    попыток блокировки (настройки см.ч.7) инициируется исключение 
    rtl.CANNOT_LOCK. Поэтому в обработчике исключения rtl.CANNOT_LOCK при 
    считывании информации по get_info или read, во внутренний буфер попадает 
    информация о запросе на блокировку экземпляра, которую реализовать не 
    удалось и по которой возникло исключение. Это происходит, например, в 
    Навигаторе, если исключение выходит на клиента, это же можно делать и 
    программно в пользовательских обработчиках исключения CANNOT_LOCK, и, 
    соответственно, реагировать на ситуацию, при этом информацию можно 
    заносить в стек блокировок и реагировать на них позже.
  б) При блокировке выборки (или курсора) в PL/PLUS вызывается процедура
    lock_info.put_get (устанавливается блокировка-семафор с некоторым 
    синтетическим ID, зависящим от операции и позиции курсора в ней). При 
    невозможности блокировки инициируется исключение rtl.CANNOT_LOCK. Поэтому 
    в обработчике исключения rtl.CANNOT_LOCK при считывании информации по 
    get_info или read, во внутренний буфер попадает информация о запросе на 
    блокировку выборки, которую реализовать не удалось. 
  в) Указанные механизмы можно использовать и для реализации блокировок других
    типов, например, при работе с файлами. При открытии файла можно запросить 
    блокировку-семафор функцией lock_info.request с ожиданием ответа. Если 
    функция вернула не пустой текст (описывающий причину невозможности 
    установки блокировки), то это означет, что файл захвачен другим 
    пользователем и можно выдать сообщение об ошибке или попытаться открыть 
    другой файл, иначе файл никем не захвачен и с ним можно работать. По 
    окончании работы сбросить блокировку можно процедурой lock_info.del.
  Пример:
    declare
        l integer;
        f integer;
        b boolean;
        s string(200);
        self  lock_info.users_info;
    begin
        b := lock_info.get_user_info(self); -- получить информацию о себе
        -- ID блокировки-семафора
        l := -utils.hash_value('/oradb1/utlfile/test.txt'); 
        -- запрос на блокировку c ожиданием
        s := lock_info.request(l,'/oradb1/utlfile/test.txt',1); 
        if s is not null then -- установить блокировку не удалось
          pragma error(s);  -- тогда ошибка
        end if;
        f := stdio.open('/oradb1/utlfile','test.txt','w'); -- все в порядке
        ...
        stdio.close(f);
        lock_info.del(l);    -- снимаем блокировку
    end;
4. Завершение работы операции - выгрузка формы операции. Если закрываемая 
  форма - верхнеуровневая (т.е. она не является порожденной вызовом формы 
  другой операции), тогда производится полная очистка блокировок с помощью 
  вызова lock_info.clear с параметром true (это делает Навигатор по завершении
  операции).
5. Закрытие сеанса lock_info.close (это делает Навигатор при выходе).


            4. Описание дополнительных (служебных) функций пакета.

procedure run;
- запуск  (загрузка) основного сервиса LOCK_INFO.

procedure stop(p_instance integer default null,
               p_node     integer default null,
               p_mode     integer default null);
- остановка (выгрузка) сервисов, установка отладки.
  Параметр p_instance определяет тип сервиса: 
    >= 0 - передаёт команду основному сервису; 
    < -1 - передает команду дополнительному сервису физических блокировок 
           (см.ч.10);
    -1 или null - передает команду как основному сервису, так и 
           дополнительному.
  Параметр p_node задает номер узла кластера RAC (считая от 0 до полного
количества узлов кластера без единицы). Если параметр не задается, то 
используется текущее значение сессии пользователя (см. также атрибуты 
системного контекста - plphints.txt п.4.2).
  Процедура делает commit при удалении процесса из DBA_JOBS (если p_mode не 
задан).
  Параметр p_mode задаёт специальные режимы работы дополнительного сервиса 
поддержки физических блокировок:
если p_mode > 0, тогда задается уровень отладки сервиса поддержки физических
блокировок значением p_mode-1;
если p_mode = 0, тогда происходит перезапуск сервиса физических блокировок;
если -100 <= p_mode < 0, тогда производится запуск обработчиков сервиса 
физических блокировок на узле кластера RAC с номером -p_mode;
если p_mode < -100, тогда производится остановка обработчиков сервиса 
физических блокировок на узле кластера RAC с номером -p_mode-100.
  Остановка основного сервиса (контроля ресурсов зарегистрированных сессий)
выполняется только в случае, если параметр p_mode принимает значение null.

function  open(p_name    string default NULL,
               p_info    string default NULL,
               p_user_id integer default NULL
              ) return integer; 
- зарегистрировать сессию пользователя с id=p_user_id (если p_user_id не 
задан, то регистрируется текущая сессия пользователя,вызывающая эту функцию).

procedure close(p_user_id integer default NULL);
- удалить сессию пользователя p_user_id из списка зарегистрированных (если 
p_user_id не задан, то удаляется текущая сессия пользователя).

procedure clear(p_all     boolean default FALSE,
                p_user_id integer default NULL);
- очистить блокировки сессии пользователя p_user_id (если p_user_id не задан, 
то очищаются блокировки текущей сессии пользователя).

function  clear_locks(p_object  varchar2,
                      p_user_id pls_integer default null,
                      p_nowait  boolean default false
                     ) return pls_integer;
- очистить блокировки в FRM_LOCKS сессии пользователя p_user_id (если 
p_user_id не задан, то очищаются блокировки текущей сессии пользователя). 
  Пустое значение p_object очищает все блокировки заданного пользователя, 
непустое значение - удаляет только блокировки с заданным ID = p_object.
  Параметр p_nowait задает режим удаления со ждущей (false - по умолчанию) или
не ждущей (true - в этом случае в конкурентной среде может возникнуть 
исключение RTL.RESOURCE_BUSY и блокировки могут не удалиться).


procedure put(p_object  string,
              p_subject string default NULL,
              p_info    string default NULL,
              p_user_id integer default NULL);
- поместить информацию о блокировке для сессии пользователя p_user_id (если 
p_user_id не задан, то для текущей сессии пользователя).

function submit_job(p_submit in out  boolean) return string;
- функция, возвращающая строку состояния основного сервиса контроля ресурсов 
зарегистрированных сессий.
  При указании для параметра p_submit на входе значения true, если сервис на 
момент вызова не был запущен, он будет поставлен в очередь заданий (в 
DBA_JOBS). В p_submit возвращается true, если сервис находится в очереди 
заданий (или был туда помещен), false, если сервиса нет в очереди заданий. 
Функция осуществляет постановку заданий в очередь в автономной транзакции 
(если на входе p_submit был установлен в true).

function hold(p_hold     boolean,
              p_instance integer default null,
              p_node     integer default null ) return string;
- заблокировать (p_hold = true) или разблокировать (p_hold = false) сервисы 
пакета lock_info. Если сервис заблокирован, то он запускаться не будет до тех 
пор, пока не будет разблокирован этой же функцией.
  Параметр p_instance задает тип сервиса:
    >= 0 - передает команду основному сервису контроля зарегистрированных 
           сессий;
    <-1 -  передает команду дополнительному сервису физических блокировок 
          (см. ч.10);
    -1  -  передает команду как основному сервису, так и дополнительному.
  Если параметр не задается, то используются значение -1.
  Параметр p_node задает номер узла кластера RAC (считая от 0 до полного
количества узлов кластера без единицы). Если параметр не задается, то 
используется текущее значение сессии пользователя.
  Эта функция используется при изменении элементов системного ядра, от которых
зависят сервисы пакета lock_info, а без их остановки эти изменения делать 
невозможно. Функцию также можно использовать как административное средство 
временного запрещения работы с системой.
  Функция возвращает строку с информацией о произведенном действии. Делает 
commit при удалении процесса из DBA_JOBS.

procedure touch(p_user_id pls_integer default null);
- послать информацию сервису контроля зарегистрированных сессий о "живости" 
заданной в p_user_id сессии пользователя (если p_user_id не задан, то 
используется текущая сессия). Процесс LOCK_INFO (в ТЯ 7.3.1.1 и выше - задание
LOCK_REFRESH) периодически (с периодом LOCK_TIMEOUT - см. ч.8) удаляет 
"неживые" сессии, которые не подтверждают свое существование. Специально 
вызывать эту процедуру не нужно, т.к. это делается автоматически Навигатором с
интервалом MESSAGE_PERIOD (см. ч.8). В случае отключения использования 
LOCK_TIMEOUT процедура ничего не делает.

procedure set_ids(p_id   type_number_table, 
                  p_frm  boolean default false);
procedure set_ids(p_id   type_refstring_table, 
                  p_frm  boolean default false);
procedure set_ids(p_id   rtl.refstring_table, 
                  p_frm  boolean default false);
- установка списка блокировок для запроса информации списком для процедур put,
put_get, put_push, get, get_push, del. Список задается параметром-массивом
p_id (процедуры перекрыты по разному типу этих массивов). После выполнения 
set_ids можно вызвать одну из процедур работы с блокировками - put, put_get, 
put_push, get, get_push, del со значением параметра p_object = NULL, тогда эти
процедуры обработают ВЕСЬ список, предварительно заданный процедурами set_ids.
  Параметр p_frm задает тип блокировок, при значении false (по умолчанию)
задаются блокировки-семафоры, при значении true - блокировки в FRM_LOCKS 
(список блокировок в FRM_LOCKS можно задавать только для последующего вызова 
процедур get, get_push, del, для процедур put... это не сработает).

procedure get_v$lock(p_id1  in out nocopy pls_integer, 
                     p_id2  in out nocopy pls_integer,
                     p_sid  pls_integer, 
                     p_typ  varchar2 default null, 
                     p_req  boolean default null);
- процедура поиска блокировки по v$lock для сессии с заданным sid 
(v$session.sid) в p_sid, с заданным типом блокировки в p_typ (null или 'TX' -
транзакция, 'TM' - таблица и т.д.) и p_req (при значении true или null - поиск
ждущей блокировки c v$lock.request>0, иначе поиск удерживаемой блокировки с 
v$lock.ltime>0). При успешном выполнении процедура возвращает информацию о 
блокировке v$lock.id1 и v$lock.id2 в параметрах p_id1 и p_id2, соответственно,
если возвращаемые значения оба равны нулю, то это означает, что информация о 
блокировке не найдена.

function  get_v$lock_user(p_user in out nocopy users_info,
                          p_id1  pls_integer, p_id2 pls_integer,
                          p_typ  varchar2 default null) return pls_integer;
- функция поиска пользовательской сессии, которой принадлежит заданная 
блокировка с идентификаторами p_id1 и p_id2 и типом p_typ (null 
интерпретируется как 'TX', т.е. транзакция). При успешном поиске функция 
возвращает время существования блокировки в секундах (v$lock.ctime) и 
информацию о сессии в p_user, которой принадлежит блокировка, иначе возвращает 
пустые значения.

ПРИМЕЧАНИЕ.
1. Процедуры и функции данного раздела - служебные и могут использоваться 
  только для каких-то специальных целей администрирования работы системы. В 
  операциях их использовать не рекомендуется (по умолчанию они и не доступны).
2. Фактическая реализация сервисов LOCK_INFO находится в пакете RTL, пакет 
  LOCK_INFO представляет собой просто выделенный интерфейс к этой реализации.


            5. Запуск и остановка.

  Сервисы пакета lock_info запускаются и останавливаются автоматически через
механизм очереди заданий ORACLE.
  Для активации основного сервиса контроля ресурсов зарегистрированных сессий 
в отдельной пользовательской сессии можно запустить процедуру lock_info.run 
из-под пользователя-владельца. При этом будет запущены задание LOCK_REFRESH, 
отвечающее за обновление списка пользовательских сессий, и задания
EVENT_SERVICE, обеспечивающие рассылку сообщений между узлами кластера. 
Задание LOCK_REFRESH запускается одно на одном из узлов кластера, задания 
EVENT_SERVICE запускаются по одному на каждом узле кластера.
  Завершает работу процедура lock_info.stop. Ее следует запустить из-под 
владельца.
  Управление сервисом возможно также и не из-под владельца, а из-под 
пользователя системы доступа через пакет executor, который таким пользователям
доступен (в нем продублированы основные функции lock_info, в т.ч. есть и 
lock_stop, lock_hold, lock_run).

  До ТЯ 7.3.2.0 запуск основного процесса производился автоматически путем 
постановки задания в очередь заданий Oracle при первой регистрации любой 
пользовательской сессии. Начиная с ТЯ 7.3.2.0 такого автоматического запуска
не происходит, т.е. задания LOCK_REFRESH и EVENT_SERVICE могут быть и не 
запущены до тех пор, пока в них не возникнет необходимости. 
  Автоматический запуск задания LOCK_REFRESH произойдет в случае, если при 
открытии пользовательской сессии возникнет превышение ограничения
SESSIONS_PER_USER или MAX_SESSIONS. Задание EVENT_SERVICE запускается 
автоматически, если отправляется событие на другой узел кластера (в этом 
случае задание будет запущено на том узле, куда отправляется событие).
  Ситуация, когда какое-либо из заданий сервиса не запущено, является штатной
(например, такое может произойти при плановом выключении узла, на котором
работал сервис в рабочее время) и обычно не требует специального перезапуска
сервиса. Однако при незапущенном процессе LOCK_REFRESH не будет происходить 
автоматическое удаление фатально завершившихся сессий (см. ч.8, настройка
LOCK_TIMEOUT), поэтому рекомендуется для всех пользователей задавать в профиле
ограничение SESSIONS_PER_USER. При необходимости процесс можно запустить 
принудительно с помощью вызова процедуры lock_info.run или через системный ТБП
"Выполнение заданий по расписанию" с помощью операции "Запуск процесса 
поддержки блокировок" (SYSTEM_JOBS.LOCK_INFO_RUN).

    Запуск дополнительного процесса поддержки физических блокировок реализован
путем выполнения системного задания через механизм ТБП "Выполнение заданий по 
расписанию" (SYSTEM_JOBS) версии 7.3. Операция по выполнению процесса 
SYSTEM_JOBS.LOCK_INFO_RUN ставится в очередь операцией "Запуск системных 
заданий" (SYSTEM_JOBS.SUBMIT_SYS_JOBS) и удаляется из очереди операцией 
"Останов системных заданий" (SYSTEM_JOBS.STOP_SYS_JOBS).


            6. Типы блокировок и их использование.

    Различаются следующие типы блокировок:
1. Физические блокировки записей БД, которые устанавливаются модификатором 
  %lock или выборкой данных с блокировкой (FOR/LOCATE/SELECT c опцией LOCK) 
  или операторами модификации данных (INSERT/UPDATE/DELETE). Эти блокировки 
  инициируют физические транзакции в БД и имеют наивысший приоритет, их 
  очередизация и обработка производится средствами БД. Сервис физических 
  блокировок может взаимодействовать с ними только на уровне опроса состояния,
  препятствовать он им не может.
2. Логические блокировки экземпляров ТБП для работы форм операций, которые 
  сохраняются в словаре FRM_LOCKS. Порядок их использования и взаимодействия 
  с физическими блокировками типа 1 описан в ч.3 п.2. Для запросов и проверки
  состояния таких блокировок (т.е. для работы операций на "оптимистическом" 
  уровне форм операций) в языке PL/Plus предусмотрены модификаторы %request,
  %check, %scn (см. plplus.doc, plplus.txt).
3. Логические блокировки-семафоры информационной модели. Начиная с ТЯ 7.3 
  такие блокировки обрабатываются не сервисом LOCK_INFO, как раньше, а 
  сохраняются в RTL_LOCKS и обрабатываются самим клиентским процессом. Эти 
  блокировки разделяются также на несколько подтипов, в зависимости от 
  диапазонов их индекса (см. ч.1) и свойства subject:
    а) простые, диапазонов 2-3 и subject <> 'LOCK'
    b) логические, диапазонов 2-3 и subject = 'LOCK'
    с) пользовательские, диапазона 4.

  Физические блокировки (тип 1) устанавливаются при выполнении операций, 
модифицирующих данные. Снимаются они стандартными командами управления 
транзакциями commit/rollback.
  Логические блокировки (тип 2) устанавливаются и снимаются интерфейсными 
пакетами форм операций. Программно устанавливаются модификатором %request, 
снимаются процедурой CLEAR с параметром true.
  Логические блокировки-семафоры устанавливаются программно интерфейсными
средствами пакета lock_info (put, put_get, put_push, request). Снимаются
процедурами CLEAR и DEL. Причем блокировки типа 3a снимаются любым вызовом 
CLEAR, блокировки типа 3b - только с параметром TRUE, блокировки типа 3c - 
только процедурой DEL.
  При выполнении операций в Навигаторе - по завершении выполнения вызова любой
секции операции осуществляется commit в случае успешного завершения и rollback
в случае возникновения исключения. Таким образом, любой вызов любой секции 
операции рассматривается как атомарная транзакция, которая всегда завершается
и сбрасывает ВСЕ физические блокировки. Одновременно с фиксацией физической
транзакции выполняется также процедура CLEAR с параметром false.
  Между вызовами разных секций (валидаторов или тела операции) Навигатором 
ведется "логическая" транзакция, про которую БД фактически ничего не знает,
взаимодействие этих логических транзакций осуществляется через интерфейсные
пакеты операций и логические блокировки типа 2, как описано в ч.3. Логическая 
транзакция завершается Навигатором вызовом процедуры CLEAR с параметром true 
по закрытии верхнеуровневой формы операции (т.е. когда она не является 
порожденной вызовом формы другой операции).
  Блокировки-семафоры типа 3 могут произвольно использоваться в операциях, 
непосредственной связи с блокировками типов 1 и 2 они не имеют, если только 
эта связь не заложена программно. При их использовании нужно иметь в виду, что
блокировки типа 3a живут на протяжении атомарных вызовов (как и физические 
блокировки), блокировки типа 3b живут на протяжении логической транзакции форм
операций, блокировки типа 3c живут до тех пор, пока программно не будут сняты
(процедурой DEL).

  В прежних версиях ТЯ (до введения нового типа блокировок 2) логические 
транзакции при работе форм операций производились посредством 
блокировок-семафоров типов 3a и 3b. Логическая транзакция начиналась вызовом
умолчательного валидатора и установкой семафора с object = ID экземпляра и 
subject = 'LOCK' (типа 3b - функцией request), над которым запускалась 
операция. Последующие атомарные вызовы операции контролировали существование
поставленной блокировки (процедурой check_obj). Завершение работы операции 
(логической транзакции) сопровождалось вызовом CLEAR(TRUE). Атомарные вызовы 
при выполнении физической блокировки (модификатором %lock) устанавливали 
безусловный семафор на object = ID блокируемого экземпляра и 
subject = 'OBJECT' (типа 3a), не ждущим запросом (процедурой put), чтобы, 
во-первых, не задерживать выполнение операции, а, во-вторых, перекрыть 
возможно уже существующие семафоры на блокируемые экземпляры, установленные
другими пользователями. Такая схема логически совпадала с новой реализацией
(описанной в ч.3), однако имелись следующие недостатки:
  - вся обработка осуществлялась централизованно единственным   сервисом - 
    процессом LOCK_INFO, что при большой общей загрузке сервера БД могло 
    приводить к задержкам при выполнении запросов на установку-проверку 
    блокировок-семафоров;
  - процессу LOCK_INFO нужно было отслеживать списки блокировок-семафоров,
    как соответствующих физическим блокировкам (тип 3a), так и логическим 
    транзакциям форм операций (тип 3b), причем первый список мог быть 
    значительно более широким, чем второй список, т.к. логические транзакции
    выполнения операций могли включать блокировку и изменения большого числа 
    экземпляров;
  - фактически изменение экземпляров отслеживалось опосредованно (т.е. только
    при выполнении %lock), изменения, сделанные другими средствами, могли не
    отслеживаться.                                         
  Новая схема логических блокировок экземпляров избавлена от этих недостатков,
т.к. отпала необходимость в ведении списка блокировок, заблокированных 
физически, а также отслеживание логических блокировок производится самими 
пользовательскими сессиями (а не сервисами lock_info), при этом проверка 
изменений экземпляров основана на контроле версий (SCN) экземпляров, которые 
изменяются любыми операторами внесения изменений в БД, т.е. такая проверка 
стала более жесткой и четкой. Однако следует отметить, что новый механизм 
более жестко завязан на существующие данные в БД, т.к. блокировки могут 
устанавливаться только на реально существующие в БД экземпляры, тогда как 
старый механизм позволял использовать фиктивные (не существующие) ID 
экземпляров.
  Таким образом, в новой схеме список блокировок-семафоров, соответствующих 
физическим блокировкам, полностью упразднен, список блокировок форм вынесен из
сервисов lock_info и хранится в отдельном словаре-таблице FRM_LOCKS, так что 
пользовательские сессии могут работать с этим списком напрямую, минуя сервисы
lock_info, в результате нагрузка на сервисы lock_info существенно уменьшилась,
что высвободило больше ресурсов на пользовательские запросы.
  Механизмы и функции прежней схемы логических блокировок все остались в 
полном объеме (только они перестали использоваться в работе форм операций), и
их вполне можно использовать программно в самих операциях для выстраивания 
каких-то связанных между собой действий в логическую цепочку наподобие того, 
как это описано выше, или выстраивать какие-то собственные схемы 
взаимодействия.

ПРИМЕЧАНИЕ.
1. Следует отметить, что установка-проверка логических блокировок при работе в
  форме операции (т.е. выполнение логической транзакции) происходит только в 
  том случае, если операция имеет признак "Проверка изменения экземпляра". 
  Если этот признак не выставлен, то над одним экземпляром может быть запущена
  не одна операция (точнее, форма операции) и не одним пользователем. Такой 
  режим можно использовать для операций просмотра, т.е. которые не производят
  изменений.
2. В связи с упразднением списка блокировок-семафоров, соответствующих 
  физическим блокировкам, сервис по поиску владельцев физических блокировок
  реализован по новому алгоритму (см.ч.10), который опционально может быть
  отключен, в этом случае поиск владельцев осуществляется по списку блокировок
  форм (FRM_LOCKS), который, строго говоря, может не соответствовать 
  фактическим физическим блокировкам.


            7. Настройки физических блокировок.

LOCK_RETRY
    Количество попыток физической блокировки экземпляра процедурами физической
    блокировки (%lock, rtl.lock_object). Количество попыток не может превышать
    50. Если не задано, то по умолчанию равно 5.
LOCK_DELAY
    Задержка попыток блокировки экземпляров (в сек., минимальная точность - 
    0.1 сек), если количество попыток задано больше 1, то задержка задает 
    время засыпания сессии между попытками. Общее время ожидания, таким 
    образом, может достигать значения LOCK_DELAY*LOCK_RETRY. Если задано 
    значение 0, то независимо от значения LOCK_RETRY будет только одна попытка
    блокировки. Задержка не может превышать 10 сек. Если не задана, то 
    по умолчанию равна 1 сек.
RETRY_PIPE_SIZE
    Размер pipe для вывода информации о попытках блокировки (байты). Если 
    задано значение, большее 100, то инициализируется отладочная пайпа с 
    указанным размером и именем LOCKS$<IBSO owner>$RETRY, в которую 
    записывается информация о неудачных попытках блокировки экземпляров. Если 
    не задан, то отладочная пайпа не используется.
LOCK_NOWAIT
    Признак использования только неждущих (NOWAIT) блокировок при физической
    блокировке экземпляров (%lock) при значениях YES или 1. Другие значения, 
    равно как и отсутствие настройки, используют ждущую блокировку с 
    тайм-аутом 1 сек, общее время ожидания определяется выражением 
    LOCK_DELAY*LOCK_RETRY (см. также ч.10).
LOCK_SKIP_WAIT
    Признак отключения использования функции поиска информации о физической
    блокировке экземпляра (%lock) при значениях YES или 1. Другие значения, 
    равно как и отсутствие настройки, используют функцию поиска в случае, 
    если используются циклы ждущих блокировок при попытках блокировок 
    (настройки LOCK_DELAY, LOCK_RETRY, LOCK_NOWAIT, см. также ч.10).

  Алгоритмы выполнения попыток блокировки экземпляра принципиально различны 
для режимов, определяемых настройкой LOCK_NOWAIT:
  а) ждущий режим (по умолчанию):
    - вычисляется полное время ожидания по формуле LOCK_DELAY*LOCK_RETRY;
    - выполняются по циклу следующие действия:
      - на первом проходе выполняется неждущая блокировка экземпляра 
        посредством "select ... for update nowait";
      - на последующих проходах выполняется ждущая в течение 1 секунды
        блокировка экземпляра посредством "select ... for update wait 1";
      - если блокировка удачна, то цикл завершается;
      - счетчик времени выполнения увеличивается на 1, если значение счетчика
        превысит вычисленное ранее полное время, то цикл завершается;
      - на первом проходе выполняется запрос сервису на получение информации 
        о физической транзакции, блокирующей экземпляр;
      - цикл продолжается;
    - по завершении цикла при неудачной блокировке инициируется исключение 
      RTL.CANNOT_LOCK.
  b) неждущий режим:
    - выполняются по циклу следующие действия:
      - неждущая блокировка экземпляра посредством 
        "select ... for update nowait";
      - если блокировка удачна, то цикл завершается;
      - счетчик попыток увеличивается на 1, если значение счетчика превысит
       значение настройки LOCK_RETRY, то цикл завершается;                  
      - выполнение засыпает на заданное настройкой LOCK_DELAY время;
      - цикл продолжается;
    - по завершении цикла при неудачной блокировке выполняется запрос на поиск
      блокировки по списку блокировок форм (FRM_LOCKS) и инициируется 
      исключение RTL.CANNOT_LOCK.


            8. Настройки сервиса LOCK_INFO.

LOCK_ACTIVE
    Ограничение количества одновременно выполняющихся критических операций.
    Операциям может быть выставлен признак критичности, соответственно, запуск
    на выполнение таких операций контролируется этой настройкой. Если задано
    значение 0, то контроль отключается. 
    Если не задано, то по умолчанию контроль отключен.
LOCK_DEBUG_SIZE
    Размер pipe для вывода отладочной информации сервиса контроля 
    зарегистрированных сессий (байты). Если задано значение большее 100, то 
    инициализируется отладочная пайпа с указанным размером и именем 
    LOCKS$<IBSO owner>$DEBUG, в которую, в частности, пишется информация о 
    перехвате блокировок от одной сессии к другой. Для включения отладки 
    перезапуск сервиса не требуется.
    Если параметр не задан, то отладочная пайпа не используется.
LOCK_TIMEOUT
    Максимально допустимый период (в сек.) неактивности сессии пользователя,
    по истечении которого сессия удаляется. Если задано значение 0 или меньше,
    то активность пользовательских сессий этой настройкой не контролируется,
    если задано значение больше нуля, тогда оно должно превышать значение 
    настройки MESSAGE_PERIOD (см. ниже). 
    Если период не задан, то по умолчанию принимается значение 300 сек.
    Параметр действует только на 3L-подключения Навигатора.
MESSAGE_PERIOD
    Интервал запуска проверки внешних сообщений в секундах. Навигатор с
    указанной периодичностью производит вычитывание внешних сообщений и 
    событий при не активности пользователя, при этом 3L-подключения
    пролонгируют время своей жизни на очередной период LOCK_TIMEOUT (см.выше).
    Если интервал не задан, то по умолчанию используется значение 60 сек.
LOCK_EVENT_TIMEOUT
    Период (в сек.) запуска задания рассылки сообщений, используется для 
    передачи событий между узлами кластера.


            9. Технические подробности реализации блокировок FRM_LOCKS.

  Для хранения информации о логических блокировках экземпляров в структуру ТЯ
добавлена таблица FRM_LOCKS со следующими смысловыми полями:
  OBJ_ID    VARCHAR2(128) - ID экземпляра,
  CLASS_ID  VARCHAR2(16)  - тип экземпляра,
  USER_ID   NUMBER        - ID (AUDSID) сессии пользователя - владельца 
                            блокировки,
  USER_SID  NUMBER        - SID сессии пользователя - владельца блокировки,
  OBJ_SCN   NUMBER        - версия экземпляра (SYSTEM CHANGE NUMBER - SCN),
  TIME      DATE          - время установки блокировки,
  INFO      VARCHAR2(256) - дополнительная (пользовательская) информация о 
                            блокировке,
  EINFO     VARCHAR2(512) - заполняется информацией об идентификаторах 
                            пользовательских сессий, внесших последние 
                            изменения в таблицы типов.

  Новые блокировки форм операций (FRM_LOCKS) реализованы как отдельный 
функционал, не пересекающийся с уже существующими типами блокировок, 
информация о них в интерфейсах существующих функций и процедур заполняется в 
типах LOCKS_INFO и LOCKS_TBL.
  Соответствие полей нового словаря логических блокировок FRM_LOCKS и 
структуры LOCKS_INFO следующее:
    FRM_LOCKS.OBJ_ID     - LOCKS_INFO.OBJECT
    FRM_LOCKS.CLASS_ID   - LOCKS_INFO.SUBJECT
    FRM_LOCKS.USER_ID    - LOCKS_INFO.USER_ID
    FRM_LOCKS.USER_SID   - LOCKS_INFO.USER_SID
    FRM_LOCKS.OBJ_SCN    - LOCKS_INFO.ID
    FRM_LOCKS.TIME       - LOCKS_INFO.TIME
    FRM_LOCKS.INFO       - LOCKS_INFO.INFO (в поле info добавляется префикс 
                           'FORM: ' - для отличия от блокировок-семафоров).
    FRM_LOCKS.EINFO      - LOCKS_INFO.EINFO (для блокировок-семафоров не 
                           заполняется).

  Для отслеживания изменений экземпляров в таблицах типов используется так 
называемый SCN (SYSTEM CHANGE NUMBER), который реализован следующим образом:
- во все таблицы типов добавляется числовая колонка SN, значение которой
  инкрементируется при любом изменении записи таблицы. SCN экземпляра 
  вычисляется как сумма всех значений колонки SN по своей таблице и всем
  родительским для данного ID экземпляра;
- во все таблицы типов добавляется числовая колонка SU, в которую заносится
  идентификатор пользовательской сессии, внесшей изменения в таблицу типа. При
  установке-проверке блокировок в поле FRM_LOCKS.EINFO заносится информация о
  владельцах изменений из собственной таблицы и всех родительских (если 
  таковые имеются, то заносится список сессий через запятую).

  Алгоритм работы форм операций теперь использует не старый механизм 
логических блокировок-семафоров, который использовал сервис LOCK_INFO, а 
использует новую схему (без запросов сервисам LOCK_INFO, что снимает с них 
существенную нагрузку и позволяет увеличить их пропускную способность по 
обслуживанию других пользовательских запросов):
- запуск DEFAULT валидатора устанавливает логическую блокировку (создается 
  запись в FRM_LOCKS). Если блокировку установить не удастся (установлена 
  кем-то другим или экземпляр блокирован физически на уровне Oracle), то 
  выдается соответствующее сообщение об ошибке;
- последующие запуски валидаторов, а также тела операции проверяют 
  установленную блокировку, а именно:
    - запись в FRM_LOCKS присутствует и ее владелец не поменялся 
      (FRM_LOCKS.USER_ID);
    - не поменялось значение SCN экземпляра, над которым запущена форма
      (FRM_LOCKS.OBJ_SCN);
    - если значение SCN экземпляра поменялось, то проверяется владелец 
      изменений (FRM_LOCKS.EINFO), допускаются изменения только от собственной
      сессии;
- по завершении выполнения операции блокировки снимаются (записи FRM_LOCKS для
  текущего владельца удаляются).
  Эта функциональность реализована на уровне интерфейсных пакетов операций.

  Технически логическая блокировка устанавливается в два этапа:
- в основной транзакции (чтобы были видны изменения SCN текущей транзакции,
  если таковая была инициализирована) зачитывается SCN с блокировкой, которая
  тут же откатывается;
- в автономной транзакции заносится запись в FRM_LOCKS с зачитанным на первом
  этапе значением SCN экземпляра.

  Для работы с новым типом блокировок реализованы дополнительные функции
интерфейсных пакетов операций:
  - SCN$ - возвращает значение SCN экземпляра по его ID;
  - REQUEST_LOCK - запрос логической блокировки по его ID, возвращает пустую
    строку, если блокировка успешно установлена, либо строку с информацией о
    причине невозможности установки блокировки;
  - REQUEST_LOCKS - запрос логических блокировок списком (строкой с 
    разделителями-запятыми), возвращает пустую строку, если удалось установить
    все затребованные блокировки, либо список ошибок;
  - CHECK_LOCK - процедура проверки установленной ранее блокировки, при 
    неудачной проверке генерит исключение RTL.CHECK_OBJECT.

  Расширен набор функций и процедур пакета LOCK_INFO для работы с новым типом
блокировок (более подробно - см.ч.2,4):
- Новые функции и процедуры:
    OBJECT_SCN     - динамический вызов <CLASS INTERFACE>.SCN$,
    REQUEST_LOCK   - динамический вызов 
                     <CLASS INTERFACE>.REQUEST_LOCK/REQUEST_LOCKS,
    CHECK_LOCK     - динамический вызов <CLASS INTERFACE>.CHECK_LOCK,
    GET_LOCK       - получить информацию о блокировке в FRM_LOCKS,
    GET_USER_LOCKS - получить список блокировок пользователя из FRM_LOCKS.
- Расширение существующих:
    LOCK_CLEAR     - с параметром p_all=TRUE удаляет блокировки и из 
                     FRM_LOCKS.
    LOCK_GET, LOCK_GET_PUSH, LOCK_DEL - при значении параметра 
                     p_subject='FORM' запрашивают информацию непосредственно 
                     из FRM_LOCKS; 
    SET_IDS        - возможно указание списков запрашиваемых блокировок 
                     процедурами с параметром p_frm=TRUE.
    GET_INFO, GET_LOCK_INFO, PUSH_INFO, POP_INFO работают с любыми типами
                     блокировок в т.ч. и блокировками форм (если по ним 
                     запрошена информация), информация о них передается через
                     типы LOCKS_INFO, LOCKS_TBL.
    GET_LOCK_LIST  - позволяет получать список всех блокировок пользователя, 
                     в т.ч. и блокировок форм (при значении p_subject=NULL), 
                     при значении p_subject='FORM' возвращает список только 
                     из FRM_LOCKS.

  Изменен алгоритм работы и функции EXECUTOR.LOCK_REQUEST, которая при 
указании непустого значения для параметра p_class или при значении 
p_info='Nav' запрашивает блокировки FRM_LOCKS, а не стандартные 
блокировки-семафоры. Обработка значения p_info='Nav' реализована для обратной
совместимости со старыми версиями Навигаторов, которые про новый механизм 
ничего не знают, EXECUTOR.LOCK_REQUEST в этом случае выполняет динамические 
вызовы интерфейсных пакетов типов (что не очень хорошо). Новые версии 
Навигаторов должны будут использовать для этих целей новые функции 
интерфейсных пакетов операций, которые выполняют вызовы функций установок 
блокировок статически.

  Реализован также дополнительный сервис в языке PL/Plus (в дополнение к 
расширению функций пакетов RTL/EXECUTOR/LOCK_INFO). Добавлены новые 
модификаторы:
    %scn - получение SCN экземпляра (через <CLASS INTERFACE>.SCN$);
    %request - запрос блокировки (через <CLASS INTERFACE>.REQUEST_LOCK);
    %check  - проверка блокировки (через <CLASS INTERFACE>.CHECK_LOCK);
    %ses - возвращает значение ID сессии, внесшей последние изменения в 
      таблицу типа (т.е. значение колонки SU);
    %orascn - возвращает значение псевдоколонки ORA_ROWSCN для версий 
      Oracle 10g и выше.
  При использовании в SQL выражениях PL/Plus модификатор %scn транслируется
как обращение к колонке SN, модификаторы %ses и %orascn могут использоваться
только в SQL выражениях PL/Plus.
  На уровне ТЯ реализована генерация изменения значений колонок SN (инкремент)
и SU для любых конструкций, изменяющих данные в таблицах типов (SQL-операторы
INSERT/UPDATE, SET$OBJ$THIS для кэша THIS).


            10. Технические подробности реализации поиска владельца 
                физических блокировок.

  Реализован новый сервис по определению владельца физической блокировки 
экземпляра при блокировке посредством модификатора %lock. В связи с переходом 
на новую версию логических блокировок форм операций этот сервис в новой схеме
стал практически не работоспособен, т.к. информация может извлекаться только 
по списку блокировок форм (FRM_LOCKS), при этом полной гарантии того, что 
найденная логическая блокировка FRM_LOCKS соответствует удерживаемой 
физической, не существует, поскольку логическая блокировка лишь отражает 
намерение изменить экземпляр, тогда как фактически экземпляр может быть 
блокирован другой сессией без всяких предварительных запросов на логическую 
блокировку (см.ч.6).

  Новый сервис реализован по принципу поиска сессии-владельца транзакции, 
удерживающей физическую блокировку экземпляра. Поэтому если эту информацию 
удается извлечь, то она совершенно точно и адекватно определяет владельца 
физической блокировки.
  Алгоритм реализации следующий:
    - сессия выполняет попытку блокировки экземпляра (через модификатор %lock)
      путем выполнения "select ... for update wait 1" (с условием на ID 
      экземпляра и ожиданием в 1 сек.);
    - если первая попытка блокировки не удалась, тогда сессия сообщает сервису
      поддержки физических блокировок идентификатор своей сессии (sid из 
      v$session) и снова пытается установить блокировку экземпляра путем 
      "select ... for update wait 1", и так делает несколько раз (в 
      зависимости от настроек LOCK_RETRY, LOCK_DELAY, см.ч.7);
    - сервис поддержки физических блокировок получает запрос на определение 
      физической блокировки, пытается найти ждущую транзакционную блокировку
      (ТХ) по заданному sid сессии в v$lock (а такая запись должна 
      существовать пока данная сессия продолжает пытаться блокировать 
      экземпляр). Если сервис находит такую транзакцию, то найденные 
      идентификаторы транзакции (id1 и id2 в v$lock) помещает в ответную пайпу
      сессии, запросившей данную информацию;
    - пользовательская сессия при неудачной блокировке экземпляра по истечении
      всех попыток блокировки поднимает стандартное исключение 
      RTL.CANNOT_LOCK; в обработчике этого исключения (или из клиентского 
      приложения, например из Навигатора) сессия может запросить ответ от 
      сервиса c информацией о транзакции, и выполнить поиск по v$lock, чтобы
      определить sid сессии, удерживающей данную транзакцию и по v$session 
      определить характеристики данной сессии.

  Интерфейс данного сервиса для Навигатора не изменился, так что функционально
все выглядит точно так же, как и в прежней реализации, основанной на 
накоплении информации о блокировках в сервисе LOCK_INFO. Как видно из 
описанного алгоритма, новая реализация не требует поддержки списков 
блокированных экземпляров, это делается по факту наличия транзакции, 
удерживающей физическую блокировку.

  Дополнительные процедуры и функции, которые реализуют логику данного 
сервиса, могут использоваться программно для реализации каких-либо прикладных 
алгоритмов, основанных на данном сервисе: get_v$lock, get_v$lock_user 
(см. ч.4), get (см. ч.2).

  Следует отметить, что сервис по определению физических блокировок будет 
работать только при следующих условиях (описание настроек см. чч.7,8):
- используется режим ждущих блокировок, т.е. настройка LOCK_NOWAIT должна быть
  отключена (режим по умолчанию);
- режим поиска явно не отключен настройкой LOCK_SKIP_WAIT (режим 
  по умолчанию);
- время ожидания LOCK_DELAY*LOCK_RETRY должно быть больше 1 секунды, чтобы 
  была как минимум одна дополнительная попытка блокировки, которая и 
  используется для поиска ждущей транзакции сервисом поддержки физических 
  блокировок (первая попытка нужна, чтобы понять, что экземпляр блокирован 
  другой сессией).

  Данный сервис использует информацию, публикуемую системой в представлении 
V$LOCK, запросы по которому являются весьма ресурсоемкими и выполняются 
довольно медленно (особенно в Oracle11g). Поэтому под этот сервис выделен 
отдельный процесс, который выполнется через механизм заданий по расписанию 
(как и основной процесс, обслуживающий логические блокировки-семафоры -
см. ч.11). Управление дополнительным сервисом, обслуживающим физические 
блокировки осуществляется с помощью функций и процедур пакета rtl:
  загрузка-выполнение -
    procedure lock_run(p_job in   pls_integer default null, 
                       p_instance pls_integer default null);
    где p_job - номер задания при выполнении через очередь заданий Oracle, не
                задается при выполнении в отдельной сессии;
    p_instance < 0 - выполняет функции дополнительного сервиса по обслуживанию
                физических блокировок;
    p_instance  пусто или >= 0 - выполняет функции основного сервиса по 
                обслуживанию логических блокировок-семафоров.
  остановка-выгрузка - 
    lock_stop/lock_hold (то же, что и lock_info.stop/hold - см. ч.4)

 
            11. Аутентификация пользовательских сессий.

    До версии ТЯ 7.3 функции регистрации пользовательских сессий были 
возложены на сервис lock_info, так что процедуры open/close просто посылали 
ждущий запрос сервису и по получении ответа инициализировали внутренние 
буферные данные соответствующего режима работы (зарегистрированном или нет). 
По запросу на регистрацию сессии сервис проверял состояние этой сессии 
(присутствует ли она в списке сессий Oracle - v%session), состояние учетной 
записи пользователя в системе доступа, проверял возможность добавления новой 
зарегистрированной сессий по ограничениям на общее количество сессий (из 
установленной лицензии) и для конкретного пользователя (по настройке 
SESSIONS_PER_USER из профиля пользователя). Список зарегистрированных 
пользовательских сессий находился в памяти выделенного процесса (собственно и
представляющего сервис lock_info), управлялся только этим процессом, доступ к
этому списку сессии получали только посредством запросов к сервису через 
пайповый механизм Oracle. Дополнительно список сессий дублировался сервисом в
таблице rtl_users.

  В версии ТЯ 7.3 алгоритм аутотентификации сессий пользователей принципиально
изменен. Эта функция вынесена из-под контроля сервиса lock_info и возложена на
саму регистрирующуюся сессию. Информация о регистрации сессий вынесена из 
памяти выделенного процесса и теперь размещается в специально созданном для 
этого глобальном контексте (с именем <Owner>_USERS), управляемом пакетом rtl, 
т.е. список сессий стал разделяемым ресурсом, так что теперь сами сессии стали
выполнять все необходимые действия по регистрации (в т.ч. по проверке заданных
ограничений). Эта же информация дублируется и в таблице rtl_users (как и 
раньше, только запись в таблицу теперь производится самими регистрирующимися 
сессии, а не сервисом lock_info), которая необходима как в плане совместимости
с предыдущими версиями ТЯ, так и для опций RAC (Real Application Cluster) и 
ADG (Active Data Guard - Physical ReadOnly Standby). При этом все действия по
регистрации, связанные с изменениями данных как глобального контекста, так и 
таблиц rtl_users/frm_locks/rtl_events (чистка таблиц при удалении сессий по 
close) производятся в автономной транзакции.
  Также реализован режим хранения информации о зарегистрированных сессиях 
только в таблице rtl_users, без использования глобального контекста. Этот 
режим рекомендуется использовать в конфигурации RAC Oracle11g, т.к. в этом 
случае запись в контекст происходит очень медленно из-за проблем синхронизации
контекста на разных узлах RAC. По умолчанию глобальный контекст используется 
только для классических 3L-сессий (не 2MCA) и нужен только для того, чтобы 
проверять "живость" сессии. Счетчики для отслеживания превышения количества
сессий не хранятся в этом контексте, для этого используется таблица RTL_USERS.

    Формат заполнения глобального контекста <OWNER_USERS>:

attribute: <ID зарегистрированной сессии>
value: строка с разделителем '|' в виде:
   'sid|ora_user|userid.module_hash|check_time|logon_time|ses_id|os_user|
    username|instance|info' где поля соответствуют структуре rtl.users_info 
    (см. ч.2),
    а также:
      module_hash - хэш-сумма исполняемого модуля сессией пользователя,
      check_time  - время последней активности сессии (заполняется при 
                    выполнении процедуры touch, а также по другим запросам к
                    сервису - см.ч.4), если контроль активности включен
                    настройкой LOCK_TIMEOUT (см. ч.8). Формат времени - 
                    'YYYYMMDDHH24MISS'.
attribute: '.'
value - общий счетчик зарегистрированных сессий.

attribute: '..'
value - время последнего обновления глобального контекста
        (формат 'HH24:MI:SS DD/MM/YY').

аttribute: 'userid.module_hash'
value - счетчик зарегистрированных сессий пользователя с идентификатором 
        userid и модулем module_hash (такие записи в контексте создаются
        только для пользователей, у которых задан контроль SESSIONS_PER_USER
        в профиле).

  Таким образом, за сервисами пакета lock_info остались следующие функции:
a) получение информации о физических блокировках (из v$lock - ч.10), причем 
  эта функция вынесена в отдельный независимый процесс;
b) удаление информации о зарегистрированных сессиях, завершившихся нештатным
  образом или по тайм-ауту (по настройке LOCK_TIMEOUT - см.ч.8), т.е. функция 
  refresh;
c) рассылка событий между узлами кластера.




