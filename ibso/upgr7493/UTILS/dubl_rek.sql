set serveroutput on size 100000
SET VERIFY OFF
SET FEEDBACK OFF
SET TERMOUT OFF
set linesize 180

/*
  Начиная с версии ТЯ >= 7.4.1.2 при добавлении нового реквизита в АРМе "Администратор словаря данных" выдается ошибка,
  если происходит мапирование нескольких реквизитов на одну колонку таблицы ТБП (отслеживается ситуация, когда новому реквизиту
  соответствует существующая колонка в таблице ТБП, которая уже относится к другому реквизиту).
  Ошибка возможна, если реквизит в процессе разработки переименовывался, но таблица ТБП не перестраивалась. Таким образом создается
  ситуация, когда имя колонки в таблице ТБП не равно "C_[КОРОТКОЕ ИМЯ РЕКВИЗИТА]".

  Наличие подобных ошибок в модели данных может привести к ошибкам в бизнес-логике, поэтому крайне рекомендуется исправить их.
  Данный скрипт предлагается использовать для диагностики проблемы.

  При использовании  JAVA-компилятора ошибка дублирования реквизитов на одну колонку ТБП будет  выдана в процедуре хранения
  для любых существующих сдублированных реквизитов.

  Возможные варианты решения:

  1) Переименование реквизита и/или модификация словаря данных.
     Переименовываем выбранный реквизит, в АРМе "Администратор словаря данных" выполняем хранение ТБП,
     при хранении будет добавлена колонка в таблицу для переименованного реквизита, выполняем заполнение данных новой колонки.
     Переименовать возможно только локальные реквизиты.

  2) Перестроение таблицы ТБП. В процессе перестроения ТБП будут созданы колонки для каждого из реквизитов. Данные сдублированной колонки
     в процессе перестроения копируются в колонки всех сдублированных реквизитов. Если типы реквизитов разные,
     то возможна ошибка конвертации данных при перестроении.

  3) Удалить лишние локальные реквизиты. Выполнить хранение ТБП.

  Вариант решения N1 разберем на примере:

  ВНИМАНИЕ!
  Обязательно сохраните резервное хранилище ТБП перед проведением работ. Проверьте результаты на тестовой схеме.

  Пусть у нас такой вывод
  -----------------------------------------------------------------------------------
  ТБП : PLATFORM_TEST
  Колонка : C_ZZZ
  Реквизиты : ZZ,ZZZ
  -----------------------------------------------------------------------------------
  1. В class_tab_columns для соответствующего класса найти реквизиты(выданные dubl_error.log), которые ссылаются на одну колонку.
  Определить реквизиты, которые требуется переименовать.

    На нашем тестовом примере  мы видим 2 проблемных реквизита, значит, поменять имя колонки нужно только для одного из них.

    Сделаем запрос
        select * from class_tab_columns c where c.qual in('ZZ','ZZZ') and c.class_id = 'PLATFORM_TEST';

        1.1 Очевидно, что если у реквизитов одинаковые типы(см. class_tab_columns.host_type), конвертация данных не требуется.

        Если же типы разные, нужно определить реквизиты, типы которых соответствуют типу колонки в таблице ТБП.
        Это можно сделать с помощью запроса вида:
        select u.TABLE_NAME, u.COLUMN_NAME, c.qual
        from user_tab_columns u, class_tab_columns c
        where u.table_name = (select table_name from class_tables where class_id = 'PLATFORM_TEST')
              and c.qual in('Z','ZZ') and c.class_id = 'PLATFORM_TEST' and c.column_name = u.COLUMN_NAME
              and c.host_type = data_type||
                      case
                      when data_precision is not null and nvl(data_scale,0)>0 then '('||data_precision||','||data_scale||')'
                      when data_precision is not null and nvl(data_scale,0)=0 then '('||data_precision||')'
                      when data_precision is null and data_scale is not null then '(*,'||data_scale||')'
                      when char_length>0 then '('||char_length||')'  end;

        1.2 Производим переименование реквизитов и/или редактируем записи в class_tab_columns:

          1.2.1 Если имя колонки для реквизита соответствует имени реквизита, т.е. имя колонки равно "C_[КОРОТКОЕ ИМЯ РЕКВИЗИТА]",
          то переименование не требуется.
          В примере: реквизит ZZZ не требуется переименовывать.

          1.2.2 Если для реквизита, не существует записи в class_tab_columns, то в АРМе "Администратор словаря данных" необходимо и достаточно
          переименовать короткое имя реквизита так, чтобы оно было уникальным и имя колонки для этого реквизита было уникальным в class_tab_columns
          для заданного класса.

          1.2.3. Если реквизит с заданным коротким именем есть в class_tab_columns, то информацию о колонке для реквизита следует
          удалить из class_tab_columns.
          В примере: Удалим информацию из class_tab_columns о колонке С_ZZZ для реквизита ZZ.
          delete from class_tab_columns where class_id='PLATFORM_TEST' and c.qual='ZZ'

    2. Нажать "Хранение" в АРМе "Администратор словаря данных" в окне редактирования ТБП на вкладке "Реквизиты".
    В логе хранения должна быть информация о добавлении колонок в таблицу ТБП. Серверная часть при добавлении  колонок
    сформирует корректное уникальное имя для новых колонок.
    Если ошибки о дублировании реквизитов не выдалось, то проблема решена.

    3.  Выполнить модификацию данных для колонок которые были созданы.
     При необходимости:
     - В созданные при выполнении хранения колонки скопировать или перенести данные из существоваших ранее колонок, преобразовать к требуемому типу.
     - Очиcтить данные в колонках.
     - Заполнить данные при возможности согласно требованиям бизнес-логики
     - ...
    Пример:
    update Z#PLATFORM_TEST set C_ZZ=C_ZZZ;
    update Z#PLATFORM_TEST set C_ZZZ=null;

    4. Если на шаге 1.2 выполнялось удаление данных из таблицы class_tab_columns, рекомендуется восстановить свойства колонок из резервного хранилища.
    Пример: Накатить информацию о реквизите ZZ из резервного хранилища. АРМ Администратор проектов при переносе информации о колонке для реквизита ZZ
    не изменит имя колонки в class_tab_columns.

*/

spool dubl_error.log

begin
  dbms_output.put_line('Список ТБП, в которых несколько реквизитов мапируются на одну колонку таблицы ТБП.');
  dbms_output.put_line('-----------------------------------------------------------------------------------');
  -- Здесь мы получаем имя класса, имя колонки, список дублируемых реквизитов
  for c in(select  a.class_id, a.col_name, listagg(a.qual,',') within group(order by a.qual) as attrs
           from(-- Реквизит может быть в class_attributes, но его может не быть в class_tab_columns по причинам:
                  -- произошла внутренняя ошибка
                  -- мы уже пытались добавить реквизит, и ядро сообщило нам, что колонка дублируется

             -- Так как мы отсеяли length(hq.qual) > 28(см. условие where), поэтому второй параметр class_mgr.make_column_name уже не важен и должен быть >=0
             -- Если второй параметр <0, то колонка формируется со служебным префиксом "С$" (опять же если length(hq.qual)<28, то имеет значение лишь знак параметра, а не его значение)
             -- колонки такого типа нас не интересуют.
             select hq.qual, nvl(ct.column_name, class_mgr.make_column_name(hq.qual,0)) as col_name, hq.class_id
             from
              class_tab_columns ct,
                 (-- Если в class_attributes в колонке [SELF_CLASS_ID] содержится имя класса(справочник или структура, то есть те классы, которые описаны в class_attributes)
                  -- то мы должны включить еще все реквизиты из класса, указанного в колонке [SELF_CLASS_ID]
                  -- c именами [КОРОТКОЕ ИМЯ РЕКВИЗИТА В ТЕКУЩЕМ КЛАССЕ].[КОРОТКОЕ ИМЯ РЕКВИЗИТА ИЗ КЛАССА [SELF_CLASS_ID]],
                  -- иначе формируется имя = [КОРОТКОЕ ИМЯ РЕКВИЗИТА В ТЕКУЩЕМ КЛАССЕ]. Это делается для связи с class_tab_columns

                  -- Здесь мы получаем исходное имя класса, полное имя реквизита.
                  select connect_by_root ca.class_id as class_id, ltrim(SYS_CONNECT_BY_PATH(ca.attr_id, '.'),'.') as qual
                  from class_attributes ca
                  -- отбираем только листовые узлы дерева.
                  -- То есть только те реквизиты, у которых [SELF_CLASS_ID] <> "STRUCTURE"
                  where CONNECT_BY_ISLEAF = 1
                  connect by prior ca.self_class_id = ca.class_id)hq
                -- связь построена таким образом, так как реквизит может быть в class_attributes, но его может не быть в class_tab_columns.
                -- Отсеиваем реквизиты, короткое имя которых больше 28 символов. Если длина превышает 28 сиволов,
                -- то ядро само добавит уникальный идентификатор(в пределах ТБП) и колонка никогда не пересечется с какой-либо другой.
             where length(hq.qual) <= 28 and ct.class_id(+) = hq.class_id and ct.qual(+) = hq.qual)a
             group by a.col_name, a.class_id
             having count(*) > 1)
  loop
    dbms_output.put_line('ТБП       : ' || c.class_id);
    dbms_output.put_line('Колонка   : ' || c.col_name);
    dbms_output.put_line('Реквизиты : ' || c.attrs);
    dbms_output.put_line('-----------------------------------------------------------------------------------');
  end loop;
end;
/

spool off
