ИЗМЕНЕНИЯ В STATES

Начиная с версии 6.1 класс STATES основывается не на таблице STATES,
а на представлении VW_STATES. Они отличаются в следующем:
1) VW_STATES.ID = STATES.CLASS_ID || '.' || STATES.ID
2) VW_STATES.STATE_ID = STATES.ID
все остальные поля без изменений.

ИЗМЕНЕНИЯ В ЗАВИСИМЫХ ОТ STATES ОБЪЕКТАХ

Чтобы учесть изменения в STATES нужно:

1) Исправить код на sql (условия в простых и сложных представлениях,
условия join при присоединении произвольных типов и т.д), в котором
происходит обращение к полю ID представления VW_STATES (т.е.
раньше происходило обращение к полю ID таблицы STATES)
Это необходимо, потому что VW_STATES.ID = STATES.CLASS_ID || '.' || STATES.ID

Пусть, например, в простом представлении происходит join c "таблицей" класса States
(при этом она добавлена через пункт контекстного меню "Добавить тип", т.е. условие
соединения нужно писать на вкладке "Свойства"->на вкладке "Условие") и в
этом запросе она идет с алиасом A2_1 (исходная таблица обычно имеет алиас A1_1).
Если условие соединения выглядело так:
A1_1.C_STATE_ID = A2_1.ID and
  A1_1.C_CLASS_ID = A2_1.CLASS_ID
то его нужно переписать так:
A1_1.C_CLASS_ID || '.' || A1_1.C_STATE_ID = A2_1.ID
либо так:
A1_1.C_STATE_ID = A2_1.STATE_ID and
  A1_1.C_CLASS_ID = A2_1.CLASS_ID

2) Исправить код на pl\plus (операции, pl\plus представления и т.д.), в котором
происходит обращение к %id класса STATES

Это необходимо, потому что изменилось значение возвращаемое
оператором-модификатором %id. Рассмотрим для примера состояние c
ID = 'NOT_PAID' и CLASS_ID = 'ACCF' (т.е. у которого поле ID таблицы STATES
содержит 'NOT_PAID', а поле CLASS_ID - 'ACCF') До версии 6.1 для этого
состояния %id и [ID] возвращали 'NOT_PAID', а %class_id и [CLASS_ID]
возвращали 'ACCF'. Теперь %id вернет 'ACCF.NOT_PAID', а [ID], как и раньше,
вернет 'NOT_PAID'.

Пусть, например, в pl\plus представлении происходит join c "таблицей" класса States и в
этом запросе она идет с алиасом s, т.е. указана в выражении in как (::[STATES]: s). Если
условие соединения выглядело так:
where doc%state = s%id and
  doc%class = s%class_id
то его нужно переписать так:
where doc%class || '.' || doc%state = s%id
либо так:
where doc%state = s.[ID] and
  doc%class = s%class_id
либо так:
where doc%state = s.[ID] and
  doc%class = s.[CLASS_ID]

3) Исправить код на pl\plus (операции, pl\plus представления и т.д.), который
работает с классом STATE_REF

Например:
...
  doc ref%MAIN_DOCUM;
  sref STATE_REF;
...
begin
...
  sref := doc%state;
...
end;
doc [MAIN_DOCUM];
sref [STATE_REF];
...

нужно исправить на
  sref := doc%class || '.' || doc%state;

4) Преобразовать содержимое колонок таблиц классов,
ссылающихся на STATES.

Поскольку старые значения id класса STATES неуникальны,
вопрос о преобразовании ссылок на него должен решаться
индивидуально в каждом случае. Рассмотрим два примера:
  а) Пусть в классе TEST есть реквизит REF - ссылка на STATES,
и работа с этим классом ведется так, что он может ссылаться
только состояния класса DOC. Для преобразования нужно выполнить
такой запрос
update Z#TEST set C_REF = 'DOC.' || C_REF
  б) Пусть в классе TEST есть реквизит SREF - ссылка на STATES и
реквизит CREF - ссылка на METACLASS (CREF добавлен специально для
однозначной идентификации состояния). Тогда нужно выполнить запрос
update Z#TEST set C_SREF = C_CREF || C_SREF
и, после этого CREF можно удалить (CREF уже не нужен, т.к. SREF
однозначно идентифицирует состояние)
  в) Все тоже что и в б), только в качестве типов реквизитов используется
STRING_16, а не ссылки. Преобразуется также как и в б), только приведенный ниже
запрос для поиска ссылок НЕ найдет эту таблицу!!! Кроме того, перед
преобразованием, нужно изменить тип SREF на STRING_128 (а еще лучше
на STATE_REF)!!!

В случае, если вы затрудняетесь с преобразованием ссылок, обратитесь
в службу поддержки БФТ.


ЗАПРОСЫ ПОИСКА ОБЪЕКТОВ ДЛЯ КОНВЕРТАЦИИ
Находятся в Meta.sql
