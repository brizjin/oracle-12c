        Основные типы и процедуры

1. Типы данных.

-- Тип даты-времени в журналах аудита
-- для Oracle8i это date, для Oracle9i и выше - timestamp
type DATE_TYPE is &datetype;

-- Структура журнала истории изменения реквизитов экземпляров
type VALUES_HISTORY_ITEM_T is RECORD (
  ID NUMBER,	       	-- ID записи журнала
  TIME DATE_TYPE,      	-- время записи
  OBJ_ID [REFSTRING],	-- ID экземпляра
  CLASS_ID STRING(16),	-- тип экземпляра
  AUDSID INTEGER,      	-- ID сессии пользователя, создавшей запись,
             -- (подробную информацию можно извлечь из журнала
             -- LOCK_INFO функцией get_user_info)
  USER_ID STRING(70),	-- имя пользователя (в формате <ORA_USER>.<OS_USER>)
  QUAL STRING(700),    	-- квалификатор реквизита
  BASE_ID STRING(16),	-- базовый тип реквизита
  VALUE STRING (4000),	-- текстовое значение реквизита
  REFCLASSID STRING(16),-- тип ссылаемого экземпляра (для реквизитов-ссылок или
             -- коллекций)
  REFNAME STRING(1000),	-- имя (умолчательное значение) ссылаемого экземпляра
             -- для реквизитов-ссылок,
             -- или действие (ADD - добавление элемента, DEL -
             -- удаление элемента) для реквизитов-коллекций,
  OBJ_COLL [REFSTRING],	-- ID ссылаемого экземпляра (элемента коллекции) для
             -- реквизитов-коллекций,
  PRIOR_ITEM	INTEGER,-- предыдущая запись (для одинаковых квалификаторов)
  NEXT_ITEM	INTEGER -- следующая запись (для одинаковых квалификаторов)
);

-- PL/SQL таблица структуры журнала истории изменения реквизитов экземпляров
type VALUES_HISTORY_T is TABLE of VALUES_HISTORY_ITEM_T;

-- Режимы поиска изменений по списку реквизитов
FIND_FLAG_EXACT	const integer := 0;	-- только заданный список реквизитов
FIND_FLAG_LOGGING	const integer := 1;	-- заданный список и все журналируемые
             -- реквизиты
FIND_FLAG_ALL	const integer := 2;	-- любые реквизиты

-- Структура исходных данных для извлечения истории изменений
type FIND_HISTORY_ITEM_T is RECORD (
  CLASS_ID	STRING(16),	-- тип экземпляра
  OBJ_ID	reference,	-- ID экземпляра
  ATTRS		STRING(4000),   -- список реквизитов
  FLAG		INTEGER,	-- режим поиска - 0 только заданный список, 1 +
             -- журналируемые реквизиты, 2 - все реквизиты,
             -- (для этих режимов определены мнемонические константы
             -- FIND_FLAG_...)
  REF_LEVEL INTEGER,	-- уровень обработки вложенных реквизитов-ссылок
  COL_LEVEL INTEGER,	-- уровень обработки реквизитов-коллекций
  GROUP_PER	BOOLEAN,-- признак свертывания изменений за период
  STATES	BOOLEAN,-- признак обработки истории изменения состояний
  COLLECTS	BOOLEAN	-- признак обработки истории изменения коллекций
);
-- PL/SQL таблица структуры исходных данных
type FIND_HISTORY_T is TABLE of FIND_HISTORY_ITEM_T;

-- Типы записей истории изменения реквизитов экземпляров
ITEM_OBJECT	const integer := -1;	-- узловая запись для экземпляра
ITEM_REFATTR	const integer := -2;	-- значения реквизитов-ссылок
ITEM_COLLATTR	const integer := -3;	-- значения реквизитов-коллекций
ITEM_REFINFO	const integer := -4;	-- информация о ссылаемом экземпляре
             -- через ссылку
ITEM_COLLINFO	const integer := -5;	-- информация о ссылаемом экземпляре
             -- через коллекцию
ITEM_PRNTINFO	const integer := -6;	-- информация о родительском
             -- экземпляре для элемента коллекции
ACTION_UPDATED	const integer := 0;	-- история изменений - изменение
             -- реквизита
ACTION_CREATED	const integer := 1;	-- история изменений - создание
             -- экземпляра
ACTION_DELETED	const integer := 2;	-- история изменений - удаление
             -- экземпляра
ACTION_ADDELEM	const integer := 3;	-- история изменений - создание
             -- элемента коллекции
ACTION_DELELEM	const integer := 4;	-- история изменений - удаление
             -- элемента коллекции

-- Структура истории изменения реквизитов экземпляров
type HISTORY_ITEM_T is RECORD (
  ITEM_TYPE	INTEGER,    -- тип записи, определяется мнемоническими константами
             -- для элементов истории (ACTION_...) или узловые (ITEM_..)
  ITEM_LVL	INTEGER,    -- 0 - основной уровень, >0 - уровень вложенности
             -- порожденной записи
  PARENTIDX	INTEGER,    -- родительская запись (для ссылок и коллекций)
  CHILD_IDX	INTEGER,    -- дочерняя запись (для ссылок и коллекций)
  PRIOR_IDX	INTEGER,    -- предыдущая запись (связный список)
  NEXT_IDX	INTEGER,    -- следующая запись  (связный список)
  MODIFIED	DATE_TYPE,  -- время записи (пусто если сама запись не изменялась,
             -- изменения - в порожденных записях)
  OBJ_ID	REFERENCE,  -- ID экземпляра
  OBJ_REF	REFERENCE,  -- ID ссылающегося экземпляра
  OBJ_COLL	COLLECTION, -- ID коллекции экземпляра
  CLASS_ID	STRING(16), -- тип экземпляра
  CLASS_NAME    STRING,	    -- наименование типа
  AUDSID	INTEGER,    -- ID сессии пользователя, создавшей запись
  USER_ID	STRING(70), -- имя пользователя (в формате <ORA_USER>.<OS_USER>)
  QUAL		STRING(700),-- квалификатор реквизита
  QUAL_NAME STRING(1000),   -- наименование реквизита
  BASE_ID	STRING(16), -- базовый тип реквизита
  TARGET_ID	STRING(16), -- ссылаемый тип реквизита
  VALUE_NEW	STRING(4000),-- новое значение реквизита
  VALUE_OLD STRING(4000)    -- предыдущее значение реквизита
);
-- PL/SQL таблица структуры истории изменения реквизитов экземпляров
type HISTORY_T is TABLE of HISTORY_ITEM_T;

-- Структура последнего изменения экземпляра
type OBJECT_ITEM_T is RECORD (
  OBJ_ID	REFERENCE,	-- ID экземпляра
  CLASS_ID	STRING(16),	-- тип экземпляра
  MODIFIED	DATE_TYPE,	-- время последнего изменения
  AUDSID	INTEGER,	-- ID сессии пользователя, изменившего экземпляр
  USER_ID	STRING(70)	-- имя пользователя (в формате <ORA_USER>.<OS_USER>)
);
-- PL/SQL таблица структуры истории изменения реквизитов экземпляров
type OBJECT_T is TABLE of OBJECT_ITEM_T;


2. Процедуры и функции.

2.1. Получение списка изменений реквизитов экземпляра p_obj_id за период с
P_START_DATE по P_END_DATE, если какая-то из дат не задана, то соответствующее
ограничение на поиск не накладывается.
  Возвращает массив истории изменений в p_history. Записи для одинаковых
реквизитов соединяются в связный список через поля структуры prior_item,
next_item, которые, соответственно, связывают предыдущее изменение или
последующее для данного реквизита.
procedure GET_VALUES_HISTORY(P_OBJ_ID reference,
    P_HISTORY in out VALUES_HISTORY_T,
    P_START_DATE in date := null, P_END_DATE in date := null);
pragma restrict_references(GET_VALUES_HISTORY,WNDS,WNPS);

2.2. Получение списка изменений состояний экземпляра p_obj_id за период с
P_START_DATE по P_END_DATE, если какая-то из дат не задана, то соответствующее
ограничение на поиск не накладывается.
  Возвращает массив истории изменений в p_history, при этом в QUAL заносится
значение '%state', при значении p_order=true (по умолчанию) выбираемые записи
упорядочиваются хронологически, иначе в обратном порядке, при непустом значении
p_order записи также связываются через указатели связного списка prior_item,
next_item.
procedure GET_STATE_HISTORY(P_OBJ_ID reference,
    P_HISTORY in out VALUES_HISTORY_T,
    P_START_DATE in date := null, P_END_DATE in date := null,
    P_ORDER boolean := true);
pragma restrict_references(GET_STATE_HISTORY,WNDS,WNPS);

2.3. Получение списка изменений коллекций экземпляра p_obj_id за период с
P_START_DATE по P_END_DATE, если какая-то из дат не задана, то соответствующее
ограничение на поиск не накладывается.
  Возвращает массив истории изменений в p_history, при этом в QUAL заносится
значение '%collection', а также может быть заполнена информация о родительском
экземпляре коллекции:
-- OBJ_COLL - ID родительского экземпляра, REFCLASSID - его тип,
-- REFNAME - его имя (значение умолчательного реквизита).
  При значении p_order=true (по умолчанию) выбираемые записи упорядочиваются
хронологически, иначе в обратном порядке, при непустом значении p_order записи
также связываются через указатели связного списка prior_item, next_item.
procedure GET_COLLECTION_HISTORY(P_OBJ_ID reference,
    P_HISTORY in out VALUES_HISTORY_T,
    P_START_DATE in date := null, P_END_DATE in date := null,
    P_ORDER boolean := true);
pragma restrict_references(GET_COLLECTION_HISTORY,WNDS,WNPS);

2.4. Получение свойств пользовательской сессии из журнала сообщений LOCK_INFO
по ее ID (p_audsid) и событию P_CODE (по умолчанию REGISTERED, т.е. на момент
регистрации).
  Возвращает дату заданного события и информацию о пользовательской сессии в
p_info.
function get_user_info(p_audsid integer, p_info out lock_info.users_info,
    p_code string default null) return date_type;
pragma restrict_references(get_user_info,WNDS,WNPS);

2.5. Процедура построения дерева истории изменений методом поиска изменений
"от экземпляров", т.е. по заданным параметрам p_find сначала определяется набор
экземпляров, для которых требуется извлечь историю, а затем для каждого из них
извлекается история изменений.
  Входные параметры:
-- p_find - исходные данные для извлечения истории;
-- p_start_date, p_end_date - период для извлечения данных по истории (могут
      быть не заданы);
-- p_del_empty - признак удаления из дерева узлов, для которых история не
      найдена (параметр служебный, без необходимости задавать не требуется).
  Возвращает информацию в виде дерева истории, содержащейся в параметре p_hist
Описание связей в дереве истории - см. п.3.
procedure get_history(p_hist in out HISTORY_T, p_find FIND_HISTORY_T,
    p_start_date date, p_end_date date, p_del_empty boolean default true);

2.6. Процедура извлечения последних изменений экземпляров методом поиска
изменений "от истории", т.е. по заданным параметрам p_find сначала определяется
набор экземпляров, для которых требуется извлечь историю, а затем за указанный
интервал дат извлекаются данные из журналов истории, которые затем фильтруются
по заданным типам, реквизитам и набору экземпляров.
  Входные параметры:
-- p_find - исходные данные для извлечения истории;
-- p_start_date, p_end_date - период для извлечения данных по истории, причем
      начальная дата должна быть задана обязательно.
  Возвращает информацию о последних изменениях экземпляров в массиве p_objs.
procedure get_objects(p_objs in out OBJECT_T, p_find FIND_HISTORY_T,
    p_start_date date, p_end_date date);

2.7. Процедура извлечения последних изменений из дерева истории (p_hist).
При значении p_last_date=true извлекается также информация о дате изменения и
пользователе, внесшем последнее изменение.
  Возвращает информацию о последних изменениях экземпляров в массиве p_objs.
procedure extract_objects(p_objs in out OBJECT_T, p_hist HISTORY_T,
    p_last_date boolean);

2.8. Общая процедура построения дерева истории изменений.
  Входные параметры:
-- p_mode true  - использование алгоритма поиска изменений "от экземпляров",
-- p_mode false - использование алгоритма поиска изменений "от истории",
-- p_mode null - автоматический выбор алгоритма:
      поиск изменений "от истории" - если заданный период <=30 дней,
        а также в p_find есть типы, для которых поэкземплярный поиск не задан
      иначе - поиск изменений "от экземпляров";
-- p_start_date, p_end_date - период для извлечения данных по истории (могут
      быть не заданы), если p_start_date не задан, то при поиске от истории,
      принимается значение, отстоящее от p_end_date на 30 дней ранее (если
      p_end_date не задан, то принимается значения начала следующего дня, считая
      от текущей даты).
  При поиске "от экземпляров" дерево выстраивается процедурой get_history.
  При поиске "от истории" сначала определяются измененные экземпляры
(get_objects), для которых потом производится поэкземплярное извлечение истории
по шаблону параметров из первого элемента p_find (процедурой get_history).
  Возвращает информацию в виде дерева истории, содержащейся в параметре p_hist.
  Описание связей в дереве истории - см. п.3.
procedure get_objects_history(p_hist in out HISTORY_T, p_find FIND_HISTORY_T,
    p_start_date date, p_end_date date, p_mode boolean default null);

2.9. Общая процедура извлечения последних изменений экземпляров.
  Входные параметры:
-- p_mode true  - использование алгоритма поиска изменений "от экземпляров",
-- p_mode false - использование алгоритма поиска изменений "от истории",
-- p_mode null - автоматический выбор алгоритма:
      поиск изменений "от истории" - если заданный период <=30 дней,
        а также в p_find есть типы, для которых поэкземплярный поиск не задан
      иначе - поиск изменений "от экземпляров";
-- p_start_date, p_end_date - период для извлечения данных по истории (могут
      быть не заданы), если p_start_date не задан, то при поиске от истории,
      принимается значение, отстоящее от p_end_date на 30 дней ранее (если
      p_end_date не задан, то принимается значения начала следующего дня, считая
      от текущей даты).
  При поиске "от истории" изменения извлекаются процедурой get_objects.
  При поиске "от экземпляров" сначала выстраивается дерево истории
(get_history), для которого потом извлекаются последние изменения (процедурой
extract_objects).
  Возвращает информацию о последних изменениях экземпляров в массиве p_objs.
procedure get_objects_modified(p_objs in out OBJECT_T, p_find FIND_HISTORY_T,
    p_start_date date, p_end_date date, p_mode boolean default null);

2.10. Функция возвращает мнемонический код для заданного типа узла истории
-- (p_type - HISTORY_ITEM_T.ITEM_TYPE).
function  node_name(p_type integer) return string;

2.11. Функция возвращает текстовое представление даты истории изменений
(делает преобразование DATE_TYPE к строке)
  Для преобразования date (Oracle8i) используется формат
constant.DATE_FORMAT ('YYYY-MM-DD HH24:MI:SS').
  Для преобразования timestamp (Oracle9i) используется формат constant.TIMESTAMP_FORMAT ('YYYY-MM-DD HH24:MI:SS.FF9').
function  get_date_char(p_date_time DATE_TYPE) return string;

2.12. Функция возвращает дату истории изменений по заданной строке
(делает преобразование строки к DATE_TYPE)
  Для преобразования к date (Oracle8i) используется формат
constant.DATE_FORMAT ('YYYY-MM-DD HH24:MI:SS').
  Для преобразования к timestamp (Oracle9i) используется формат
constant.TIMESTAMP_FORMAT ('YYYY-MM-DD HH24:MI:SS.FF9').
function  get_char_date(p_str string) return DATE_TYPE;


3. Описание дерева истории.
  Основные процедуры извлечения истории изменения принимают массив исходных
данных типа FIND_HISTORY_T, с элементами-структурами FIND_HISTORY_ITEM_T,
где в полях структуры задается исходная информация для поиска:
  CLASS_ID -- ТБП для поиска изменений - должен быть задан всегда.
  OBJ_ID   -- ID экземпляра заданного типа, для которого требуется извлечь
      историю, может быть не задан, тогда история изменений извлекается для всех
      экземпляров.
  ATTRS    -- Список реквизитов, изменения которых следует извлекать, в виде
    списка квалификаторов, где разделителями могут быть запятые, пробелы,
    табуляторы, переводы строк. Квалификаторы могут содержать префикс типа
    (для указания необходимых реквизитов в ссылаемых экземплярах, если задан
    поиск по вложенным ссылкам или коллекциям), например, CLASS_ID='CLIENT',
    ATTRS='NAME,INN,ADDRESSES,PERSONAL_ADDRESS:CITY,PERSONAL_ADDRESS:STREET'.
    Список реквизитов должен быть указан при значении FLAG=0, для других
    режимов поиска это необязательно.
  FLAG     -- Режим поиска (должен быть указан)
    Для режимов поиска определены мнемонические константы FIND_FLAG_...(см.п.1):
      0 только заданный список в ATTRS;
      1 используется заданный список, а также все журналируемые реквизиты,
        в т.ч. при вложенном поиске по ссылкам и коллекциям;
      2 отслеживать изменения любых реквизитов.
  REF_LEVEL -- Уровень обработки вложенных реквизитов-ссылок.
    Если задан >0, тогда будет извлекаться история изменения ссылаемого
    экземпляра (по ссылкам, заданным в списке реквизитов и режимом поиска).
  COL_LEVEL -- уровень обработки вложенных реквизитов-коллекций.
    Если задан >0, тогда будет извлекаться история изменения элементов массива
    экземпляра (по коллекциям, заданным в списке реквизитов и режимом поиска).
  GROUP_PER -- Признак свертывания изменений за период.
    При заданном значении true, изменения реквизита за заданный период будут
    свернуты на начало и конец периода. Если при этом окажется, что эти
    значения будут одинаковы, тогда такая запись в дерево истории включена
    не будет.
  STATES    -- Признак обработки истории изменения состояний.
    При заданном значении true будет извлекаться история изменения состояний
    экземпляров (квалификатор при этом будет установлен в значение '%state').
  COLLECTS  -- Признак обработки истории изменения коллекций.
    При заданном значении true будет извлекаться история изменения состояний
    экземпляров (квалификатор при этом будет установлен в значение
    '%collection').

  При поиске истории по вложенным экземплярам, при переходе к вложенному
экземпляру, значения обрабатываемых уровней вложенности уменьшаются на 1 (т.е.
проваливание по ссылкам и коллекциям будет происходить, пока не будет достигнуто
значение 0). Задавать большие уровни вложенности без серьезной необходимости не
рекомендуется, т.к. это может сильно расширить количество экземпляров, для
которых будет извлекаться история, что может привести к очень долгому поиску.

  По заданным критериям поиска процедурами get_history и get_objects_history
выстраивается дерево истории. Дерево истории представляет собой
иерархические списки, устройство которых описано ниже.
  Связывание узлов дерева, а также навигация по дереву осуществляется через поля
структуры HISTORY_ITEM_T:
  PARENTIDX -- Родительский узел (для порожденных записей), т.е. индекс
    родительского узла в дереве истории.
  CHILD_IDX -- Дочерний узел (для родительских записей), т.е. индекс
    первого в списке дочерних узлов в дереве истории.
  PRIOR_IDX -- Предыдущий узел (индекс) в связном списке узлов дерева
    на одном уровне.
  NEXT_IDX  -- Следующий узел (индекс) в связном списке узлов дерева
    на одном уровне.
Таким образом, навигация вперед-назад по списку внутри одного уровня
осуществляется через поля NEXT_IDX-PRIOR_IDX. Для первого узла одноуровневого
списка PRIOR_IDX пуст, а для последнего узла NEXT_IDX пуст.
Переход на уровень выше осуществляется по индексу PARENTIDX, если PARENTIDX
пуст, это значит, что узел принадлежит верхнеуровневому списку.
Переход на уровень ниже осуществляется по индексу CHILD_IDX на первый элемент
дочернего списка, если CHILD_IDX пуст, это значит, что список дочерних
элементов также пуст.

  На верхнем уровне выстраиваются узлы типа ITEM_OBJECT, которые идентифицируют
экземпляр, для которого существует информация в дереве истории.
Для такого узла существенными являются поля:
  OBJ_ID, OBJ_REF (для вложенных экземпляров), OBJ_COLL, CLASS_ID, CLASS_NAME.
Дочерними элементами у ITEM_OBJECT могут быть элементы истории (у которых
тип узла ACTION_...), а также значения реквизитов-ссылок (ITEM_REFATTR) и
коллекций (ITEM_COLATTR), если задан поиск по вложенным ссылкам и коллекциям.
  Для элементов истории все поля существенны, для ITEM_REFATTR/ITEM_COLATTR
существенны все поля, кроме MODIFIED, AUDSID, USER_ID, VALUE_OLD,
значение ссылки/коллекции заносится в поле VALUE_NEW.
  У элементов-реквизитов ссылок и коллекций (ITEM_REFATTR/ITEM_COLATTR)
может быть определен список элементов-экземпляров ITEM_OBJECT (у ссылок
ITEM_REFATTR он всегда один, у коллекций ITEM_COLATTR их может быть несколько),
при этом у этих элементов значение поля ITEM_LVL будет на 1 больше, чем у
предыдущего уровня, OBJ_REF будет указывать на ID экземпляра, по ссылке из
которого добавлена порожденная запись в историю, а PARENTIDX будет указывать на
родительский элемент-реквизит (ITEM_REFATTR/ITEM_COLATTR). Соответственно,
порожденные ITEM_OBJECT узлы, в свою очередь, также могут содержать дочерние
списки с элементами истории и элементами-реквизитами, однако уровень
вложенности не может превышать заданный исходно в структуре FIND_HISTORY_ITEM_T.

  Для узлов - элементов истории изменений, могут быть определены
дополнительные дочерние информационные узлы, которые содержат
сопутствующую информацию:
  Узлы добавления-удаления элементов коллекций (ACTION_ADDELEM,ACTION_DELELEM)
содержат дополнительный дочерний узел ITEM_COLLINFO с информацией о добавленном
элементе коллекции, в котором заполняются поля OBJ_ID, CLASS_ID (информация
об элементе коллекции), OBJ_REF, OBJ_COLL (родительский экземпляр и его
коллекция).
  Узлы изменения значений ссылок (item_type=ACTION_UPDATED и base_id='REFERENCE')
могут содержать дочерний узел ITEM_REFINFO с информацией о ссылаемых экземплярах
со следующими заполненными полями:
OBJ_ID, CLASS_ID, VALUE_NEW (ID экземпляра, его тип, наименование -
  умолчательный реквизит, соответственно) для нового значения ссылки,
CLASS_NAME, TARGET_ID, VALUE_OLD (ID экземпляра, его тип, наименование -
  умолчательный реквизит, соответственно) для старого значения ссылки,
OBJ_REF, OBJ_COLL - ссылающийся экземпляр и его идентификатор коллекции.
  Узлы изменения значения идентификатора коллекции(item_type=ACTION_UPDATED
и qual='%collection') могут содержать дочерний узел ITEM_PRNTINFO с информацией
о родительских экземплярах со следующими заполненными полями:
OBJ_ID, CLASS_ID, VALUE_NEW (ID экземпляра, его тип, наименование -
  умолчательный реквизит, соответственно) для нового родителя,
CLASS_NAME, TARGET_ID, VALUE_OLD (ID экземпляра, его тип, наименование -
  умолчательный реквизит, соответственно) для старого родителя,
OBJ_REF, OBJ_COLL - ссылающийся экземпляр и его идентификатор коллекции.


4. Рекомендации по использованию различных алгоритмов извлечения истории
("от экземпляров" или "от истории"). Если набор экземпляров, для которых
требуется извлекать историю точно известен, тогда рекомендуется использовать
поиск "от экземпляров". Поиск "от истории" рекомендуется использовать,
если нужно отследить изменения любых экземпляров в типе (т.е. если
в структуре FIND_HISTORY_ITEM_T поле OBJ_ID не задано) и если период
времени для извлечения истории задан не слишком большим. Также этот
режим поиска удобен, если нужно получить только набор измененных
экземпляров, для которых потом можно провести уже точечный поиск
"от экземпляров" (процедура get_objects_history, если выполняется
"от истории", так и делает). Дополнительным свойством алгоритма
извлечения изменений "от истории" является режим, при котором исходный
набор всех экземпляров типа не извлекается (в режиме "от экземпляров"
список экземпляров извлекается всегда и, если этот список может
получиться довольно объемным, то только процедура извлечения экземпляров
может занять значительное время), набор экземпляров определяется при
извлечении данных из самой истории. Этот режим действует, если
в структуре FIND_HISTORY_ITEM_T не задан (или задано значение 0) уровень
вложенных ссылок REF_LEVEL, а уровень вложенных коллекций COL_LEVEL не
превышает значения 1, либо также не задан.


5. Служебные типы и процедуры.
-- Тип для преобразования индексов
type INDEX_TBL is table of integer index by &index_type;

-- PL/SQL таблица списков реквизитов со ссылками на их описания или значения
type ATTR_LIST_T is TABLE of STRING(32767);
-- PL/SQL таблица описания квалификаторов и сохраненных значений реквизитов
-- экземпляров
type ATTR_VALS_T is constant.MEMO_TABLE;

-- Структура описания экземпляров и их реквизитов.
type OBJ_VALS_ITEM_T is RECORD (
  OBJ_ID	reference,	-- ID экземпляра
  CLASS_ID	STRING(16),	-- тип экземпляра
  STATE_ID	STRING(16),	-- состояние экземпляра
  COLL_ID	collection,	-- ID коллекции экземпляра
  ATTR_LIST	integer,	-- индекс в таблице описаний реквизитов
  ATTR_VALS	integer,	-- индекс в таблице значений простых реквизитов
  REF_VALS	integer,	-- индекс в таблице значений реквизитов-ссылок
  COL_VALS	integer		-- индекс в таблице значений реквизитов-коллекций
);
-- PL/SQL таблица структуры описаний экземпляров и их реквизитов
type OBJ_VALS_T is TABLE of OBJ_VALS_ITEM_T;
-- Таблица описаний реквизитов определяется типом ATTR_LIST_T,
-- таблица значений - типом ATTR_VALS_T.
-- Поле ATTR_LIST определяет индекс в таблице описаний и ссылается
-- на запись в этой таблице следующего формата:
-- :<IDX>;<QUAL1>:<IDX1>;<QUAL2>:<IDX2>;...<QUALn>:<IDXn>;
--   где QUAL1 .. QUALn - квалификаторы реквизитов экземпляра,
--   где IDX, IDX1 .. IDXn - индексы в таблице значений, которые ссылаются
--     на записи в таблице значений следующего формата (индекс IDX ссылается
--     на описание самого типа - CLASS_ID):
--   <BASE_CLASS_ID>.<TARGET_CLASS_ID>.<QUAL name>
-- Поле ATTR_VALS определяет индекс в таблице описаний и ссылается
-- на запись в этой таблице следующего формата:
-- ;<QUAL1>:<IDX1>;<QUAL2>:<IDX2>;...<QUALn>:<IDXn>;
--   где QUAL1 .. QUALn - квалификаторы простых реквизитов (не ссылочных)
--     экземпляра,
--   где IDX1 .. IDXn - индексы в таблице значений, в которой хранятся
--     текстовые значения этих реквизитов.
-- Поле REF_VALS определяет индекс в таблице описаний и ссылается
-- на запись в этой таблице следующего формата:
-- ;<QUAL1>:<IDX1>;<QUAL2>:<IDX2>;...<QUALn>:<IDXn>;
--   где QUAL1 .. QUALn - квалификаторы реквизитов-ссылок экземпляра,
--   где IDX1 .. IDXn - индексы в таблице значений, в которой хранятся
--     текстовые значения этих реквизитов.
-- Поле COL_VALS определяет индекс в таблице описаний и ссылается
-- на запись в этой таблице следующего формата:
-- ;<QUAL1>:<IDX1>;<QUAL2>:<IDX2>;...<QUALn>:<IDXn>;
--   где QUAL1 .. QUALn - квалификаторы реквизитов-коллекций экземпляра,
--   где IDX1 .. IDXn - индексы в таблице значений, в которой хранятся
--     текстовые значения этих реквизитов.
-- Списки реквизитов для фактических значений (ATTR_VALS,REF_VALS,COL_VALS)
-- являются, естественно, подмножеством полного списка (ATTR_LIST)

-- Получение текущих значений реквизитов экземпляров
-- возвращает true при успешно выполненном поиске и заполненными буферами
function fill_attr_values(
    p_class string,     -- тип для поиска данных (если не заданы p_obj, p_coll,
      -- тогда накладывается условие на CLASS_ID и COLLECTION_ID is null)
    p_obj reference,    -- ID экземпляра (если задан, то накладывается условие
      --только на ID)
    p_coll collection,  -- ID коллекции экземпляра (если p_coll задан, а p_obj
      -- не задан, то накладывается условие на COLLECTION_ID)
    p_list string,	    -- список квалификаторов скалярных реквизитов (через
      -- запятую)
    p_flag integer,	    -- 0 только заданный список, 1 + журналируемые
      -- реквизиты, 2 - все реквизиты
    p_ref_level integer,-- уровень обработки реквизитов-ссылок
    p_col_level integer,-- уровень обработки реквизитов-коллекций
    obj_vals  in out OBJ_VALS_T,	-- буфер получения набора экземпляров
    attr_list in out ATTR_LIST_T,	-- буфер получения набора описаний
      -- реквизитов экземпляров
    attr_vals in out ATTR_VALS_T	-- буфер получения набора значений
      -- реквизитов экземпляров
) return boolean;
-- Буфер obj_vals содержит ссылки на буфер описаний реквизитов attr_list и их
-- значений attr_vals в соответствии с описанными связями.

-- Процедура удаляет узел из дерева истории, пере направляя внутренние ссылки
-- дерева, чтобы на нарушалась навигация по дереву.
procedure delete_node(p_hist in out HISTORY_T, p_idx integer);

-- Функции преобразования DATE_TIME в строку и наоборот
function  get_date_char(p_date_time DATE_TYPE) return string;
function  get_char_date(p_str string) return DATE_TYPE;

-- Процедура заполнения массива P_ARCH (типа LIB.ARCHIVE_REC_TBL_T)
-- из системного журнала истории изменения реквизитов для заданных:
-- в P_CLASS - типа,
-- в P_QUALS - списка квалификаторов реквизитов (пустое значение означает
--             любые квалификаторы),
-- в P_START_DATE и P_END_DATE - диапазона дат (пустые значения означают
--             отсутствие соответствующих граничных условий)
procedure GET_ARCHIVE_VALUES(P_CLASS string, P_QUALS memo,
               P_ARCH in out LIB.ARCHIVE_REC_TBL_T,
               P_START_DATE in DATE_TYPE := null, P_END_DATE in DATE_TYPE := null);

-- Функция сохранения массива P_ARCH (типа LIB.ARCHIVE_REC_TBL_T) 
-- в истории архивных реквизитов для заданного в P_CLASS типа (сохраняются
-- только записи для скалярных реквизитов и изменений значений коллекций).
-- Параметр P_EXISTING задает признак проверки существования экземпляра в заданном типе.
-- Возвращает количество сохраненных записей
function PUT_ARCHIVE_VALUES(P_CLASS string, P_ARCH LIB.ARCHIVE_REC_TBL_T
               P_EXISTING boolean := true)  return integer;

-- Функция переноса данных из системного журнала истории 
-- в историю архивных реквизитов для заданных:
-- в P_CLASS - типа, 
-- в P_QUALS - списка квалификаторов реквизитов (пустое значение означает 
--             любые квалификаторы),
-- в P_START_DATE и P_END_DATE - диапазона дат (пустые значения означают 
--             отсутствие соответствующих граничных условий);
-- в P_EXISTING - признака проверки существования экземпляра в заданном типе.
-- Переносятся записи только для скалярных реквизитов и изменений значений коллекций.
-- Возвращает количество перенесенных записей.
function FILL_ARCHIVE_VALUES(P_CLASS string, P_QUALS memo, 
               P_START_DATE in DATE_TYPE := null, P_END_DATE in DATE_TYPE := null,
               P_EXISTING boolean := true)  return integer;

