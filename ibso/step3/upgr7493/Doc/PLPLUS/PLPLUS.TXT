            Изменения в PL/PLUS (версий 6.1 и выше).

----------------------------------------------------------------------
Изменения на 20.09.2011. - версия 7.3 (build 0 Revision 0).

        1. Синтаксис.

1.1. Реализованы операторы для работы со вложенными массивами
(multiset operators):
     MULTISET UNION {/ALL DISTINCT/}
     MULTISET MINUS {/ALL DISTINCT/} (multiset except - in SQL)
     MULTISET INTERSECT {/ALL DISTINCT/}
  Для массивов с элементами-структурами эти операторы могут
быть использованы только в SQL-выражениях, для скалярных
элементов их можно использовать и в процедурном коде.

1.2. Реализованы логические условия-операторы для вложенных
массивов:
     IS {NOT} EMPTY
     IS {NOT} /SET A_SET/ (is a set - in SQL)
     IS {NOT} MEMBER OF (member - in SQL)
     IS {NOT} SUBMULTISET OF (submultiset - in SQL)
  Для массивов с элементами-структурами эти операторы могут
быть использованы только в SQL-условиях, для скалярных
элементов их можно использовать и в процедурном коде.

1.3. Реализована поддержка операторов-функций для
Oracle text option:
     CATSEARCH(<text column>,<text query>,<structured query>)
     CONTAINS(<text column>,<text query>,<score correlation>)
     SCORE(<score correlation>)
     MATCHES(<text column>,<sample string>,<match correlation>)
     MATCH_SCORE(<match correlation>)
  Эти операторы могут быть использованы только для текстовых
колонок в таблицах БД, для которых определены специализированные
текстовые индексы поддержки Oracle text option.

1.4. Реализована поддержка числовых констант в научной
(экспоненциальной) нотации, а также констант BINARY_FLOAT и
BINARY_DOUBLE, для которых следует указывает суффиксы F или D,
соответственно.
                Пример:
        n := 123 + 4.56E-3 - 1E3D;

1.5. Реализованы операторы проверки числовых типов
BINARY_DOUBLE/BINARY_FLOAT:
     IS {NOT} NAN
     IS {NOT} INFINITE
                Пример:
        declare
          d binary_double := 1.0D;
          n number := 1.0;
        begin
          d := d/0D;
          if d is infinite then
            stdio.put_line_buf('Get Infinity - no exception');
          end if;
          n := n/0; -- zero_divide exception
        end;


1.6. Реализован native оператор continue для Oracle11g.

1.7. Реализована возможность использования скобок в операторах
UNION/MINUS/INTERSECT в SQL-запросах (ранее в качестве скобок
использовались дополнительные подзапросы).
                Пример:
        type c_users is
          select s(s.[name]) in [USERS] where s.type = 'U'
           minus (
             select u(u.[name]) in [USER]
              union
             select c(c.[name]) in [CLIENT]
           );

1.8. Расширен набор стандартных функций:
  acos, asin, atan/atan2, to_blob, to_clob, to_raw, lnnvl,
  soundex, nanvl.
Функции для работы с вложенными массивами:
  collect, cardinality, set_distinct (set in SQL).
Псевдо-функции:
  system_context - имя системного контекста <owner>_SYSTEM;
  gowner - имя глобального владельца (inst_info.gowner).
Константы:
  binary_double_infinity, binary_float_infinity - бесконечность
     для типов binary_double и binary_float, соответственно
     (возникает при делении любого ненулевого вещественного
     числа на вещественный ноль), любые арифметические действия
     с бесконечностью дают в результате бесконечность или нечисло
     (однако при делении вещественного числа на бесконечноть
     получается вещественный ноль);
  binary_double_nan, binary_float_nan - нечисло
     для типов binary_double и binary_float, соответственно
     (возникает при делении вещественного нуля на вещественный ноль,
     при делении бесконечности на бесконечность, при умножении бесконечности
     на вещественный ноль), любые арифметические действия с нечислом
     дают в результате нечисло.



        2. Семантика.

2.1. Доработки компилятора:
  - реализовано соединение таблиц при разыменовании ссылок,
    определенных как функциональные реквизиты (через вызов
    функций интерфейсных пакетов типов);
  - реализовано подавление ошибки при анализе параметров функций,
    возвращающих неопределенный тип (когда на этапе компиляции
    не удается определить возвращаемый тип из-за неполного
    описания в словаре rtl_entries);
  - реализовано подавление алгоритма оптимизации списка таблиц
    выборки по условию OR, если в ветках этого условия используются
    другие подзапросы;
  - скорректирован алгоритм подбора вызова стандартных функций
    работы со строками и CLOB-ами при использовании синтаксиса
    с указанием имен параметров;
  - реализовано переупорядочивание списка параметров функций с
    именованными параметрами при использовании в SQL-выражениях;
  - реализованы обращения к реквизитам экземпляров по ссылке через
    именованные функции-реквизиты интерфейсных пакетов типов (см.п.3.2);
  - реализована возможность установки значения реквизитов
    через модификатор %value (см.п.3.2);
  - реализована замена функций rtl.get_value/rtl.set_value
    на функции интерфейсных пакетов get$value/set$value (см.п.3.2),
    если на этапе компиляции известен тип ссылки (1-параметр
    get_value/set_value);
  - реализован анализ режима кэширования экземпляров при
    генерации кода кэширования экземпляра this в операциях (см.п.3.3),
  - скорректирована генерация умолчательных (пустых) значений
    при объявлении функций и процедур с параметрами-индексированными
    массивами, объявленными умолчательными;
  - реализовано предупреждение при генерации текстов SQL-операторов
    insert/update/delete по подзапросу;
  - реализовано предупреждение о возможно ошибочном использовании
    статического экземпляра в качестве переменной.
  - реализовано переименование используемых параметров
    в неявных курсорах, открываемых оператором %open;
  - скорректирована генерация автоматического значения для
    колонки STATE_ID в SQL-операторе INSERT при указании других
    системных колонок (CORECORE-34);
  - оптимизировано использование временных переменных в
    SQL-запросах PL/Plus, устранено лишнее дублирование.


2.2. Доработки java-компилятора:
- реализована поддержка выборки колонок типа вложенный массив;
- скорректирована генерация кода для модификатора %size при применении
  к коллекциям скалярных типов;
- реализовано вынесение в процедурный код вызовов прикладных функций
  и стандартных функций sys_context/rtl.user при использовании в
  SQL-запросах путем использования bind-переменных;
- скорректирована генерация описаний внешних типов (типов Oracle и
  таблиц-вьюх Oracle);
- удален лишний вызов cache_mgr.cache_flush после генерации ошибки
  пакетом message;
- скорректирован вызов расширений операций-деструкторов;
- убран атрибут final при описании пользовательских типов-структур,
  чтобы была возможность переопределения таких структур через subtype;
- реализована опциональная генерация процедуры initialize для
  режима генерации java-кода с method_id='RTL' (без генерации описания
  объемлющего класса);
- реализована опциональная проверка уникальности импортируемых объектов
  процедурой plp2java.get_imports, чтобы устранить дублирование при
  соединении нескольких фрагментов java-кода;
- скорректирована диагностика ошибки при использовании pipelined функций.

2.3. Реализована поддержка запуска заданий dbms_scheduler:
  - реализована аутотентификация заданий dbms_scheduler
    в пакете rtl;
  - реализован новый тип заданий (SCHEDULER) в ТБП "Выполнение
    заданий по расписанию" (SYSTEM_JOBS).

2.4. В пакете constant декларированы индексированные по строке
массивы скалярных типов. Соответственно, реализовано автоматическое
переопределение типов для index by string таблиц:
TYPE name IS TABLE OF REF[class]       index by string <-->  CONSTANT.NUMBER_TABLE_S
TYPE name IS TABLE OF [class_ARR]      index by string <-->  CONSTANT.NUMBER_TABLE_S
TYPE name IS TABLE OF REF[kernelclass] index by string <-->  CONSTANT.REFSTRING_TABLE_S
TYPE name IS TABLE OF STRING{(size)}   index by string <-->  CONSTANT.STRING_TABLE_S
TYPE name IS TABLE OF MEMO             index by string <-->  CONSTANT.STRING_TABLE_S
TYPE name IS TABLE OF REFSTRING        index by string <-->  CONSTANT.REFSTRING_TABLE_S
TYPE name IS TABLE OF BOOLSTRING       index by string <-->  CONSTANT.BOOLSTRING_TABLE_S
TYPE name IS TABLE OF BOOLEAN          index by string <-->  CONSTANT.BOOLEAN_TABLE_S
TYPE name IS TABLE OF DATE             index by string <-->  CONSTANT.DATE_TABLE_S
TYPE name IS TABLE OF NUMBER{(sz{,pr})}index by string <-->  CONSTANT.NUMBER_TABLE_S
TYPE name IS TABLE OF INTEGER          index by string <-->  CONSTANT.INTEGER_TABLE_S
TYPE name IS TABLE OF INTEGER     index by string(512) <-->  CONSTANT.INDEX_TABLE_S


          3. Разное.

3.1. Произведен рефакторинг пакетов препроцессора PL/Plus:
  - пакеты plp$parser и plp$scanner объединены в plp$parser;
  - пакеты plib и plp$check объединены в plib;
  - пакеты plp2plsql и plp$cursor объединены в plp2plsql;
  - пакеты plp2java и p2j$sql объединены в plp2java;
  - произведена перенумерация ряда стандартных функций в словарях
    rtl_entries/rtl_parameters в связи с добавлением поддержки
    работы со вложенными массивами (см.пп.1.1-1.3).

3.2. Произведен рефакторинг интерфейсных пакетов типов:
  - реализованы именованные функции для получения и установки
    значений реквизитов экземпляров (для всех скалярных реквизитов
    get/set функциям присваиваются имена g#<attr_id>/s#<attr_id>,
    для структурных реквизитов публикуются только функции для
    не вложенных структур get/set - g$<attr_id>/s$<attr_id>);
  - реализована процедура set$value для установки значений
    скалярных реквизитов по переданному строкой квалификатору
    реквизита (аналог get$value, которая считывает значения);
  - реализовано использование мягкого режима инициализации
    интерфейсных пакетов типов в случае наличия в типе собственных
    архивных реквизитов (и как следствие,триггера архивирования).

3.3. Реализован новый режим кэширования для одного экземпляра
в интерфейсных пакетах типов (кэширование горячего экземпляра).
Этот режим задается значением -1 для колонки cached в таблице
class_tables. Новый режим характеризуется следующими свойствами:
  - кэшируется один экземпляр, к которому было произведено
    последнее обращение;
  - при обращении к другому экземпляру, экземпляр в кэше
    заполняется реквизитами нового экземпляра;
  - статический экземпляр (если есть) кэшируется отдельно;
  - кэшируемый экземпляр существует на протяжении транзакции,
    по командам завершения-отката транзакции кэш сбрасывается
    (по commit/rollback, точнее, сброс кэша производится процедурами
    cache_mgr.cache_commit/cache_mgr.cache_rollback);
  - при модификации экземпляра рассылки событий не происходит
    (это не требуется, т.к. кэш живет только в течение транзакции,
    так что другие сессии сделанные изменения увидят по завершении
    своих транзакций после выполнения commit/rollback).
  Данный режим может быть эффективен для типов, работа с экземплярами
в которых построена на многочисленных (в течение транзакции) обращениях
к одному экземпляру (например, проводка документа).

3.4. Реализован глобальный контекст доступа <Owner>_RIGHTS.
Т.е. бывший локальный контекст доступа, управляемый пакетом
executor, преобразован в глобальный и теперь управляется пакетом
secadmin. Признаком заполнения контекста, по-прежнему, является
системная настройка RIGTHS_CONTEXT (в settings).
  В таблицу users добавлена новая колонка userid, которая задает
некий уникальный для субъектов доступа идентификатор (т.е. добавлен
синтетический ID). При создании новых субъектов (пользователей или
групп доступа) счетчик для userid инкрементируется и автоматически
присваивается вновь созданному субъекту доступа. При инициализации
пользовательских сессий значение userid прописывается в системный
контекст <OWNER>_SYSTEM c атрибутом 'UID'.
Изменен формат хранения данных в контексте, новый формат таков:
  namespace = <Owner>_RIGHTS,
  attribute = <USERID>.<Class_ID/Criteria_ID>
  value = 1
Наличие записи в контексте означает наличие прав на
тип или представление у субъекта с заданным USERID,
отсутствие записи означает и отсутствие прав.
Автоматическая генерация условия проверки прав в представлениях,
использующих контекст доступа, соответствующим образом изменена.

3.5. Реализована возможность объединения основной операции и ее
расширения в один PL/SQL пакет.
  Основные преимущества объединения операций в один пакет:
  - устраняется неопределенность с глобальными переменными пакетов
    основной операции и расширения - они теперь находятся в одном
    пакете;
  - устраняется разрыв в отслеживании состояния кэша экземпляра
    this (в разных пакетах используется свой кэш в каждом пакете;
    в едином пакете, кэш тоже един);
  - отсутствие лишних взаимозависимостей пакетов и межпакетных
    вызовов.
  Объединение пакетов реализовано следующим образом:
  - глобальные описания базовой операции и расширения объединяются
    как есть;
  - к глобальным описаниям добавляется список глобальных переменных
    расширения (по определению расширения этот список в себя включает
    все глобальные переменные базовой операции);
  - локальные описания базовой операции и расширения объединяются
    как есть;
  - тексты VALIDATE и EXECUTE формируются на основе текста расширения,
    в которых код VALIDATE и EXECUTE базовой операции оформляются
    в виде вложенных процедур/функций с именами BASE$VALIDATE и
    BASE$EXECUTE, соответственно;
  - имя общего пакета формируется по имени базовой операции, в который
    включаются все объединенные глобальные описания, а также процедуры
    и функции VALIDATE/EXECUTE, сформированные по именам как расширения,
    так и базовой операции (которые реализованы перевызовом VALIDATE/EXECUTE
    расширения);
  - т.о. все операции, вызывающие базовую операцию или ее расширение,
    перенаправляются на один пакет.
  Возможная проблема при таком объединении - использование одинаковых
имен переменных/функций/процедур в глобальных и локальных описаниях
базовой операции и расширения.
  Для расширений, у которых не создается собственный пакет (т.е.
создается общий пакет с именем базовой операции) в поле methods.package_name
записывается пустое значение.
  В функцию создания расширений method_mgr.set_extension добавлен
умолчательный параметр p_standalone (тип varchar2 default null),
управляющий режимом генерации расширений при указании следующих значений:
  - 'Y','1' - для расширения создается собственный пакет (режим
              создания расширений от прежних версий ТЯ);
  - другое непустое значение - собственный пакет для расширения не
              создается, создается один пакет по имени базовой операции;
  - пустое значение (значение по умолчанию) - режим создания определяется
              системной настройкой PLP_STANDALONE_EXTENSION.
  Системная настройка PLP_STANDALONE_EXTENSION (в settings) определяет
режим создания расширений по умолчанию:
  - 'Y','1', пустое значение - для расширения создается собственный пакет;
  - другое значение - создается единый пакет по имени базовой операции.

3.6. Принципиально изменен алгоритм аутотентификации сессий пользователей.
Эта функция вынесена из-под контроля сервиса lock_info и возложена на саму
регистрирующуюся сессию. Информация о регистрации сессий вынесена из памяти
выделенного процесса и теперь размещается в специально созданном
для этого глобальном контексте <OWNER>_USERS, управляемом пакетом rtl
(т.е. стала разделяемым ресурсом). Эта же информация дублируется и в таблице
rtl_users, которая необходима как в плане совместимости с предыдущими
версиями, так и для опций RAC (Real Application Cluster) и ADG (Active
Data Guard - Physical ReadOnly Standby), т.к. информация в контексте
доступна только на своем узле.

3.7. Оптимизирована работа среды времени исполнения:
  - реализовано подавление обработки событий при инициализации
    3L-сессий;
  - доработан алгоритм удаления неиспользуемых пайп
    при обновлении списка сессий сервисом lock_info (при
    снятии регистрации с пропавших/удаленных сессий);
  - реализовано сохранение/считывание состояния
    сервиса lock_info при инициализации сессий;
  - реализована автоочистка серверных пайп сервиса
    lock_info для standby-сервера при неактивном сервисе;
  - оптимизированы запросы по обработке событий в типе
    "Системные события" (SYS_EVENTS).

3.8. Свойства операций HOTKEY/DEFHOTKEY переведены в разряд
особых свойств (CORECORE-46).

----------------------------------------------------------------------
Изменения на 20.09.2010. - версия 7.1 (build 1 Revision 0).

        2. Семантика.

2.1. Реализован алгоритм по связыванию спецификаций (forward declarations)
функций и процедур с их фактическими реализациями (implementations),
что позволяет диагностировать наличие-отсутствие подходящих
соответствий спецификаций и реализаций. Реализовано два уровня
соответствий - точное и похожее, при этом java-компилятор
переименовывает функции, имеющие похожие спецификации, т.к. такие
функции в коде java становятся неразличимыми.

2.2. Реализована фактическая типизация модификатора %ID, т.е. для
системных типов (метаклассов) и для типов, в которых определен
ключевой реквизит, модификатор %ID возвращает строку (длиной 128),
для остальных типов %ID возвращает число. В прежних версиях ТЯ
модификатор %ID позиционировался как возвращающий всегда строку,
т.к. фактический числовой тип всегда приводим к строке на уровне
неявного преобразования.

2.3. Реализован новый алгоритм подбора вызовов перекрытых функций
по типам значений, переданных фактическими параметрами, введены
дополнительные уровни при анализе несовместимости параметров
по типам; реализовано предупреждение при наличии нескольких
возможных вызовов функций, подходящих по заданным значениям
параметров (см. plphints.txt п.1.10).

2.4. Реализована расширенная диагностика ошибок компиляции:
  a) ошибки разыменования коллекций в процедурном коде,
  b) ошибки использования модификаторов для коллекций в процедурном коде
     (кроме модификаторов, предназначенных специально для коллекций),
  c) ошибки использования реквизита ID без префикса переменной (которое
     эквивалентно обращению к реквизиту ID типа OBJECT),
  d) ошибки использования модификатора %ID к скалярным значениям
    (кроме ссылок).
                Пример:
        declare
          a [PR_CRED_ARR];
          s string;
        begin
          s := a.[NUM_DOG]; -- ошибка a)
          s := a%id;        -- ошибка b)
          s := [id];        -- ошибка c)
          s := s%id;        -- ошибка d)
        end;

2.5. Реализована возможность использования функции rtl.get_parent
с переопределением типа ссылки, для которой вызывается эта функция.
Вызов функции rtl.get_parent оправдан, если требуется единовременно
получить расширенную информацию о родительском экземпляре, а именно -
значение ссылки и ее тип (по отдельности эту информацию возвращают
модификаторы %parent и %parentclass, соответственно).
Переопределяемый тип задается строкой-константой, передаваемой вторым
параметром в функцию get_parent (первым параметром передается
коллекция, для которой требуется найти родительский экземпляр):
                Пример:
        declare
          a [PR_CRED_ARR];
          o [OBJECT];
        begin
          o := get_parent(a);
          o := get_parent(a,'OVERDRAFTS'); --переопределение типа
        end;
                Преобразуется так:
        declare
          A number;
          O RTL.OBJECT_REC;
	begin
          O := Z#PR_CRED#INTERFACE.get_parent(A);
          O := Z#OVERDRAFTS#INTERFACE.get_parent(A);
        end;


2.6. Общие доработки компилятора:
- реализовано разворачивание синонимов до объектов, на которые
  они указывают;
- оптимизирована генерация арифметических, строковых и
  логических выражений с использованием null значений;
- реализован расширенный анализ выражений, использующих методы
  последовательностей, в sql-операторе insert на предмет повторения
  использования одних и тех же последовательностей;
- усовершенствован механизм синхронизации состояния кэша this
  в операциях при сведении разных исполняемых блоков в один;
- усовершенствована процедура анализа сигнатур глобальных
  функций и процедур операций (уточнена сортировка для перекрытых
  функций).

2.7. Доработки Java-компилятора:
- реализована поддержка автономных транзакций в java;
- реализована поддержка конструкции execute immediate c использованием
  out-параметров;
- реализовано позиционное связывание значений для execute immediate
  и использование ScrollableResults для select-выражений;
- реализована поддержка returning clause SQL-операторов insert/update/delete,
  включая конструкцию execute immediate и массивы-приемники (bulk collect);
- реализована поддержка forall clause indices of/values of
  SQL-операторов insert/update/delete;
- реализовано исключение из java-кода неиспользуемых функций, процедур,
  статических курсоров;
- реализована генерация спецификации процедур и функций в java, описанных
  как глобальные, в случае отсутствия фактической реализации (implementation)
  этих процедур и функций;
- реализованы case-выражения в java;
- реализована поддержка методов вложенных массивов и ссылочных курсоров;
- реализована поддержка связывания вложенных массивов, используемых
  в SQL-запросах;
- реализована замена вложенных массивов скалярных типов на runtime типы;
- реализован оператор insert в коллекцию скалярных значений (как правило,
  ссылок);
- реализована поддержка оператора insert для массивов и
  структуры rowtable;
- реализована поддержка триггерных операций и операций функциональных
  реквизитов;
- реализована поддержка ссылочных курсоров через тип ScrollableResults,
  в т.ч. и как полей составных типов;
- реализовано приведение типа integer к ссылке с помощью cast_to;
- реализован разный системный код для простых и сложных конструкторов;
- доработано определение типов выражений, теперь конструктор всегда
  возвращает ссылку;
- реализовано присвоение значений элементам массивов, передаваемым
  out-параметрами в функции и процедуры;
- реализована инициализация системных реквизитов структур как приемников
  конструкции select into, реализовано корректное присвоение элементам
  массивов, используемым как приемники;
- реализовано развертывание по полям оператора присвоения структур,
  описанных как статические курсоры;
- реализовано комментирование pl/sql вставок в описаниях;
- реализована генерация исключений по неподдерживаемым исполняемым
  конструкциям в java: pl/sql вставки, операторы goto, exit на метку;
- реализован алгоритм преобразования оператора exit на метку на простой
  exit, если точка выхода определена для текущего цикла;
- реализовано сохранение экземпляра this в сложном конструкторе
  при его использовании в sql запросах;
- реализовано копирование значений out-параметров в локальные
  переменные функций и процедур;
- реализовано разыменование модификаторов для обобщенной ссылки
  (reference);
- доработаны алгоритмы преобразований конструкций update/delete по ссылке -
  добавлены анализ на развертывание ссылок и преобразование логических
  значений;
- скорректирована генерация временных переменных счетных циклов (for),
  реализовано использование буферных переменных для сложных выражений,
  в т.ч. для методов массивов;
- расширен список зарезервированных слов при использовании
  в java и оптимизирован алгоритм переименования типов и
  реквизитов при совпадении с зарезервированными словами;
- реализовано приведение типов полей структур в конструкции
  select into, убрано ограничение 32k при генерации списка
  приемников (into) в случае большого количества полей
  структур-приемников;
- реализовано вынесение объявлений временных переменных, используемых
  в конструкциии поиска по логическому условию, в основной блок описаний
  текущего исполняемого блока;
- реализована корректная генерация блока обработки исключений при
  использовании команд условной компиляции;
- реализована корректная генерация связывания переменных, используемых в
  запросах, основанных на описанных ранее статических курсорах;
- реализована поддержка модификаторов %request, %getcollection, %compare,
  архивных модификаторов %arch;
- реализована генерация кода для синхронизации используемых типов
  в sql-выражениях с кэшем экземпляров на сервере приложений -
  при использовании %size, а также по реквизитам-ссылкам в SQL-операторах
  insert/update;
- реализованы заглушки для процедур пакета cache_mgr, имеющих
  java-реализацию (cache_flush, cache_clear);
- реализовано создание нового объекта при приведении ссылки
  вверх по иерархии в случае передачи такой ссылки параметром
  в другие процедуры или функции;
- реализован вызов функции сброса кэша экземпляров (cache_flush)
  сервера приложений при использовании в коде обработчиков
  исключений проверки целостности данных (с номерами ошибок
  -1, -2290 - -2294).


        3. Разное.

3.1. Доработки схемы Хранения:
- скорректирована генерация процедуры change_state (смены
  состояния) в интерфейсных пакетах типах, исключающая
  вероятность анализа неконсистентного состояния экземпляра;
- скорректирована диагностика ошибки дублирования имен колонок
  для разных реквизитов при выполнении хранения в типах;
- реализован вывод полного стека ошибок при выполнении хранения
  в типах;
- реализован новый алгоритм инициализации статического
  экземпляра в интерфейсных пакетах типов, исключающий
  возможность возникновения ошибки мутирующей таблицы
  во время выполнения триггера удаления данных;
- оптимизировано создание интерфейсных пакетов операций,
  теперь спецификация пакета и грант не пересоздаются, если
  они уже существуют в актуальном состоянии; реализовано
  подавление ошибки получения умолчательных значений по
  ссылке в процедуре журналирования параметров и переменных
  операций.

3.2. Доработки среды времени исполнения (Runtime):
- реализован новый механизм регистрации 3L сессий на стороне
  клиента, позволяющий существенно снизить нагрузку на процесс
  LOCK_INFO;
- реализована возможность регистрации пользовательских событий для
  адресной рассылки в пакете cache_mgr, реализована возможность
  указания списка исключений при получении информации о списке
  зарегистрированных сессий процедурой rtl.get_user_list и при
  формировании списка рассылки с помощью rtl.send_events
  (см. plphints.txt п.5.17);
- реализована процедура utils.errors_stack, возвращающая полный
  стек ошибки на момент ее возникновения;
- реализован режим запрета выполнения команд управления
  транзакциями commit/rollback (в пакете cache_mgr), новый
  режим используется при записи-воспроизведении тестов;
- реализован новый алгоритм авторасширения пайп в пакете stdio,
  обходящий существующую проблему во вьюхе sys.v$db_pipes (Oracle10g);
- скорректирован алгоритм проверки изменения кэшируемых
  колонок таблиц типов процедурой valmgr.check_cached;
- реализовано получение событий, посланных собственной сессии,
  сразу после выполнения рассылки;
- реализована возможность запуска отчетов Администратора доступа,
  Ревизора, Администратора персональных данных через сервер отчетов;
- реализованы сокращение стека вызова при генерации исключений
  пакетом message и включение полного стека вызовов при генерации
  исключений процедурой error_repeat, если последняя вызвана из
  обработчика исключений, в частности, теперь выводится полный
  стек ошибки при выполнении переходов при смене состояний экземпляров;
- убраны пароли у стандартных ролей пользователей IBSO.

3.3. Реализована системная настройка PLP_DEF_TARGET (в settings),
управляющая умолчательным режимом компиляции операций, возможные значения:
  0, отсутствие настройки - генерация PL/SQL-кода операций,
  1 - генерация одновременно PL/SQL-кода и JAVA-кода операций,
  2 - генерация JAVA-кода операций.

----------------------------------------------------------------------
Изменения на 15.03.2010. - версия 7.1 (build 1 Revision 0).

        1. Синтаксис.

1.1. Реализованы синтаксис и семантический разбор конструкции
execute immediate.
Синтаксис соответствует SQL-синтаксису:
   a) выполнение анонимного PL/SQL блока:
      EXECUTE IMMEDIATE expr
	{USING {/in  out  in out/} bind1,  {/in  out  in out/} bind2 ...}
      ;
   b) выполнение динамической выборки (select into):
      EXECUTE IMMEDIATE expr
	{INTO  var1, var2 ...}
	{USING bind1, bind2 ...}
      ;
   c) выполнение динамических DML (insert/update/delete):
      EXECUTE IMMEDIATE expr
	{USING bind1, bind2 ...}
	{RETURN INTO var1,  var2 ...}
      ;
где:
expr - строковое выражение, содержащее SQL команду или PL/SQL код;
bind1, bind2 - выражения для связываемых переменных, используемых в expr
       (для PL/SQL блока могут быть указаны возвращаемые значения путем
       указания направленности bind-переменных - in/out/in out);
var1, var2 - переменные-приемники SQL-выражений типа select into или
       insert/update/delete returning into.

    Конструкция execute immediate приравнена к pl/sql вставке,
так что без крайней необходимости использование этой конструкции
настоятельно не рекомендуется (по тем же причинам, что и pl/sql
вставка, т.к. исполняемый код может перестать соответствовать
состоянию прикладной модели).


        2. Семантика.

2.1. Реализована генерация PL/SQL CASE-оператора из PL/Plus
CASE-оператора (ранее использовался только IF-оператор).

2.2. Скорректирована генерация PL/Plus представлений с использованием
алиасов-ссылок (REF$%).

2.3. Расширен PL/Plus разбор системных пакетов и типов Oracle.
Стало допустимым обращение к системным типам Oracle через префикс
схемы SYS.

2.4. Реализована возможность использования вычисляемых
констант системных пакетов (например, CONSTANT) в PL/Plus
представлениях.

2.5. Реализована совместимость строк и логики (boolean) в sql-выражениях
PL/Plus. Скорректировано приведение логических значений в логические
выражения SQL.

2.6. Реализовано преобразование выражения для списка IN
в выражение сравнения в случае, когда список состоит из
единственного значения.

2.7. Скорректировано описание системных функций в словарях
rtl_entries/rtl_parameters:
- sqlerrm - возвращаемое значение увеличено до 2000;
- to_date/to_number задан тип первого параметра как строковый (ранее был
  нетипизованный, так что использовалось неявное приведение к строке
  на уровне Oracle, что в случае с to_date было чувствительным к nls-
  настройкам сессии и могло приводить к непредсказуемым результатам
  при применении to_date к типу date, в новой версии ТЯ в этом случае
  используется явный формат, задаваемый в вызове to_date, и выдается
  предупреждение);
- функции пакета standard приведены в соответствии с версии Oracle 10.
- реализованы разные описания rtl_entries/rtl_parameters
  функций round/trunc для чисел и дат в соответствии с sql-описаниями.

2.8. Скорректирована генерация вложенных функций и процедур
в глобальных описаниях (вложенные функции и процедуры не включаются
в спецификацию пакета операции).

2.9. Скорректирована генерация кода валидатора сложного конструктора
в режиме редактирования (признак проверки создания экземпляра plp$check$
в этом случае не сбрасывается).

2.10. Реализован анализ условия where update/delete конструкций,
в случае условия по единственной ссылке, реализовано обновление
кэша только для этой ссылки, а не полный сброс кэша.

2.11. В PL/Plus добавлена новая псевдо-функция GOWNER, возвращающая
строковую константу с именем глобального владельца схемы IBSO
(inst_info.gowner, см.п.3.2 изменений версии 7.1 от 30.04.2009).
Доработана библиотека [SYS_DIARYS]::[DLIB] по управлению последовательностями
(обращение к ним через указание префикса схемы <GOWNER>).
Усовершенствован разбор выражения для вычисления следующего
момента запуска в операции [SYSTEM_JOBS]::[SET_INTERVAL]
через использование библиотеки [RUNTIME]::[CALC].

2.12. В PL/Plus реализована дополнительная оптимизация генерируемого
кода при вычислении выражений с использованием пустых значений (null)
в логических и арифметических выражениях.


        3. Разное.

3.1. Доработаны процедуры хранения типов.

    Реализована дополнительная возможность генерации триггеров поддержки
целостности для секционированных с использованием умолчательных
значений ключей архивации. При включении общего режима использования
архивов (с помощью процедуры valmgr.switch_archiving - см.п.3.3
изменений версии 7.0 от 30.03.2008) генерация триггеров поддержки
целостности будет осуществляться с использованием ключей архивации,
т.е. настройка ACTUAL_PARTITIONS воздействует также на процедуры:
  - storage_utils.create_refcing_triggers (создание триггеров по ссылкам);
  - storage_utils.create_refced_triggers (создание триггеров по обратным ссылкам);
  - storage_utils.create_triggers (обе процедуры в одной).

    Расширен размер колонки для типа RAW с 255 до 2000.

    Оптимизированы запросы при генерации описаний структур типов
в интерфейсных пакетах типов, расширено использование кэшируемой
информации.

    Реализованы преобразования datetime/interval типов в строки
и числа и между собой при выполнении хранения в типах.

    Реализовано опциональное создание индексов в режиме
ONLINE (без блокировки таблицы, по которой строится индекс).
Режим управляется системной настройкой STORAGE_FORCE_ONLINE
(в settings).

    Процедура анализа таблиц и индексов осуществляет сбор
статистики только через пакет dbms_stats (команда analyze
более не используется). Настройка хранения ANALYZE_OPTION
(словарь storage_parameters) может содержать дополнительные
опции для сбора статистики используемые dbms_stats.


3.2. Расширен интерфейс пакета utils для управления трассировкой
в сессиях. Добавлена возможность параметрически трассировать
ожидания и значения bind-переменных. Расширен функционал
системного ТБП "Статистика" (RUN_SESSIONS). Добавлена возможность
включения sql-трассировки Oracle при выполнении операций и выборок
из пользовательских представлений. Этот признак устанавливается
в справочнике "[RS] Отслеживаемые действия при сборе статистики"
(RUN_STAT_KIND).

3.3. Реализовано журналирование выборок из пользовательских
представлений. Данные о запуске представлений со всеми используемыми
фильтрами и значениями bind-переменных помещаются в журнал
"Запуска операций со значениями параметров".

3.4. Расширены и оптимизированы механизмы кэширования метамодели
в пакете LIB (используемом в общем runtime и препроцессоре PL/Plus):
- расширено количество кэшируемых полей classes/class_tables/class_attributes;
- добавлено кэширование иерархии типов (class_relations);
- добавлено кэширование умолчательных реквизитов в типах;
- добавлено кэширование описаний полей структур и колонок таблиц
  типов (class_tab_columns, class_rec_fields);
- кэш пакета valmgr (флаги, начальные состояния, операции инициализации
  типов) заменен на кэш пакета lib.

3.5. Реализована генерация javа-кода препроцессором PL/Plus.
Реализованы дополнительные структуры и данные и более тесное
взаимодействие кодогенераторов PL/SQL и JAVA. Произведен
серьезный рефакторинг процедур семантического разбора
и кодогенератора:
  - генерация кода SQL сделана общей для обоих кодогенераторов;
  - реализована более строгая проверка типов и их приведение для
    кодогенератора java;
  - реализовано удаление неиспользуемого кода операций на этапе
    семантического разбора;
  - реализованы проверка уникальности имен и переименование идентификаторов
    по правилам java;
  - реализован анализ update/delete конструкций и их преобразование
    в block-конструкцию установки значений реквизитов/удаления
    по ссылке в случае условия по единственной ссылке, реализовано
    дополнительное приведение типов для boolean-реквизитов;
  - реализовано единое пространство и алгоритмы генерации имен
    используемых временных переменных, в т.ч. для %insert/%locate и
    конструкции поиска по логическому условию;
  - реализована поддержка статических и ссылочных курсоров в java по аналогии
    с PL/SQL (выделение процедурного кода инициализации переменных,
    используемых в курсоре отдельной процедурой класса, где определен курсор);
  - реализована поддержка атрибутов курсоров в java (%found,%isopen,%rowcount...);
  - реализована поддержка перегруженных вызовов функций и процедур
    с умолчательными параметрами в java, реализована отдельная спецификация
    для вызова с указанием именованных параметров;
  - реализована поддержка перекрытых вызовов операций с приведением
    типов для значений параметров-ссылок в java;
  - реализована поддержка перекрытых вызовов операций в java через
    использование параметра plp$class$ (как в PL/SQL);
  - реализована работа с массивами - аналогами pl/sql таблиц в java;
  - расширена структура дерева разбора для хранения информации о типах
    преобразований значений параметров при их неявном приведении (в java
    реализованных явными), реализовано синхронное копирование-удаление этой
    информации при копировании-удалении узлов дерева;
  - реализованы вычисления на этапе компиляции в java и упрощение выражений
    с условиями (if, while, exit when, for where);
  - реализованы вычисления по константе-ссылке (полученной поиском на этапе
    компиляции) в java, реализованы вычисления конструкций вида [CLASS]%class;
  - реализовано приведение ссылок по иерархическому принципу в конструкциях
    с явным и неявным переопределением типа ссылки в java;
  - реализована инициализация значений переменных при их объявлении (в т.ч.
    null) в java;
  - реализована установка системной колонки SU значением из системного
    контекста в java (вместо rtl.uid$);
  - реализована однократная инициализация вложенных java-классов для
    локальных функций и процедур;
  - реализована замена вызовов операций через синонимы на вызовы самих
    операций в java;
  - реализовано приведение типа для %ID в java (число/строка);
  - реализовано преобразование оператора множественного присваивания в
    последовательность простых присваиваний для java.

3.6. Реализован новый сервис Lock_Info по определению владельца
физической блокировки экземпляра при блокировке посредством модификатора
%lock. В связи с переходом на новую версию логических блокировок форм
операций (см.п.3.1 изменений версии 7.0 от 1.12.2007) этот сервис
в новой схеме был практически отключен, т.к. информация могла извлекаться
только из таблицы frm_locks, при этом не было никакой гарантии, что даже
найденная логическая блокировка в frm_locks соответствовала удерживаемой
физической.
    Новый сервис реализован по принципу поиска сессии-владельца
транзакции, удерживающей физическую блокировку экземпляра. Поэтому
если эту информацию удается извлечь, то она совершенно точно и адекватно
определяет владельца физической блокировки (более подробно см. описание
lockinfo.txt).

3.7. Расширен интерфейс пакета DBF для работы с мемо-полями.
более подробно см. описание dbf.txt).

3.8. Реализовано сохранение частотной характеристики использования
типов, реквизитов, операций, глобальных функций и процедур операций
в зависимостях операций и преставлений (таблица dependencies,
колонка refs_count).

3.9. Скорректирована проверка списка кэшированных колонок
для PL/Plus оператора update (valmgr.check_cached).

3.10. Усовершенствованы представления и операции в типе "Системные
журналы" (SYS_DIARYS) для работы со списком сессий. Обработка
пользовательских сессий, соответствующих физическим сессиям Oracle
(v$session), осуществляется путем идентификации по SID, что существенно
эффективнее использования AUDSID.

3.11. Реализован новый алгоритм выполнения операций в режиме
readonly (если экземпляр логически блокирован другим пользователем).
Теперь проверяется не принципиальная "возможность" изменения
данных операцией перед ее запуском, а запрещается фактическое
изменение данных на этапе ее выполнения.

3.12. Расширены настройки адресной рассылки событий обновления
кэша интерфейсных пакетов типов (см.п.3.2 изменений ТЯ 7.0 от 30.03.2008).
При включенной адресной рассылке системная настройка CLS_NO_CACHE_PIPES
задает список типов (через запятую), для которых адресная рассылка
не используется. В этот список рекомендуется включать кэшируемые типы,
которые используются в процедуре пользовательской инициализации сессий
(т.е. эти типы инициализируются для всех пользовательских сессий,
соответственно, им адресная рассылка не нужна), при этом тип SYSTEM
автоматически включен в этот список (его указывать не нужно).

----------------------------------------------------------------------
Изменения на 30.04.2009. - версия 7.1 (build 0 Revision 0).

        1. Синтаксис.

1.1. Добавлена обработка простых CASE-выражений (simple case expressions)
в SQL-конструкциях (см. также п.1.2 изменений на 20.08.2003 - searched
case expressions)
Синтаксис соответствует SQL-синтаксису:
	CASE expr WHEN expr1 THEN expression1
	{WHEN expr2 THEN expression2}
	...
	{WHEN exprN THEN expressionN}
	{ELSE else_expression}
	END
где
	expr - исходное выражение для проверки значений,
	expr1..exprN - значения для сравнения c expr,
	expression1..expressionN - скалярные выражения-результаты при выполнении
		равенства expr c соответствующим заданным выражением в expr1..exprN;
	else_expression - скалярное выражение-результат при невыполнении ни одного
		из условий равенства с expr1..exprN;
    Выражения-результаты должны иметь один и тот же тип. Выражения для сравнения
    expr1..exprN должны иметь тот же тип, что и исходное выражение expr.
    Case-выражения допустимы только в операторах FOR/LOCATE/SELECT/UPDATE/DELETE/%LOCATE.
    При отсутствии конструкции ELSE результирующее значение Case-выражения
    при несовпадении ни с одним из заданных значений будет пустым.
    В отличие от Searched Case выражения, Simple Case выражение может быть
    индексировано.

1.2. Добавлен новый разделитель алиасов источников данных и выбираемых
значений - пробел (ранее был только ':'):
                Пример:
          for( select x(
                x.[name] : name, -- разделитель ':'
                x.[username] username, -- разделитель ' '
                y.[name] yname,
                z.[name] zname
               ) in [USER],
                   ([USER] : y), -- разделитель ':'
                   ([USER]   z)  -- разделитель ' '
                 where x=stdlib.user_id and y=x and z=x
          ) loop
            exit;
          end loop;


        2. Семантика.

2.1.  В язык PL/Plus добавлены новые модификаторы (см.п.3.1):
%ses - возвращает значение ID сессии, внесшей последние
       изменения в таблицу типа (т.е. значение колонки SU);
%orascn - возвращает значение псевдоколонки ORA_ROWSCN
       для версий Oracle 10g и выше.
Указанные модификаторы могут использоваться только в
SQL выражениях PL/Plus. Применяются по ссылке.
                Пример:
          for (select x(x%id id,x%scn sn,x%orascn scn,x%ses ses) in [USER])
          loop
            exit;
          end loop;


2.2. Оптимизирована обработка перекрытых вызовов операций
из расширений, устраняющая возможность бесконечной рекурсии.
Реализована поддержка перекрытых вызовов валидаторов операций.

2.3. Доработана процедура разбора описаний timestamp/interval
типов в PL/Plus, что позволяет парсить большее количество системных
пакетов, в частности dbms_scheduler.

2.4. Добавлен новый модификатор %compare для сравнения структур
типов (см.п.3.27). Применяется к структуре типа, принимает
следующие параметры:
  - структуру типа для сравнения, обязательный параметр;
  - признак сравнения автоматических реквизитов (логическое значение),
    параметр не обязательный, при значении true (по умолчанию) автоматические
    реквизиты (коллекции и автонумеруемые реквизиты, значения которых
    инициируются из последовательностей) сравниваются, иначе не сравниваются;
  - признак поиска различий по иерархии типов (логическое значение),
    параметр не обязательный, при значении true реквизиты родительского
    типа проверяются независимо от проверки собственных реквизитов,
    при значении false проверяются только собственные реквизиты,
    при значении null (по умолчанию) проверка производится до первого
    найденного различия (сначала проверяются собственные реквизиты,
    затем родительские).
Модификатор возвращает целочисленное значение:
  - значение 0 означает полное совпадение значений полей сравниваемых структур
    (структуры, к которой применен модификатор и структуры, переданной параметром);
  - ненулевое значение интерпретируется побитно следующим образом:
    - 1 бит установлен (значения 1 и 3) - существуют различия в собственных
      реквизитах;
    - 2 бит установлен (значения 2 и 3) - существуют различия в родительских
      реквизитах.
Скалярные поля структур сравниваются следующим образом:
  - если соответствующие поля структур пустые, то поля считаются равными;
  - если сравниваемые поля не пустые, то сравниваются значения полей;
  - если одно из полей пустое, а другое не пустое, то поля считаются различными;
  - структуры считаются различными, если есть различия хотя бы по одному полю
    (в соответствии с заданными дополнительными опциями сравнениЯ).
                Пример:
        declare
          x [USER];
          y [USER];
        begin
          ...
          if x%compare(y)<>0 then -- структуры различны
            null;
          end if;
          ...
        end;

2.5. Скорректировано предупреждение в PL/Plus представлениях
при разыменовании коллекций.


2.6. Реализована возможность при вызове простых операций
указывать параметром фактический тип ссылки, для которой
вызывается операция. Выражение для фактического значения
типа ссылки можно указать первым параметром  с явным указанием
имени параметра PLP$CLASS. Выражение должно возвращать
строковое значение реально существущего типа, находящегося
в иерархии типа, которому принадлежит операция. В случае
специальных вызовов перекрытых операций и конструкторов
(см.plphints.txt п.1.15), а также при вызове по ссылке
this, заданное выражение игнорируется. Новый режим удобен
в случае вызова перекрытых операций в дочерних типах
по ссылке на родительский тип, что позволяет в случае
многочисленных вызовов экономить на запросах по определению
типа ссылки в вызываемых операциях.
                Пример:
        declare
          d ref [DOCUMENT];
          c string(16);
        begin
          ...
          c := d%class;
          -- вызов с указанием фактического значения типа документа
          d->[DOC_TO_PROV]( plp$class == c , true );
          ...
        end;



        3. Разное.

3.1. Реализован новый механизм отслеживания авторства
изменений прикладных данных в процедурах контроля изменений
экземпляров. Этот механизм расширяет функционал отслеживания
логических блокировок форм операций (FRM_LOCKS), описанный
в п.3.1 изменений версии 7.0 от 1.12.2007..

  В таблицу FRM_LOCKS и структуру LOCKS_INFO добавлено поле
EINFO, которое для логических блокировок форм операций
заполняется информацией об индентификаторах пользовательских
сессий, внесших последние изменения в таблицы типов.
Для обычных логических блокировок поле EINFO не заполняется.

  В таблицы типов добавляется колонка SU, в которую
заносится идентификатор сессии пользователя, изменяющего
данные в таблице. Во все автогенерируемые конструкции
модификации прикладных данных автоматически добавляется
код, модифицирующий колонку SU.

  Отключен режим получения SCN записи через псевдостолбец
ORA_ROWSCN, т.о. для этих целей всегда используется колонка
SN, которая добавляется в случае ее отсутствия.

  При работе форм простых операций, имеющих признак проверки
изменения экземпляра, производится контроль как самих
изменений, так и их авторства. В случае модификации
данных собственной сессией ошибка типа "Экземпляр был
изменен..." не генерируется.

  Реализовано отслеживание принадлежности к типам при
установке логических блокировок форм списком.


3.2. Реализована возможность разделения схем хранения данных
прикладных таблиц и метаданных словаря IBSO. Реализованы
новые режимы перестроения таблиц с переносом данных из
одной схемы хранения в другую. Реализованы следующие
схемы хранения (по именам констант пакета INST_INFO):
GOWNER - глобальный пользователь, который определяет
         общую идентификацию схем IBSO для конечных
         пользователей, в схемах аудита, менеджера
         аудита и других;
OWNER  - схема хранения метаданных (таблиц словаря
         IBSO), хранимых процедур и триггеров как
         самого ТЯ, так и ФЯ (функционального ядра,
         генерируемых процедурами ТЯ);
DOWNER1- схема хранения прикладных данных (таблиц и
         индексов);
DOWNER2- дополнительная схема хранения прикладных данных
         (таблиц и индексов).

  Реализован новый механизм модификации данных в прикладных
таблицах при смене типа колонки без использования промежуточной
таблицы (см.п.3.9). Модификация производится путем добавления
новой колонки, в которую данные конвертируются, после чего
старая колонка удаляется, а новая переименовывается.

  Реализована конвертация данных системных таблиц LRAW,
LONG_DATA, ORSA_JOBS_OUT из LONG RAW в BLOB. Реализован
программный интерфейс для работы с BLOB в пакетах ТЯ.
Реализованы также триггеры конвертации данных при модификации
старых колонок с LONG RAW (для поддержки совместимости с
предыдущими версиями ТЯ).

  Оптимизирован ряд запросов по словарю Oracle, использующих
DBA_INDEXES, DBA_IND_COLUMNS, DBA_CONSTRAINTS, DBA_CONS_COLUMNS.
Cозданы новые специализированные представления - DBA_CONTRAINTS_1,
DBA_CONS_COLUMNS_1.

  Реализованы специальные роли для сервера проиложений -
<Owner>_APPSRV и <Owner>_APPADM.


3.3. Доработан механизм кэширования экземпляров в интерфейсных
пакетах типов, реализована синхронизация кэшей в дочерних типах
при изменении родительских реквизитов.

3.4. Реализован универсальный модуль агента очереди заданий
RUNPROC для большинства серверных платформ.
Скорректирована поддержка очереди заданий RUNPROC в
типе SYSTEM_JOBS. Добавлены новые системные настройки
JOBS_DEFAULT_QUEUE, JOBS_MAX_FAILURES, JOBS_RUNPROC_USER.

3.5. Реализован новый механизм инициализации сессий для
отчетов (alter session set current_schema...), который
позволяет отказаться от создания синонимов для отчетов.
Новый режим инициализации сессий пользователей управляется
в разрезе профилей пользователей настройкой 'CREATE_SYNONYMS'.
Возможные значения настройки:
  YES - синонимы создаются по существующим зависимостям отчетов,
  NO, отсутствие настройки - синонимы не создаются, при инициализации
      сессий выполняется alter session set current_schema=<Owner>
Настройка подчиняется принципу наследования, т.е. если в собственном
профиле пользователя настройка отсуствует, то она берется из
профиля DEFAULT.

3.6. Добавлена проверка стека в процедуру class_mgr.skip_changes.
Теперь вызов этой процедуры вне системных пакетов запрещен.

3.7. Добавлена настройка CLS_USE_CACHE_PIPES, управляющая механизмом
рассылки событий обновления кэша интерфейсных пакетов типов (см.п.3.2
изменений ТЯ 7.0 от 30.03.2008). При значении YES (используемой по умолчанию),
используется адресная рассылка событий обновления кэша.

3.8. Доработана процедура NAV.CHANGE_STATE_REQUEST, новый вариант
позволяет изменять состояние экземпляров списком.

3.9. Скорректирована процедура инициализации лицензионного контекста
доступа при асинхронной переинициализации.

3.10. Скорректирована процедура конвертации журналов аудита от
старых версий ТЯ (менее 6.3).

3.11. Оптимизирована проверка доступа при вызове списочных
операций.

3.12. В процедуре RULES.SET_OBJECT_RIGHTS реализована возможность
автоматической раздачи прав на вновь созданный экземпляр
его создателю в текущей транзакции (опция NEW).

3.13. Оптимизирована генерация пакетов для правил доступа
(Пакеты создаются только для реально существующих правил,
пустые пакеты не создаются).

3.14. Добавлена условная компиляция в тип "Системные журналы"
в зависимости от наличия-отсутствия реквизита DEPART в типе
USER (используемого в представлениях с фильтрацией по подразделению
пользователя).
Реализован новый функционал по параллельной обработке
событий в типе SYS_EVENTS. Удалены PL/SQL вставки из операции
NEW#AUTO в типе EVENTS.

3.15. Скорректирована генерация функции get_parent (определения
владельца коллекций) в интерфейсных пакетах типов, над которыми
определена временная коллекция, в случае наличия родителя, над
которым определена физическая коллекция.

3.16. Удален синоним diary_rtl и его использование в пакете
rtl. Вместо него использован штатный синоним diary_debug.

3.17. Реализовано подавление рассылки событий при перестроении
таблиц, чтобы избежать возможного сброса состояния интерфейсного
пакета перестраиваемого типа вследствие реструктуризации
перестраиваемой таблицы.

3.18. Добавлен явный параметр p_part_mode в процедуру
dict_mgr.add_partitions добавления архивных секций,
определяющий тип секционирования по следующим значениям:
true  - Oracle partitions;
false - Partition view;
null (по умолчанию) - тип секционирования определяется глобальной
                      настройкой GLOBAL.PARTITION_OPTION в
                      storage_parameters.

3.19. Устранена ошибка при конвертации дублированных колонок
для ссылок при смене их типа с числового на строковый (и наоборот)
при перестроении таблиц.

3.20. Реализовано удаление колонок из таблиц с опцией COMPRESSED
посредством установки признака не используемости (SET UNUSED),
т.к. полное удаление (DROP COLUMN) в таких условиях невозможно.

3.21. Реализовано пересоздание partition view при неполной
конвертации составляющих view таблиц при смене типа ID с
числового на строковый и наоборот.

3.22. Реализовано подавление создания уникального ограничения
целостности при создании уникального функционального индекса.

3.23. При выполнении UPGRADE в режиме перестроения реализована
возможность перенаправления потоков создания системных индексов
в потоки, отличные от потоков перестраиваемых таблиц.

3.24. Реализовано подавление сбора статистики на таблицах
типов при добавлении новых пустых колонок.

3.25. Скорректирована генерация операций-триггеров и операций-
реквизитов в секционированных типах.

3.26. Реализована модификация системных настроек (SETTINGS)
через единый интерфейс пакета STDIO.

3.27. Оптимизировано использование кэша интерфейсных пакетов
типов. При изменении значений кэшируемых скалярных реквизитов
по ссылке производится сравнение со значениями, хранимыми в
кэше, при этом если значение не меняется, то изменения в БД
не вносятся. То же относится к изменению составных реквизитов
и собственной структуры типа. Реализованы новые процедуры
в интерфейсных пакетах типов для сравнения структур (по
составляющим их полям). Оптимизирована генерация кэша THIS
в пакетах операций в кэшируемых типах.

----------------------------------------------------------------------
Изменения на 1.09.2008. - версия 7.0 (build 0 Revision 0).

        2. Семантика.

2.1. Реализован новый модификатор %arch, позволяющий работать
с архивными реквизитами в PL/Plus (см.п.3.1).
Новый модификатор в зависимости от контекста использования реализует
следующие режимы работы с архивами:

2.1.1.  Применение к типу.
  [CLASS]%arch - варианты использования:
  - при описании переменных-параметров - определяет тип структуры
    хранения архивных реквизитов (отображается на тип LIB.ARCHIVE_REC_T);
    рекомендуется использовать именно этот синтаксис в описаниях,
    а не непосредственно тип LIB.ARCHIVE_REC_T, чтобы отражались
    правильные зависимости типов.
  - при использовании в качестве источника данных в SELECT-конструкциях
    PL/Plus (описание курсоров, циклов и пр.); в этом случае выражение
    [CLASS]%arch отображается на архивную таблицу типа [CLASS], по которой
    можно строить любые выборки и условия через переменную-алиас,
    соответствующую источнику в IN-листе конструкции SELECT.
                Пример:
        declare
          type t_history is table of [CLIENT]%arch;
          v_ref ref [CLIENT];
          v_tbl t_history;
        begin
          ...
          select x(x%rowtype) in [CLIENT]%arch
           where x.[ID]=v_ref%id and x.[qual]='NAME' and x.[time]<trunc(sysdate)
           order by x.[time]
            into v_tbl;
          ...
        end;

2.1.2. Применение по ссылке.
  <ref [CLASS]>%arch(p_qual string,p_time timestamp) return [CLASS]%arch
    - поиск архивного значения реквизита с квалификатором p_qual на заданный
      момент времени p_time для экземпляра, по ссылке на который применен
      модификатор. Возвращает заполненную структуру [CLASS]%arch,
      если запись найдена. При этом в поля ID, QUAL, BASE_ID, VALUE
      заносятся значения из записи архива на момент, последующий заданному
      времени в p_time, а поля TIME и USERNAME заполняются из записи
      архива, предшествующей заданному времени p_time (т.е. поля
      TIME и USERNAME относятся к моменту, когда было установлено
      новое значение), если же предшествующей записи не существует,
      то поля TIME и USERNAME остаются пустыми.
      Если запись архива не найдена, то возвращается структура с пустыми
      полями ID, QUAL, BASE_ID, VALUE, поля TIME и USERNAME могут быть
      заполнены в случае, если запись в истории для заданного экземпляра
      и квалификатора существует, но более ранняя, чем заданный в p_time
      момент времени (т.е. USERNAME и TIME отражают время и пользователя
      последнего изменения экземпляра до момента p_time).
    Конструкция отображается на интерфейсную функцию get$arch.
    Конструкция может использоваться только в процедурном коде. При
    использовании в SQL-выражениях без соединения таблиц (без
    джойнов) конструкция преобразуется к синтаксису 2.1.3 следующим
    образом - p_qual передается как есть (однако если значение
    задано для несуществующих реквизитов, то возможно возникновение
    runtime ошибки), p_time передается как есть, в качестве p_field
    передается значение идентификатора, разыменовывающего модификатор
    (т.е. имя поля структуры, идущей за модификатором).
                Пример:
        declare
          v_ref ref [CLIENT];
          v_rec [CLIENT]%arch;
        begin
          ...
          v_rec := v_ref%arch('NAME',trunc(sysdate));
          ...
        end;

2.1.3. Применение к скалярному реквизиту.
  <ref [CLASS]>->[ATTR1].[ATTR2]%arch(p_time timestamp,
               p_field string default null) return string
    - поиск архивного значения реквизита с квалификатором, определяемым
      набором реквизитов от оператора ссылки до модификатора (в примере
      это будет 'ATTR1.ATTR2'), на заданный момент времени p_time для
      экземпляра, по ближайшей ссылке на который применен модификатор.
      Возвращает строковое значение заданного в p_field поля структуры
      [CLASS]%arch (p_field может принимать значения 'ID','QUAL','TIME',
      'USERNAME','BASE_ID','VALUE', любые другие значения, в т.ч. и пустое,
      интерпретируются как 'VALUE', в случае 'TIME' возвращается
      строковое значение поля TIME, преобразованное по формату
      constant.TIMESTAMP_FORMAT). Принцип работы функции следующий:
      если запись на заданную дату в архиве существует, то возвращаются
      данные записи из архива, если в архиве запись не найдена, то
      возвращается текущее строковое значение реквизита. В случае
      реквизита-ссылки из архивного значения вырезается информация
      о ссылаемом экземпляре, т.е. возвращается только значение ссылки.
      Поскольку квалификатор определяется на этапе компиляции  по набору
      реквизитов от оператора ссылки до модификатора, то это гарантирует
      существование такого квалификатора и, соответственно, гарантирует
      возможность получения текущего значения реквизита (чего не гарантирует
      синтаксис 2.1.2, где может быть указан произвольный квалификатор,
      который может не существовать в текущей прикладной модели, но,
      например, существовал ранее).
    Конструкция отображается на интерфейсную функцию get_arch.
    Если реквизит [ATTR2] сам является ссылкой и требуется использовать
    синтаксис 2.1.2, тогда следует использовать синтаксис типизованного
    модификатора (%%).
                Пример:
        declare
          v_ref ref [CLIENT];
          v_val string;
        begin
          ...
          v_val := v_ref->[NAME]%arch(trunc(sysdate));
          ...
        end;

2.1.4. Применение к скалярному реквизиту.
  <ref [CLASS]>->[ATTR1].[ATTR2]%arch(p_tbl in out LIB.ARCHIVE_REC_TBL_T,
               p_time1 timestamp default null,
               p_time2 timestamp default null) return integer
  - извлечение массива записей из архива в параметр p_tbl.
    Ссылка и квалификатор реквизита, для которых извлекается история,
    определяются так же, как и для варианта 2.1.3, т.е. квалификатор
    определяется реквизитами от ближайшего оператора ссылки до модификатора,
    а сама ссылка этим самым ближайшим оператором ссылки.
    Возвращает количество извлеченных записей из архива.
    Дополнительно могут быть заданы параметры:
    p_time1 - если задан не пустому значению, то добавляет
        условие на выборку записей истории, последующих за
        заданным временем (time>p_time1)
    p_time2 - если задан не пустому значению, то добавляет
        условие на выборку записей истории, предшествующих
        заданному времени (time<=p_time2)
    Конструкция отображается на интерфейсную функцию get$vals.
    Конструкция может использоваться только в процедурном коде.
                Пример:
        declare
          type t_history is table of [CLIENT]%arch;
          v_ref ref [CLIENT];
          v_tbl t_history;
          v_cnt integer;
        begin
          ...
          v_cnt := v_ref->[NAME]%arch(v_tbl,trunc(sysdate));
          ...
        end;

2.1.5. Применение по ссылке в SQL-выражениях PL/Plus.
  <ref [CLASS]>%arch.[FIELD]
  - разыменование ссылки в архивную таблицу.
    Синтаксис предназначен для использования только в SQL-выражениях,
    т.е. в PL/Plus запросах. Использование модификатора в таком
    контексте приводит к соединению (джойну) архивной таблицы
    типа, которым определена ссылка (т.е. архивной таблицы типа
    [CLASS] в примере). Реквизиты архивной таблицы (т.е. [FIELD])
    могут иметь имена только [ID], [QUAL], [TIME], [USERNAME],
    [BASE_ID], [VALUE], их типы соответствуют полям структуры [CLASS]%arch.
    Конструкция может использоваться в любых выражениях, удовлетворяющих
    условиям проверки типов и только для ссылок, разыменованных
    через соединение таблиц, т.е. через джойны (в процедурном коде
    конструкция использована быть не может - в этом случае следует
    использовать вариант 2.1.2).
                Пример:
        for (
          select x(x.[name],x%arch.value) in [CL_PRIV]
           where x%arch.[time](true)<trunc(sysdate) -- outer join
             and x%arch.[qual](true)='NAME'         -- outer join
           order by x%arch.[time]
        ) loop
            exit;
        end loop;

2.1.6. Применение к типу.
  [CLASS]%arch.[INSERT](p_rec [CLASS]%arch)
  - создание новой записи в архиве типа [CLASS], модификатор принимает
    один параметр типа [CLASS]%arch.
    Конструкция отображается на интерфейсную процедуру log$vals.
    Это служебная процедура, предназначена для целей конвертации
    и первоначального заполнения истории (корректность заполнения
    структуры p_rec не контролируется).
                Пример:
        declare
          v_rec [CLIENT]%arch;
        begin
          ...
          [CLIENT]%arch.[insert](v_rec);
          ...
        end;

2.1.7. Применение к типу.
  [CLASS]%arch.[DELETE](p_ref ref [CLASS], p_qual string default null,
          p_time1 timestamp default null, p_time2 timestamp default null)
  - удаление записей из архива для заданного значения ссылки в параметре
    p_ref. Дополнительно может принимать параметры:
    p_qual  - если задан не пустому значению, то добавляет
        условие на равенство квалификатору в истории (qual=p_qual);
    p_time1 - если задан не пустому значению, то добавляет
        условие на удаление записей истории, предшествующих
        заданному времени (time<=p_time1)
    p_time2 - если задан не пустому значению, то добавляет
        условие на удаление записей истории, последующих за
        заданным временем (time>p_time2)
    Конструкция отображается на интерфейсную процедуру del_vals.
    Это служебная процедура, предназначена для целей конвертации
    и коррекции уже существующих архивных данных (например, для
    удаления неактуальных данных).
                Пример:
        declare
          v_ref ref [CLIENT];
        begin
          ...
          [CLIENT]%arch.[delete](v_ref,'NAME');
          ...
        end;

ПРИМЕЧАНИЯ.
  1. Следует отметить, что конструкции 2.1.2 и 2.1.3
    автоматически корректируют поля TIME и USERNAME по записи,
    предшествующей запрашиваемому моменту времени, конструкции
    2.1.4 и 2.1.5 возвращают записи архива как есть, так что
    это нужно иметь в виду при  обработке данных, получаемых
    этими конструкциями.
  2. Модификатор %arch в любых его проявлениях не контролирует
    признак архивации по заданному квалификатору (состояние
    которого может изменяться в прикладной модели), задаваемый
    квалификатор служит лишь дополнительным фильтром при поиске
    записей в истории, варианты 2.1.3 и 2.1.4 контролируют
    только существование квалификатора в принципе (причем на
    этапе компиляции). В случае отсутствия у типа архивной
    таблицы модификатор возвращает runtime ошибку.

2.2.  В версии ТЯ 7.0 реализован дополнительный синтаксис
вызова перекрытых операций. Теперь перекрытый вызов можно
инициировать не только с помощью префикса типа, но и с помощью
синтаксиса переопределения типа в операторе ссылки при вызове
по ссылке this. Таким образом, в ТЯ 7.0 появилась возможность
выполнения перекрытых вызовов валидаторов операций, чего нельзя было
сделать в прежних версиях (т.к. префикс типа инициировал перекрытый
вызов только тела операции). Естественно, перекрытые вызовы
возможны только для операций, работающих с экземплярами,
т.е. для всех типов простых операций, в т.ч. конструкторов и
деструкторов. Вызов операции считается перекрытым, если
переопределяющий тип ссылки является родительским по отношению
к типу операции, если же он является дочерним, то такой вызов
означает просто вызов операции дочернего типа (т.е. работает
обычный режим переопределения типа ссылки).
		Пример:
	[PARENT_CLASS]::[EDIT#AUTO]; 	-- перекрытый вызов тела родительской операции
	this->(::[PARENT_CLASS])[EDIT#AUTO];-- перекрытый вызов тела родительской
                                            -- операции (аналог предыдущего вызова)
	this=>(::[PARENT_CLASS])[EDIT#AUTO];-- перекрытый вызов валидатора родительской
                                            -- операции (аналога в прежних версиях нет)


        3. Разное.

3.1. Реализована поддержка "Архивных реквизитов" экземпляров
ТБП. Теперь скалярные реквизиты в типах, имеющих экземпляры,
могут иметь признак "архивируемости", что означает сохранение
истории изменения значений такого реквизита в специальной
архивной таблице, привязанной к самому типу, в отличие от
системного журнала "Истории изменения значений реквизитов",
находящегося на схеме аудита и хранящего изменения всех
экземпляров для всех типов. Системный журнал предназначен именно
для целей аудита изменений и не очень подходит для оперативного
доступа к истории самих значений, для чего и реализован
описываемый функционал архивации значений реквизитов.

3.1.1. Признак "Архивный реквизит" устанавливается и хранится
в таблице class_tab_columns.logging, в 5-бите HEX-представления
значения колонки. Этот признак может устанавливаться для любых
скалярных реквизитов, которые не являются вычисляемыми.
Соответственно, признак не может быть выставлен для массивов
типа NESTED TABLE и системных OLE - (LONG, LONG RAW, LOB, BLOB, BFILE).

3.1.2. При наличии архивных реквизитов создается таблица для их
хранения следующей структуры:
  ID       number/string - ID экземпляра,
  QUAL	   string(700)	 - квалификатор колонки, соответствующей
		 	   архивному реквизиту,
   			   или 
   			   ‘%INSERT’ - для специальной записи,
   			   соответствующей событию создания экземпляра,
   			   или 
   			   ‘%DELETE’ - для специальной записи, 
   			   соответствующей событию удаления экземпляра,
  TIME     timestamp     - время изменения,
  USERNAME string(30)    - имя пользователя, внесшего изменения,
  BASE_ID  string(16)    - базовый скалярный тип реквизита,
                           возможные значения 'STRING', 'NUMBER',
                           'DATE', 'BOOLEAN', 'MEMO', 'REFERENCE',
                           'COLLECTION', 'TIMESTAMP', 'INTERVAL',
  VALUE    string(4000)  - строковое представление значения реквизита
                           (старое значение на момент изменения,
                           в соответствии с base_id).

3.1.3. При наличии в типе архивных реквизитов создается триггер
на изменение, создание и удаление, который заполняет таблицу архивных значений.
Принцип его создания и код аналогичен триггеру журналирования.
При изменении значений ссылок значения в истории в формате:
<значение ссылки>.<тип ссылаемого экземпляра>.<имя ссылаемого экземпляра>
(под именем подразумевается значение умолчательного реквизита).
При создании (добавлении) экземпляра в ТБП в архивную таблицу добавляется  специальная служебная запись, для которой заполняются только колонки QUAL значением ‘%INSERT’, ID,  TIME и USERNAME. 
При удалении экземпляра в ТБП в архивной таблице  сохраняется информация обо всех архивных реквизитах. Событие удаления также фиксируется - в архивную таблицу добавляется служебная запись со значением ‘%DELETE’ в колонке QUAL и с заполненными колонками  ID,   TIME, USERNAME. 
Также сохраняется единый принцип архивирования и журналирования
в плане сохранения значений - в момент изменения в журнал и
в архив заносятся предыдущие (старые) значения. Добавлено также
создание системного индекса по колонке ID архивной таблицы, чтобы
обеспечить оперативный доступ к архиву значений реквизитов
конкретного экземпляра.

3.1.4. Реализован новый функционал по управлению хранением
архивной таблицы:
пакет storage_mgr:
  procedure update_class_storage
  - создает таблицу при необходимости.
  function needs_log_table(p_class_id varchar2, p_self boolean default true) return boolean
  - возвращает признак существования архивных реквизитов
  function  class2table(p_class varchar2,p_arch varchar2 default null) return varchar2
  - возвращает имя основной таблицы, при p_arch='1' - имя архивной таблицы.
  procedure delete_arc_table(p_class varchar2,p_drop boolean default false)
  - удаляет данные архивной таблицы, при p_drop=true удаляет саму таблицу.
  procedure convert_obj_id(p_class varchar2,p_set_rights boolean default true)
  - опубликована процедура из storage_utils (для Админа) конвертации данных
    таблиц object_rights_ex, object_rights_list (object_rights),
    long_data, obj_static при изменении типа ID с числового на строковый и наоборот.
  procedure reconcile_class_table
  - добавлена обработка архивной таблицы, что позволяет перемешать данные таблицы,
    перестраивать ее, переименовывать, конвертировать ID при смене типа ID
    в основной таблице.
пакет storage_utils:
  procedure create_indexes
  - создает индекс по колонке ID на архивной таблице (если его нет).
  procedure convert_obj_id(p_class varchar2,p_set_rights boolean default true)
  - добавлена конвертация данных архивной таблицы.
пакет part_mgr:
  procedure get_definitions
  - добавлен сбор информации об архивной таблице.
пакет dict_mgr:
  procedure rename_class:
  - добавлено переименование архивной таблицы.
  procedure delete_class_entirely:
  - добавлено удаление архивной таблицы.
  function  get_obj_list(p_table varchar2, p_type varchar2 default null) return varchar2
  - добавлен новый режим p_type='TABLES' для получения списка связанных таблиц
    (архивной таблицы и зеркал архивных секций).
пакет nav:
  procedure Select_History(p_cursor in out nocopy constant.report_cursor,
                           p_obj_id    varchar2, p_class_id  varchar2,
                           p_qual      varchar2, p_like_qual varchar2)
  - курсор для извлечения информации из истории архивных реквизитов
    или из системной истории (если p_class_id is null).

3.1.5. Добавлены новые типы и функции в интерфейсные пакеты типов:
пакет CONSTANT (эти же типы отображены и в пакете LIB):
  type archive_rec_t is record (
        id        varchar2(128),
        qual      varchar2(700),
        time      timestamp,
        username  varchar2(30),
        base_id   varchar2(16),
        value     varchar2(4000)
  );
  type archive_rec_tbl_t is table of archive_rec_t index by binary_integer;
интерфейсные пакеты типов:
procedure log_vals(obj_id_ , qual_ varchar2, base_ varchar2, value_ varchar2,
          time_ timestamp default null, user_ varchar2 default null);
          - добавление записи в архив (используется в триггере)
procedure log$vals(rec archive_rec_t);
          - добавление записи в архив (используется в PL/Plus)
procedure del_vals(obj_id_ , qual_ varchar2 default null,
          time1_ timestamp default null, time2_ timestamp default null);
          - удаление записей архива (используется в PL/Plus)
function  get$vals(obj_id_ , qual_ varchar2, vals_ in out nocopy archive_rec_tbl_t,
          time1_ timestamp default null, time2_ timestamp default null) return pls_integer;
          - извлечение массива записей из архива (используется в PL/Plus)
function  get$arch(obj_id_ , qual_ varchar2, time_ timestamp) return archive_rec_t;
          - поиск записи из архива на заданную дату (используется в PL/Plus)
function  get_arch(obj_id_ , qual_ varchar2, time_ timestamp, field_ varchar2 default null) return varchar2;
          - поиск записи из архива на заданную дату (используется в PL/Plus)


3.2. Добавлена поддержка работы с архивными реквизитами в PL/Plus.
Описание семантических возможностей модификатора %arch см.п.2.1.
Изменены структуры и интерфейсы базовых пакетов компиляции:
plib, plp$check, plp$cursor, plp2plsql, plp$parser, plp$scanner,
а также runtime-пакетов - lib, valmgr, types, bindings и административных -
method, method_mgr, data_views. Добавлены новые диагностические
сообщения в messages, добавлены описания типов LIB.ARCHIVE_REC_T,
LIB.ARCHIVE_REC_TBL_T в rtl_entries и rtl_parameters.

3.3. Добавлены новые процедуры и функции в библиотеку
[SYS_DIARYS]::[HLIB], которые могут использоваться в
операциях конвертации данных системных журналов в
архивные таблицы (подробности в valh.txt):
procedure GET_ARCHIVE_VALUES(P_CLASS string, P_QUALS memo,
               P_ARCH in out LIB.ARCHIVE_REC_TBL_T,
               P_START_DATE in DATE_TYPE := null, P_END_DATE in DATE_TYPE := null);
function PUT_ARCHIVE_VALUES(P_CLASS string, P_ARCH LIB.ARCHIVE_REC_TBL_T
               P_EXISTING boolean := true)  return integer;
function FILL_ARCHIVE_VALUES(P_CLASS string, P_QUALS memo,
               P_START_DATE in DATE_TYPE := null, P_END_DATE in DATE_TYPE := null,
               P_EXISTING boolean := true)  return integer;

----------------------------------------------------------------------
Изменения на 30.07.2008. - версия 7.0 (build 0 Revision 0).

        2. Семантика.

2.1. Реализована возможность создания pipelined функций в PL/Plus.
Требования для pipelined функций:
- функция должна возвращать ТБП, определенный как вложенная
  таблица (NESTED TABLE - varray(0) в PL/Plus синтаксисе);
- функция может быть вызвана только в SQL-конструкциях PL/Plus,
  в процедурном коде ее использование недопустимо;
- определение pipelined указывается только в спецификации
  функции;
- оператор return в реализации (implementation) функции может
  использоваться в двух режимах: без возвращаемого значения -
  для завершения выборки данных функцией (собственно, обычный
  return); с возвращаемым значением - для возвращения очередного
  элемента массива (pipe row), работа функции при этом не
  завершается, тип возвращаемого значения должен соответствовать
  типу элементов массива, которым определена сама функция.
Основное отличие pipelined функции от обычной, возвращающей
массив типа NESTED TABLE, в том, что она возвращает записи
по одной, а не все сразу, что может быть удобно при получении
только первых записей массива, чтобы не затрачивать ресурсы
на получение всех записей. Если же, наоборот, требуется получение
всех записей массива, то использование обычной функции более
эффективно.
                Пример:
     PUBLIC section:
         type number_array is varray(0) of number;
         function func1 return number_array;  -- обычная функция
         function func2 return number_array pipelined; -- pipelined функция
     PRIVATE section:
         function func1 return number_array is
           v_arr number_array;
         begin
           v_arr.init(1,2,3); -- инициализация всего массива
           utils.sleep(1); -- ожидание 1 сек
           return v_arr;   -- возвращаем весь массив
         end;
         function func2 return number_array is
         begin
           return 1; -- возвращаем 1 элемент массива (1 fetch)
           return 2; -- возвращаем 2 элемент массива (2 fetch)
           return 3; -- возвращаем 3 элемент массива (3 fetch)
           utils.sleep(1); -- ожидание 1 сек
           return;   -- завершение
         end;
     BODY section:
         declare
           -- курсор по обычной функции
           type cursor1 is select x(x.column_value) in func1;
           -- курсор по pipelined функции
           type cursor2 is select x(x.column_value) in func2;
           v_cur1 cursor1;
           v_cur2 cursor2;
           n number;
         begin
           v_cur1.open; -- инициализация всего массива (ждем 1 сек)
           loop
             v_cur1.fetch(n); -- извлекаем 1 элемент (ничего не ждем)
             exit; -- и сразу выходим из цикла
           end loop;
           v_cur1.close;
           v_cur2.open; -- привязка курсора к pipelined функции (ничего не ждем)
           loop
             v_cur2.fetch(n); -- извлекаем 1 элемент (ничего не ждем)
             exit; -- и сразу выходим из цикла
           end loop;
           v_cur2.close;
           v_cur1.open; -- инициализация всего массива (ждем 1 сек)
           loop
             v_cur1.fetch(n) ;-- извлекаем элементы (ничего не ждем)
             exit when v_cur1.notfound; -- пока они есть
           end loop;
           v_cur1.close;
           v_cur2.open; -- привязка курсора к pipelined функции (ничего не ждем)
           loop
             v_cur2.fetch(n); -- извлекаем элементы (ждем 1 сек после извлечения последнего)
             exit when v_cur2.notfound; -- пока они есть
           end loop;
           v_cur2.close;
         end;

2.2. Скорректирован разбор Oracle типов в PL/Plus, который в случае
отсутствия явных прав у владельца IBSO мог приводить к бесконечной
рекурсии при некоторых условиях.

2.3. Реализована диагностика ошибки при превышении размера 32K
текстов комментариев в PL/Plus. Реализована диагностика ошибки
отсутствия описания переменной цикла по нетипизованному ссылочному
курсору.


        3. Разное.

3.1. Реализованы новые функции библиотеки fio, пакетов stdio/utlfile,
позволяющие возвращать информацию о размерах файлов, превыщающих
2GB (подробности в stdio.txt). Реализован дополнительный режим
вывода информации в буфер сессии и в пайпу без преобразования
данных исходного текста при помещении их в буфер фрагментами.

3.2. Реализован опциональный NOLOGGING режим выполнения процедур
хранения и перестроения таблиц типов. Режим управляется новой
системной настройкой STORAGE_FORCE_NOLOGGING (по умолчанию
используется значение YES, т.е. режим NOLOGGING включен).

3.3. Скорректированы функции аутотентификации заданий по расписанию
для версии Oracle 10.2.0.4 и выше (в связи с изменением в Oracle
генерации AUDSID для заданий).

----------------------------------------------------------------------
Изменения на 30.03.2008. - версия 7.0 (build 0 Revision 0).

        2. Семантика.

2.1. Реализована поддержка динамического использования архивных
данных секционированных таблиц в операциях и представлениях
словаря данных (см.п.3.1). Расширен архивный режим работы
операций, определяемый опцией компиляции, управляющей использованием
архивов. Режим использования архивов определяется прагмой archive
или соответствующими опциями компиляции.

  Допустимо использование следующих режимов:
  1) pragma archive(true);
     pragma archive(true,'actual'); pragma archive(false,'actual');
     pragma archive(true,true);     pragma archive(false,true);
     COMPILER option, position 12 = '1'
     Задается режим использования только актуальных данных
     (актуальных секций - режим по умолчанию):
       - в вызовы интерфейсных пакетов типов везде передается
         значение null в качестве значения для параметра key_;
       - все выборки, поиски, курсоры  (операторы FOR/LOCATE/SELECT),
         SQL-операторы UPDATE/DELETE используют обращения только
         к актуальным секциям.
  2) pragma archive(true,'all');
     pragma archive(true,false);
     COMPILER option, position 12 = '2'
     Задается режим использования архивных данных с использованием
     текущих значений ключей архивации:
       - в вызовы интерфейсных пакетов типов везде передается
         значение -1 в качестве значения для параметра key_;
       - все выборки, поиски, курсоры  (операторы FOR/LOCATE/SELECT),
         SQL-операторы UPDATE/DELETE (только для Oracle partitions)
         используют обращения ко всем секциям с добавлением условия
         на значение колонки KEY большее или равное текущему ключу
         разделения для заданной таблицы типа.
  3) pragma archive(false);
     pragma archive(false,'all');
     pragma archive(false,false);
     COMPILER option, position 12 = '0'
     Задается режим использования всех архивных данных:
       - в вызовы интерфейсных пакетов типов везде передается
         значение 0 в качестве значения для параметра key_;
       - все выборки, поиски, курсоры  (операторы FOR/LOCATE/SELECT),
         SQL-операторы UPDATE/DELETE (только для Oracle partitions)
         используют обращения ко всем секциям без добавления условия
         на колонку KEY (либо с добавлением условия на значение колонки
         KEY большее или равное нулю).
  Для PL/Plus представлений по умолчанию используется режим 2.1.1, режим
  2.1.2 может быть включен путем добавления свойства Archive в представление
  (т.е. включение подстроки '|Archive' в criteria.properties - см.п.3.10).

  Операции-триггеры и операции-реквизиты (функциональные реквизиты)
создаются в двух вариантах:
  - с использованием режима актуальных секций 2.1.1;
  - с использованием режима архивных секций 2.1.2 с тем исключением,
    что для собственного типа используется значение дополнительного параметра
    plp$key, передаваемого в операцию явно (это реализует логику работы
    интерфейсных пакетов типов, т.к. эти операции вызываются явно именно из
    интерфейсных пакетов, где ключ архивации передается параметром).
  Варианты транслируются в одноименные pl/sql процедуры и функции,
  перегруженные по параметру plp$key (при необходимости код операций
  может анализировать значение параметра plp$key, т.е. иметь runtime
  информацию о том, в каком режиме работает операция).

  Препроцессором PL/Plus также допускается явное указание значения ключа
архивации для наложения условия в поисках и выборках, а также для получения
значений реквизитов и модификаторов по ссылкам путем указания значения
для параметра key_ (осуществляемым через вызовы соответствующих функций
и процедур интерфейсных пакетов типов).
  Явно указываемые значения номеров секций архивных таблиц (либо подключение
всех секций таблиц опцией 'all') перекрывают общие режимы 2.1.1-2.1.3 для
заданных типов. То же относится и к значениям ключей архивации - явно заданные
значения перекрывают значения режимов 2.1.2-2.1.3. Исключением является
указание параметра key_ для ссылки this в случае включенной оптимизации
кэш-переменной this (общий режим архивации перекрывает явно заданное
значение - об этом выдается предупреждение препроцессора), соответственно,
процедуры Get$Obj$This/Set$Obj$This используют ключи режимов 2.1.1-2.1.3 и
игнорируют заданные значения ключа архивации при ссылке this.

  Параметр key_ может быть задан в операторе ссылки в качестве числового
значения. Если он задан, то должен быть указан последним в списке параметров
для оператора ссылки (который может принимать первым константу true/false
для указания типа соединения outer/inner join, вторым ТБП, переопределяющим
целевой тип ссылки). В прежних версиях ТЯ ссылка также могла принимать
значение для key_, однако его нельзя было задать одновременно с указанием
выражения для переопределения типа (в котором дополнительно можно указать
либо номер секции, либо все секции).

  Параметр key_ может быть задан в операторах-модификаторах в качестве числового
значения. Если он задан, то должен быть указан последним в списке параметров
для соответствующего модификатора (которые для ссылок и коллекций могут
принимать как минимум 2 параметра - первым константу true/false для указания
типа соединения outer/inner join, вторым ТБП, переопределяющим целевой тип
ссылки). В прежних версиях ТЯ возможности указать значение ключа архивации
для модификаторов не было. Параметр key_ поддерживается для следующих
модификаторов:
  %id([<outer>,][<CLASS>,][<key>]) - при разыменовании в другой тип
  %class([<outer>,][<CLASS>,][<key>])
  %classname([<outer>,][<CLASS>,][<key>])
  %classparent([<outer>,][<CLASS>,][<key>])
  %entity([<outer>,][<CLASS>,][<key>])
  %state([<outer>,][<CLASS>,][<key>])      - при получении значения
  %statename([<outer>,][<CLASS>,][<key>])
  %collection([<outer>,][<CLASS>,][<key>]) - при получении значения
  %parent([<outer>,][<CLASS>,][<PARENTCLASS.ATTR>,][<key>])
  %parentclass([<outer>,][<CLASS>,][<key>])
  %value([<outer>,][<CLASS>,]<qual>[,<%class>][,<key>])
  %lock([<wait>,][<CLASS>,][<%class>,][<timeout>,][<info>,][<key>]) - только по ссылке
  %delete([<CLASS>,][<key>]) - только по ссылке
  %scn([<outer>,][<CLASS>,][<%class>,][<key>])
  %request([<%class>,][<info>,][<key>])
  %check([<%class>,][<key>])
  %size(<maxrownum>[,<key>])
  %attrs([<set>,][<ref>,][<quallist>,][<key>])

  Реализована возможность soft-смещения текущих значений ключей архивации
для секционированных типов путем присвоения числового значения модификатору
%key. При этом изменяются значения ключей архивации только в системном
контексте и в буфере пакета valmgr (хранимое значение в class_tables
не изменяется). Значение, большее или равное нулю, устанавливается текущим
для типа, которым определена ссылка перед модификатором %key, пустое значение
перечитывает текущее хранимое значение в БД (из class_tables), отрицательное
значение устанавливает текущее значение ключа архивации, равное ключу секции,
номер которого отсчитывается вниз от актуального на величину, определяемую
модулем заданного значения.
  Дополнительным параметром в %key можно передать логический признак
распространения заданного значения по иерархии типов (значение true -
используется по умолчанию).

  При использовании явно указываемых через параметр key_ значений ключей
архивации в операторах ссылки и в модификаторах выборок, поисков, курсоров
(операторы FOR/LOCATE/SELECT), SQL-операторов UPDATE/DELETE (только для Oracle
partitions) для базовых типов (из основного списка IN, а не присоединяемых
по ссылкам или коллекциям) по умолчанию используется принцип распространения
значений ключей по иерархии типов (как в интерфейсах типов - см.п.3.1).
Распространения ключей не происходит при использовании типизованных ссылок
(т.е. заданное значение ключа используется только в том типе, которым
определена ссылка).


2.2. Реализованы упрощенный режим проверки существования
пользовательских сессий и доверительный режим получения
списка сессий от сервиса lock_info. В частности, новый
(доверительный) режим используется в механизме рассылки
событий (для событий 0 и 12 отдельно реализован механизм
подписок см. п.3.2). Также в процедуру получения списка
сессий добавлена возможность фильтрации списка сессий по
номеру узла RAC (Real Application Cluster).
Расширен интерфейс пакета RTL (LOCK_INFO):
function init_user ( p_user in out users_info ) return boolean;
  Инициализирует структуру p_user информацией из списка
  сессий Oracle (V$SESSION для текущего узла RAC, GV$SESSION
  для других узлов RAC) и возвращает true в случае успеха.
  В исходной структуре должно быть обязательно заполнено поле ID,
  также могут быть заполнены поля:
  instance - номер узла RAC (без единицы):
             если задано пустое значение, то поиск производится
             по всем доступным узлам RAC, если значение задано
             не пустое то сессия ищется на заданном узле;
  sid - идентификатор сессии (V$SESSION.SID): если задано не пустое
        значение, то ищется сессия с заданным идентификатором sid,
        значение id сессии только проверяется (такой поиск на порядки
        быстрее и менее ресурсоемок, чем поиск по id, особенно при
        большом количестве сессий).
  Остальные поля заполняются функцией в случае успеха.
function rtl_nodes return number;
  Возвращает количество узлов RAC для экземпляра Oracle.
function  session_exists(p_uid pls_integer, p_sid pls_integer) return boolean;
  Возвращает признак существования сессии с заданным ID в p_uid и SID в p_sid.
function  session_status(p_uid pls_integer, p_sid pls_integer) return varchar2;
  Возвращает статус сессии (ACTIVE/INACTIVE если сессия живая, пусто -
  если сессия отсутствует или удалена) с заданным ID в p_uid и SID в p_sid.
function get_user_info( u_info in out users_info,
                        u_idx  pls_integer default null,
                        u_sid  pls_integer default null,
                        p_init boolean default true) return boolean;
  Возвращает информацию о зарегистрированной сессии пользователя с id
  равном u_idx и sid равном u_sid (если u_idx не задан, то возвращается
  информация о текущей сессии пользователя). При указании непустого
  значения u_idx задавать значение u_sid не обязательно, но желательно,
  т.к. поиск сессии пользователя при этом выполняется существенно
  быстрее. Параметр p_init определяет режим заполнения структуры u_info -
  если задано значение true (по умолчанию), то структура заполняется информацией
  из списка сессий Oracle, если задано значение false (доверительный режим),
  то информация из списка сессий Oracle не используется, заполняются только
  поля id, sid, instance, которые приходят по запросу от сервиса lock_info.
  Возвращает TRUE в случае успеха.
function get_user_list( p_users  in out users_tbl,
                        ora_user varchar2 default null,
                        p_init   boolean  default true) return boolean;
  Возвращает список (индексированный массив) зарегистрированных пользовательских
  сессий - информация о полученных сессиях дописывается в конец таблицы p_users.
  Возвращает TRUE в случае успешного выполнения запроса (т.е. существует хотя бы
  одна сессия).
  ora_user - задает фильтр на поиск сессий в формате:
    [<node>.]<username>, где
      <username> задает фильтр на имя пользователя oracle (пустое значение
        означает поиск всех пользователей);
      <node> задает номер узла RAC (без единицы), для которого требуется
        получить список сессий (пустое значение означает поиск на других
        узлах, т.е. на всех, кроме собственного, отсутствие указания номера
        RAC означает поиск на всех доступных узлах RAC, включая собственный);
    пустое значение параметра означает отсутствие фильтра как на имя
    пользователя, так и на номер узла RAC.
  p_init - определяет режим заполнения элементов массива p_users -
    если задано значение true (по умолчанию), то информация заносится
    из списка сессий Oracle, если задано значение false
    (доверительный режим), то информация из списка сессий Oracle не
    используется, заполняются только поля id, sid, instance, которые
    приходят по запросу от сервиса lock_info.


2.3. Доработан алгоритм подбора подходящего вызова перекрытых
функций и процедур по анализу списка фактических значений
параметров в PL/Plus. Прежний алгоритм не всегда полностью
восстанавливал атрибуты подбираемых параметров, что могло
иногда приводить к неправильной генерации кода операций
(например, могли быть объявлены лишние временные переменные
и сделаны лишние переприсвоения).

2.4. Доработан алгоритм кэширования экземпляра THIS в операциях:
- реализовано сохранение признака изменения данных
  (methods.text_type) в инвалидных операциях (ранее при
  инвалидизации операции признак сбрасывался, что могло
  приводить к изменению кода ссылающихся операций);
- реализована перекомпиляция ссылающихся операций при
  изменении признака изменения данных в ссылаемой операции;
- реализовано сохранение признака изменения данных
  (rtl_entries.features) в глобальных процедурах и функциях
  инвалидных операций;
- реализована дополнительная проверка сигнатур глобальных
  процедур и функций операций при установке признака
  изменения данных;
- реквизиты экземпляра THIS, используемые как приемники
  оператора select into, добавлены в процедуру Set$Obj$This
  сохранения экземпляра (ранее этого не происходило);
- поправлена диагностика ошибки использования разыменованных
  по ссылке значений реквизитов экземпляров при использовании
  в качестве приемников оператора select into;
- оптимизирован генерируемый код оператора присвоения при
  использовании реквизитов THIS слева от присваивания
  (удалена генерация ненужных временных переменных в случае
  неизменяемого состояния кэша this в правой части оператора
  присваивания и, наоборот, добавлена генерация необходимых
  временных переменных при использовании разыменования
  ссылочных реквизитов слева от присваивания).

2.5. Реализована возможность указания SQL-выражения для
операций-реквизитов типа BOOLEAN.

2.6. Скорректирована генерация текста скалярных подзапросов
при использовании в списке сортировки (order by).

2.7. Реализована корректировка размера временной переменной
при ее переиспользовании в разных CASE операторах в PL/Plus
(используется наибольший размер для всех CASE выражений,
использующих одну и ту же временную переменную).

2.8. Реализовано предупреждение PL/Plus при попытке определения
макроса размером, превышающего допустимый (10000). Это относится
также и к автоматически генерируемым макросам использования чужой
формы операции или вызова расширения (BASE$EXECUTE, BASE$VALIDATE,
BASE$GETVARS, BASE$SETVARS). При возникновении такого
предупреждения фактическое использование макросов невозможно.

2.9. Скорректирована генерация сложных конструкторов
в типах без реквизитов.

2.10. Скорректировано использование выражений с decode,
возвращающих логическое значение в PL/Plus выборках.

2.11. Препроцессором PL/Plus реализовано добавление префикса
схемы в код PL/SQL при обращении к внешним по отношению к схеме
IBSO объектам (типы Oracle, таблицы, представления) в
результате разбора синонимов и пакетов, ссылающихся на
эти внешние объекты.

2.12. Добавлено сохранение зависимости операций от модификатора
развертывания выражений - %rowtype. Реализована перекомпиляция
зависимых от %rowtype операций при добавлении нового реквизита.

2.13. Реализована возможность множественной выборки (bulk collect)
реквизитов - вложенных массивов в массив вложенных массивов.


        3. Разное.

3.1. Произведен практически полный реинжиниринг структуры интерфейсных
пакетов типов, направленный на возможность использования как
актуальных, так и архивных данных в одном интерфейсном пакете.
Ранее текст интерфейсных пакетов позволял работу только в одном
режиме - либо только актуальные данные, либо полный набор данных
(включая архивные), поэтому для изменения режима работы требовалось
интерфейсные пакеты полностью пересоздавать. В новой версии ТЯ
интерфейсные пакеты для секционированных типов содержат оба варианта
кода (использующего только актуальные данные и использующего
архивные данные).

  Режим выполнения функций и процедур интерфейсных пакетов
определяется параметром key_, который добавлен почти во все
базовые функции и процедуры. Значение параметра key_ интерпретируется
следующим образом:
  - key_ is null - работа только с актуальной секцией
                   (значение по умолчанию);
  - key_ < 0 - работа с архивными секциями, для условия на ключ
               архивации используются текущие значения ключей
               архивации (которые хранятся в class_tables и
               загружаются в контекст <OWNER>_KEYS);
  - key_ >=0 - работа с архивными секциями, для условия на ключ
               архивации используется заданное значение key_
               (значение 0 означает использование ВСЕХ архивных
               секций).
  Если тип устроен иерархически, то заданное значение key_
распространяется и на порожденные вызовы интерфейсных пакетов
по иерархии. Поэтому, для использования значений key_>0,
ключи архивации должны быть согласованными в пределах этой
иерархии (т.е. одно и то же значение ключа разделения должно
отсекать логически согласованные данные связанных иерархически
типов). Порожденные вызовы других интерфейсных пакетов (вызовы
по ссылкам, поиск владельца коллекций, удаление элементов коллекций)
для значений key_>0 вызываются в режиме умолчательного условия
на ключ архивации (т.е. со значением key_=-1).
  Процедуры изменения данных для архивов работают только если
тип разделен по механизму PARTITION (Oracle partitioning),
причем изменение состояний (STATE_ID) и принадлежности коллекций
(COLLECTION_ID), а также создание новых экземпляров осуществляются
только в актуальной секции.
  Скорректировано указание имени параметра Key_ при вызовах
интерфейсных пакетов типов в SQL-выражениях PL/Plus в режиме
использования архивных данных (см.п.2.1).

3.2. Реализована адресная рассылка событий обновления кэша
экземпляров в интерфейсных пакетах типов при изменении кэшируемых
реквизитов экземпляров. Алгоритм реализации основан на "подписке"
на рассылку событий 0 и 12 пользовательских сессий в момент
занесения первого экземпляра в кэш. Сама рассылка событий 0 и 12
производится в момент выполнения фиксации изменений (процедурой
cache_mgr.cache_commit, которая используется для PL/Plus оператора
COMMIT) только тем сессиям, которые подписались на рассылку, а не
для всех зарегистрированных сессий (как было прежде).
  Техническая реализация основана на использовании пайп-каналов Oracle.
Для каждого кэшируемого типа создается две пайпы - одна для списка
зарегистрировавшихся сессий, другая  - для поддержки сериализованного
доступа к этому списку (т.е. для нетранзакционной блокировки списка
сессий).
  Для поддержки механизма подписок и рассылок по подпискам  в пакете
cache_mgr опубликован следующий интерфейс (который может быть использован
и в прикладном коде для организации рассылок других событий, кроме
обновления системного кэша интерфейсных пакетов):

procedure reg_pipe_events (p_pipe varchar2, p_add boolean)
  Подписка-отписка на событие:
  p_pipe - некий строковый идентификатор объекта, на который производится
           подписка (для системного кэша - это просто ID типа), т.е. имя
           именованного списка;
  p_add  - признак подписки:
     false - удаление своей сессии из списка рассылки,
     true,null - добавление своей сессии в список рассылки (значение
             null просто добавляет без всяких дополнительных проверок
             существования своей же сессии в списке).

procedure send_pipe_events(p_pipe varchar2, p_code pls_integer, p_event varchar2)
  Рассылка заданного события для заданного списка:
  p_pipe - некий строковый идентификатор объекта, на который производилась
           подписка (для системного кэша - это просто ID типа), т.е. имя
           именованного списка;
  p_code - код события (пустое значение просто обновляет список подписчиков,
           т.е. удаляет отсутствующие сессии);
  p_event- текст сообщения или информация для события (интерпретация
           определяется кодом события).

procedure refresh_cache_pipes(p_init_classes boolean default null)
   Обновление списков сессий в пайповых кэшах:
   p_init_classes - режим обновления:
     null (по умолчанию) - обновление пайп для существующих списков рассылки
            кэшируемых типов,
     true - обновление и инициализация (если не существует) пайп для
            кэшируемых типов,
     false- обновление для любых уже существующих списков рассылки,
            т.е. не только для кэшируемых типов, но и для пользовательских
            списков.


3.3. Системная настройка PLP_ACTUAL_PARTITION_ONLY, управлявшая
ранее умолчательным режимом использования архивов теперь упразднена.
Управление умолчательным режимом осуществляется через значение
атрибута ACTUAL_PARTITIONS системного контекста <OWNER>_KEYS:
  '1',пусто - использование только актуальных данных (значение
              по умолчанию);
  '0' - использование архивных секций в соответствии со значениями
        текущих ключей архивации.
  По умолчанию включен режим использования только актуальных
секций таблиц, однако он может быть динамически изменен процедурой
valmgr.switch_archiving (которая изменяет значение атрибута ACTUAL_PARTITIONS).
  Умолчательный режим, задаваемый атрибутом ACTUAL_PARTITIONS
глобального контекста <OWNER>_KEYS (см.п.2.1), управляет работой
следующих системных процедур поддержки хранения данных:
  - attr_mgr.del_class_attr (при удалении реквизитов-коллекций);
  - storage_utils.lost_collections (зачистка потерянных коллекций);
  - storage_utils.conv_ref_table (преобразование ссылочных колонок);
  - method_mgr.delete_collection (удаление коллекций);
  - method_mgr.clear_object_refcing (зачистка кривых ссылок);
  - method_mgr.move_object (изменение ID экземпляра);
  - valmgr.first_referencing_on (поиск обратных ссылок).
Триггеры поддержки целостности и дублирования данных всегда
работают только для актуальной секции.
  Режим использования архивных данных в операциях и представлениях
регулируется свойствами самих операций (опция компиляции pragma archive -
см.п.2.1) и представлений (свойство Archive - см.п.3.10).
  Системные представления поиска владельцев коллекций для каждого
типа создаются в двух вариантах - VW_C2O_<Class> (поиск по актуальным
данным) и VW_C2P_<Class> (поиск по архивным данным с учетом текущих
значений ключей архивации).

3.4. В интерфейсных пакетах типов реализован механизм статического
перевызова дочерних интерфейсов для перекрываемых функций и процедур
(LOCK_OBJECT, LOCK_OBJECT_WAIT, CHANGE_STATE, SET_COLLECTION, DELETE,
SCN$, REQUEST_LOCK) по алгоритму, аналогичному функции GET$VALUE.
Расширен кэш пакетов LIB и VALMGR для поддержки данного механизма.

3.5. Оптимизировано использование кэша в интерфейсных пакетах
типов. Буфер для хранения кэшированных данных теперь представляет
собой PL/SQL массив структур типа (ранее использовался массив
планарных структур), что существенно сокращает накладные расходы
на преобразование типов и переприсвоение полей, особенно, когда
полей много. Также реализовано кэширование поля CLASS_ID независимо
от признака кэширования системных реквизитов (при включенном
кэшировании экземпляров колонка CLASS_ID кэшируется всегда).
Скорректировано обновление кэша родительских типов при изменении
экземпляров дочерних.

3.6. Реализована возможность сбора частотных статистик
базовых узлов дерева разбора PL/Plus.

3.7. Скорректирована процедура развертывания макросов
PL/Plus (сделана реентерабельной).

3.8. Оптимизирована результирующая сортировка списка
объектов компиляции (при компиляции списком).

3.9. Оптимизирована процедура синхронизации свойств
расширений представлений (data_views.check_extension) -
сокращены внутренние буфера insert/delete заменены update-ом.

3.10. Добавлено новое свойство представлений 'Archive',
управляющее умолчательным режимом использования архивных
секций (которое ранее регулировалось настройкой
PLP_ACTUAL_PARTITION_ONLY - см.п.3.3).

3.11. В реализации процесса LOCK_INFO на внешней С-процедуре добавлен
режим использования Posix-интерфейсов для синхронизации работы потоков
основного процесса. Этот режим используется по умолчанию вместо
старого режима, основанного на сигналах. Пересобраны библиотеки под
большинство платформ.

3.12. Реализовано пересоздание partition view для архивированных
типов при выполнении хранения, модифицирующего структуру таблицы.

3.13. Скорректирована обработка ошибок структуры гридов
на формах операций, которая приводила к созданию невалидных
интерфейсных пакетов.

3.14. Добавлены операция PIPES_REFRESH и ее запуск-останов
в типе SYSTEM_JOBS. Указанная операция реализует обновление
списков пользовательских сессий, подписавшихся на события
пакета cache_mgr (cache_mgr.refresh_cache_pipes - см.п.3.2).

3.15. Реализован новый (архивный) режим работы интерфейсных пакетов
операций, определяемый опцией компиляции, управляющей использованием
архивов (см.п.2.1).

3.16. Скорректированы описания функций и процедур пакетов
RTL/LOCK_INFO в словарях rtl_entries/rtl_parameters в
соответствии с измененными интерфейсами (см.п.2.2).

3.17. Реструктурирована процедура UPGRADE ТЯ. Добавлена возможность
автоматического запуска Мониторов на необходимые пайп-каналы.

----------------------------------------------------------------------
Изменения на 1.12.2007. - версия 7.0 (build 0 Revision 0).

        2. Семантика.

2.1. Реализованы новые операторы-модификаторы для поддержки новой
схемы блокировок (см.п.3.1):
%scn - применяется по ссылке на экземпляр, возвращает числовое
    значение идентификатора последнего изменения (SCN) экземпляра.
    При использовании в PL/Plus запросах модификатор %scn транслируется
    либо в обращение к колонке SN (для версии Oracle9i), либо к псевдо-столбцу
    ORA_ROWSCN (для версии Oracle10g и таблиц с опцией ROWDEPENDENCIES).
    В ТЯ для версии Oracle9i и для таблиц без опции ROWDEPENDENCIES (Oracle10g)
    реализована генерация изменения значения колонки SN (инкремент) для любых
    конструкций, изменяющих данные в таблицах типов (SQL-операторы INSERT/UPDATE,
    SET$OBJ$THIS для кэш-переменной THIS в операциях). Для версии Oracle10g
    и таблиц типов, созданных с опцией ROWDEPENDENCIES, этого не требуется,
    т.к. SCN и так хранится в самой записи (и доступен через ORA_ROWSCN).
    Для таблиц, созданных без опции ROWDEPENDENCIES, псевдо-столбец ORA_ROWSCN
    отражает изменения данных на уровне блока данных, а не отдельной
    записи (т.е. при изменении одной записи в некотором блоке данных,
    SCN изменится для всех записей, находящихся в том же блоке, что
    и измененная). В новой версии ТЯ при создании или перестроении
    таблиц типов эта опция включается автоматически.
    При использовании %scn в процедурном коде возвращаемое значение
    модификатора вычисляется как сумма всех значений SСN записей по
    собственной таблице и всем родительским таблицам для заданного
    экземпляра.
    Модификатор может принимать дополнительно один строковый параметр,
    определяющий тип экземпляра (если параметр не задан или задан пустым,
    то тип определяется самим модификатором, что может приводить к
    дополнительным запросам к БД).
%request - запрос-установка блокировки, применяется по ссылке на экземпляр,
    возвращает строковое значение, которое в случае успешной установки
    будет пустым, а в случае ошибки будет содержать текст этой ошибки.
    Модификатор может принимать до двух дополнительных строковых
    параметров, первым - тип экземпляра (если параметр не задан или задан
    пустым, то тип определяется самим модификатором,), вторым - пользовательская
    информация о блокировке (если не задана или задана пустой, то используется
    стандартная информация в формате [CLASS]::[METHOD] той операции, которая
    устанавливает блокировку).
%check - запрос-проверка блокировки, применяется по ссылке на экземпляр,
    возвращаемого значения не имеет, т.е. может использоваться только как
    отдельный оператор. В случае успеха (логическая блокировка существует,
    принадлежит текущему пользователю и SCN экземпляра не изменялся)
    отрабатывает без ошибок, в противном случае генерирует исключение
    RTL.CHECK_OBJECT.
    Модификатор может принимать дополнительно один строковый параметр,
    определяющий тип экземпляра (если параметр не задан или задан пустым,
    то тип определяется самим модификатором).
                Пример:
         v_ref ref [CLASS];
         v_cls string(16);
         begin
           v_cls := v_ref%class;
           -- запрашиваем логическую блокировку
           if v_ref%request(v_cls,'my info') is not null then
             raise rtl.check_object; -- при неуспехе генерим ошибку
           end if;
           ... -- что-то делаем
           v_ref%check(v_cls); -- проверяем наличие блокировки
           v_ref%lock(v_cls);  -- теперь блокируем физически
           ... -- изменяемые данные по ссылке v_ref
         end;
Замечание. Приведенный код по изменению некоего экземпляра v_ref работает
в одном "пространстве" блокировок с Навигатором, что, вообще говоря,
в коде операций не рекомендуется. По умолчанию операции должны работать
на уровне физических блокировок, т.е. они выполняются с высшим приоритетом,
без лишних опросов состояний логических блокировок. Разведение
логических блокировок осуществляется на уровне Навигатора через
интерфейсные пакеты операций.
Прежние вызовы executor.lock_request или lock_info.request, используемые
для аналогичных целей, теперь уже не будут пересекаться с блокировками
форм операций (они будут взаимодействовать только между собой), что,
возможно, потребует замены этих вызовов новыми модификаторами (при
использовании их для работы именно с экземплярами ТБП). Соответствие
старых функций для работы с логическими блокировками и новых модификаторов
следующее:
%request - executor.lock_request, lock_info.request;
%check   - rtl.check_obj, lock_info.check_obj.

2.2. Реализована замена переменных для идентичных выражений
в select-листе PL/Plus запросов (ранее замена производилась
во всех других секциях PL/Plus запроса - where, group by,
order by, having и пр., кроме самого списка выборки select).
                Пример:
         v_cl ref [CLIENT];
         type xxx is
           select u( u : id,
                   v_cl->[name] : name, -- 1
                   v_cl->[name]||'SMTH' : sname) -- 2
               in [USER] where u.[username]=v_cl->[name]; -- 3
    В прежних версиях для выражений 1 и 3 создавалась одна дополнительная
    переменная (куда помещалось значение выражения v_cl->[name]),
    а для выражения 2 создавалась еще одна переменная. В новой версии
    для всех трех выражений создается только одна переменная.

2.3. Скорректировано условие генерации проверки по ключевому
слову nostatic в PL/Plus. Ранее не всегда добавлялось условие
на ID экземпляра в эту проверку.

2.4. Скорректировано разыменование пустого квалификатора реквизита
через точку (правильное разыменование должно быть через оператор
ссылки) для ссылок-коллекций при наличии оператора-модификатора.
Например, ранее выражение вида v_ref.[COLL_ATTR].[]%id (где
COLL_ATTR - реквизит-коллекция) при использовании в PL/Plus выборке
могло приводить к генерации лишнего условия соединения таблиц,
т.е. ссылка по точке разворачивалась некорректно (тогда как выражение
v_ref.[COLL_ATTR]->[]%id с явным указанием оператора-ссылки
разбиралось корректно). В новой версии ТЯ ошибка разбора ссылки
через точку устранена, однако все равно рекомендуется использовать
операторы по назначению, т.е. точку - для разыменования полей
структур, а оператор ссылки - для разыменования ссылок (и коллекций
в PL/Plus выборках) просто из соображений удобочитаемости и
ускорения времени разбора текстов PL/Plus препроцессором (т.к.
не будут тратиться ресурсы на поиск адекватной замены не совсем
корректной семантической конструкции).

2.5. Реализована возможность указания параметром (числовой константой)
номера архивной секции для переменных-коллекций, используемых в
качестве источника данных (список IN операторов FOR/LOCATE/SELECT).
Ранее для этих целей использовалось неявное добавление модификатора
%collection, что при использовании в подзапросах могло приводить
к лишнему поэлементному разворачиванию этих коллекций, т.е. лишнему
соединению с таблицей целевого типа коллекции. Попутно решена также
проблема возникновения ошибки компиляции при аналогичных условиях,
когда номер секции не указывался.
                Пример:
         v_accnum string;
         type c_acc is
           select b ( b.id : acc, b.recs : recs )
               in ( select a( a : id, a.[ARC_MOVE] : recs )
                    in ::[AC_FIN] where a.[MAIN_V_ID]=v_accnum )
            where exists ( select r(1) in b.recs(0) ); -- actual partition
       В прежних версиях ТЯ номер секции у переменной-коллекции указать
       было нельзя и это фактически означало использование модифицированного
       условия:
            where exists ( select r(1) in b.recs%collection(0) );
       которое в приведенном контексте приводило к лишнему развертыванию
       коллекции b.recs во внешнем запросе.
       В следующем запросе (практически аналогичном):
         type c_acc_1 is
           select a( a : acc, a.[ARC_MOVE] : recs ) in ::[AC_FIN]
            where a.[MAIN_V_ID]=v_accnum
              and exists ( select r(1) in a.[ARC_MOVE](0) ); -- actual partition
       такой дилеммы нет, т.к. реквизит-коллекция всегда допускал явное
       указание номера секции числовой константой.


        3. Разное.

3.1. Реализован новый механизм логических блокировок, используемых
при работе форм операций. Новый механизм основан на хранении информации
о таких блокировках в БД и отслеживании фактических изменений экземпляров.
  Добавлена таблица FRM_LOCKS со следующими смысловыми полями:
OBJ_ID    VARCHAR2(128) - ID экземпляра,
CLASS_ID  VARCHAR2(16)  - тип экземпляра,
USER_ID   NUMBER        - ID (AUDSID) сессии пользователя - владельца блокировки,
USER_SID  NUMBER        - SID сессии пользователя - владельца блокировки,
OBJ_SCN   NUMBER        - версия экземпляра (SYSTEM CHANGE NUMBER - SCN),
TIME      DATE          - время установки блокировки,
INFO      VARCHAR2(256) - дополнительная (пользовательская) информация о блокировке.
  Новые блокировки форм операций (FRM_LOCKS) реализованы как отдельный функционал,
не пересекающийся с уже существующими типами блокировок, информация о них в
интерфейсах существующих функций и процедур заполняется в типах LOCKS_INFO и
LOCKS_TBL.
  Соответствие полей нового словаря логических блокировок FRM_LOCKS и
структуры LOCKS_INFO следующее:
FRM_LOCKS.OBJ_ID     - LOCKS_INFO.OBJECT
FRM_LOCKS.CLASS_ID   - LOCKS_INFO.SUBJECT
FRM_LOCKS.USER_ID    - LOCKS_INFO.USER_ID
FRM_LOCKS.USER_SID   - LOCKS_INFO.USER_SID
FRM_LOCKS.OBJ_SCN    - LOCKS_INFO.ID
FRM_LOCKS.TIME       - LOCKS_INFO.TIME
FRM_LOCKS.INFO       - LOCKS_INFO.INFO (в поле info добавляется префикс
                       'FORM: ' - для отличия от традиционных блокировок LOCK_INFO).
  Для отслеживания изменений записей в таблицах типов используется
так называемый SCN (SYSTEM CHANGE NUMBER), который реализован следующим
образом:
- для версии Oracle9i во все таблицы типов добавляется числовая колонка SN,
  значение которой инкрементируется при любом изменении записи таблицы. SCN
  экземпляра вычисляется как сумма всех значений колонки SN по своей таблице
  и всем родительским для данного ID экземпляра;
- для версии Oracle10g колонка SN не добавляется для таблиц, созданных
  с опцией ROWDEPENDENCIES, что позволяет использовать информацию
  о SCN записи, доступную через псевдо-столбец ORA_ROWSCN. Общий SCN
  экземпляра вычисляется как сумма всех ORA_ROWSCN своей и родительских
  таблиц для заданного ID.
  Алгоритм работы форм операций теперь использует не старый механизм логических
блокировок, который использовал сервис LOCK_INFO, а использует новую
схему (без запросов сервису LOCK_INFO, что снимает с него существенную
нагрузку и позволяет увеличить его пропускную способность по обслуживанию
других пользовательских запросов):
- запуск DEFAULT валидатора устанавливает логическую блокировку (создается
  запись в FRM_LOCKS - в автономной транзакции). Если блокировку установить
  не удастся (установлена кем-то другим или экземпляр блокирован физически
  на уровне Oracle), то выдается соответствующее сообщение об ошибке;
- последующие запуски валидаторов, а также тела операции проверяют установленную
  блокировку, а именно:
  - запись в FRM_LOCKS присутствует и ее владелец не поменялся;
  - не поменялось значение SCN экземпляра, над которым запущена форма.
- по завершении выполнения операции блокировки снимаются (записи FRM_LOCKS
  для текущего владельца удаляются).
  Эта функциональность реализована на уровне интерфейсных пакетов операций.
Технически логическая блокировка устанавливается в два этапа:
- в основной транзакции (чтобы были видны изменения SCN текущей транзакции,
  если таковая была инициализирована) зачитывается SCN с блокировкой, которая
  тут же откатывается до момента блокирующего чтения (тем самым основная
  транзакция не затрагивается);
- в автономной транзакции заносится запись в FRM_LOCKS с зачитанным на первом
  этапе значением SCN экземпляра.
  Расширен набор функций и процедур пакета RTL (и его оболочки - пакета LOCK_INFO)
для работы с новым типом блокировок (более подробное описание в lock_info.txt):
  Реализован также дополнительный сервис в языке - добавлены новые
модификаторы (см.п.2.1), дополнительные пользовательские интерфейсы добавлены
в пакет lock_info (см. lockinfo.txt) и опубликованы в словаре PL/Plus (RTL_ENTRIES).

3.2. Скорректирована генерация интерфейсных пакетов списочных
операций в типах с символьными ID.

3.3. Добавлены условия в представления ТБП USERS, исключающие
выборку удаленных пользователей.

3.4. Доработана процедура удаления экземпляров родительского
типа, не соответствующих ни одному из дочерних
(storage_utils.delete_stuff).

3.5. Добавлены гранты на системные вложенные массивы скалярных типов
(TYPE_BOOLSTRING_TABLE, TYPE_REFSTRING_TABLE, TYPE_DEFSTRING_TABLE,
TYPE_MEMO_TABLE, TYPE_DATE_TABLE, TYPE_NUMBER_TABLE, TYPE_RAW_TABLE)
всем системным ролям - ролям Пользователя, Администратора модели,
Администратора доступа.

3.6. Реализованы дополнительные доработки для Oracle9i:
- умолчательная опция сбора статистики FOR ALL COLUMNS SIZE AUTO;
- вызовы dbms_session.clear_context для очистки контекстов;
- вызовы dbms_session.modify_package_state вместо dbms_session.reset_package.

3.7. Реализована генерация текста автоматической операции
EDIT#AUTO, использующей форму NEW#AUTO, через макросы BASE$VAILDATE
и BASE$EXECUTE.

3.8. Реализовано сохранение информации о версии сервера БД
в пакете INST_INFO (константы DB_VERSION и DB_RELEASE).

3.9. Оптимизирована процедура лексического разбора текстов
PL/Plus через использование массивов типа index by varchar2 для
вычленения токенов под Oracle9i. Реализованы оптимизированные
версии пакетов UTILS схемы AUD, пакетов RTL и MESSAGE схемы IBSO
под Oracle9i (кэш сообщений index by varchar2 и автономные
транзакции).

3.10. Реализован автоматический перезапуск задания менеджера
аудита раз в сутки.

3.11. Реализован функционал по точному поиску перехода с пустой
операцией перехода (стандартный поиск при указании пустой операции
перехода означает поиск с ЛЮБОЙ операцией перехода). Для точного
поиска перехода с пустой операцией перехода нужно указать значение
'<NULL>' для короткого имени операции перехода в модификаторе
%state.
                Пример:
         v_ref%state(null) := 'SOMESTATE'; -- поиск перехода в
            -- состояние SOMESTATE с ЛЮБОЙ операцией перехода
         v_ref%state('<NULL>') := 'SOMESTATE'; -- поиск перехода в
            -- состояние SOMESTATE с ПУСТОЙ операцией перехода

3.12. Расширены размеры буферов при генерации текстов процедур и
функций для гридов на формах операций в интерфейсных пакетах
операций.

3.13. Реализованы специализированные версии пакетов UTILS схемы AUD,
пакетов RTL и MESSAGE схемы IBSO под Oracle9i (кэш сообщений с индексом
varchar2 и автономные транзакции).

3.14. Реализовано использование глобального контекста
для хранения значений ключей архивации (<owner>_KEYS)
и пользовательского контекста <owner>_GLOBAL под Oracle9i.
В процедуру VALMGR.SET_CONTEXT (установку контекста <owner>_GLOBAL)
добавлены дополнительные параметры, позволяющие задавать
дополнительные атрибуты глобального контекста - имя пользователя
и клиентский идентификатор. Использовать клиентский идентификатор
рекомендуется только для каких-то специальных внутренних целей
и запросов внутри операций, при выходе из операций его следует
очищать, т.к. системные глобальные контексты ТЯ доступны только
с пустым клиентским идентификатором.

3.15. Реализовано создание таблиц (и их перестроение) с опцией
ROWDEPENDENCIES (под Oracle9i), которая позволяет хранить информацию
об изменениях данных на уровне записей (без этой опции информация
об изменениях хранится на уровне блоков данных). Это позволяет
использовать псевдо-столбец ORA_ROWSCN (Oracle10g) для извлечения
SCN (system change number) для каждой записи в БД (ORA_ROWSCN
используется в новом механизме логических блокировок - см.п.3.1).

----------------------------------------------------------------------
Изменения на 20.05.2007. - версия 6.5 (build 1 Revision 0).

        2. Семантика.

2.1. Расширены возможности указания выражения для
навигации по ссылке/коллекции в PL/Plus представлениях.
Выражение для ссылки может быть задано с помощью указания
алиаса REF$<ALIAS>, где <ALIAS> - это алиас выражения,
для которого задается ссылка для навигации. Ранее такая
возможность существовала только для запросов с групповыми
операторами (типа UNION), для обычных запросов выражение
для ссылки выбиралось или указывалось в самом выражении
(см. п.2.5 изменений на 10.07.2005).
                Пример:
         type main is
           select md(
             md.[DATE_DOC] : C_DATE_DOC,
             md.[DOCUMENT_NUM] : C_DOCUMENT_NUM,
             md.[SUM] : C_SUM,
             decode(md.[KL_DT].[0],
               1,md.[KL_DT].[1].[2]->[MAIN_V_ID],
               2,md.[KL_DT].[2].[1]->[MAIN_V_ID]) : C_ACC,
             decode(md.[KL_DT].[0],
               1,md.[KL_DT].[1].[2],
               2,md.[KL_DT].[2].[1]) : REF$C_ACC
           ) in ::[MAIN_DOCUM];
Выражение для навигации по ссылке/коллекции должно удовлетворять
следующим условиям:
- выражение должно быть указано после основного выражения;
- тип выражения должен быть ссылка либо коллекция в соответствии
  с тем, как разыменовано основное выражение;
- выражение не может быть очень сложным, т.е. не должно превышать
  по размеру 256 символов.

2.2. Добавлены диагностики PL/Plus при попытке вызова списочной
операции через префикс типа и при попытке использовать разыменование
по ссылке в списке приемников (into list) оператора SELECT.

2.3. Реализовано сохранение обращения через префикс пакета операции
к глобальным функциям операций внутри глобальных курсоров (см.также
п.2.11 изменений на 30.10.2003).

2.4. Реализован PL/Plus синтаксис обращения к таблицам зеркал архивированных
типов напрямую, без использования partition view. Для обращения к зеркальной
таблице следует указывать номер секции (считая от актуального вглубь архива)
плюс значение 1000. Для корректного обращения к зеркалу напрямую нужно,
чтобы структура основной таблицы и зеркала были полностью синхронизованы
(при использовании partition view это не обязательно, т.к. "приведение"
структур делается на уровне view).
                Пример:
        declare
          x [ARRAY_REC];
          r ref [RECORDS];
        begin
          locate exact r in x(1) where rownum=1;
          locate exact r in x(1001) where rownum=1;
        end;
                Преобразуется так:
        declare
          X  number;
          R  number;
        begin
          ...
          select  a1.id
          into R
          from Z#RECORDS partition(Z#RECORDS#1) a1  -- обращение к архивной секции
          where a1.COLLECTION_ID=plp$1$1 and a1.key=0
            and (ROWNUM = 1);
          ...
          select  a1.id
          into R
          from Z#001Z#RECORDS a1 -- обращение к зеркальной таблице архивной секции
          where a1.COLLECTION_ID=plp$2$1 and a1.key=0
            and (ROWNUM = 1);
          ...
        end;


2.5. Реализована возможность получения текущего значения (CURRVAL)
порядкового номера последовательности через функцию rtl.next_value,
для чего параметром нужно передать строковое значение в формате
<SEQUENCE name>.CURRVAL.
                Пример:
        declare
          n number;
        begin
          n := next_value('SEQ_ID'); -- получение нового значения последовательности
          n := next_value('SEQ_ID.CURRVAL'); -- получение текущего значения последовательности
        end;
Реализована возможность использования функции rtl.next_value
непосредственно в PL/Plus запросах:
- при использовании в запросах первым параметром может быть передана
  строковая константа, которая задает либо имя последовательности
  (тогда функция транслируется как получение нового значения последовательности
  в виде выражения <Sequence name>.nextval), либо непосредственно выражение
  для получения атрибутов последовательности (<Sequence>.nextval - новое значение
  или <Sequence>.currval - текущее значение);
- если при использовании в запросах первым параметром указать
  любое строковое выражение (кроме строковой константы), определяющее имя
  последовательности или выражение для получения атрибутов последовательности,
  тогда в запрос будет помещен вызов функции rtl.next_value (до версии ТЯ 6.5.1
  такой режим использования next_value был недоступен).
                Пример:
        declare
          s  string;
          n1 number;
          n2 number;
        begin
          s := 'SEQ_ID';
          select u(next_value('SEQ_ID'), -- старый режим (псевдо-функция)
                   next_value(s))  -- новый режим (обычная функция)
              in [USER] where rownum=1
            into n1,n2;
        end;
                Преобразуется в:
        ...
        select  SEQ_ID.nextval, RTL.NEXT_VALUE(S)
        into N1, N2
        from Z#USER a1
        where ROWNUM = 1;
        ...

2.6. Реализована функция valmgr.rowcount для вычисления sql%rowcount
в PL/Plus (через псевдо-функцию rownum). Функция сохраняет значение
sql%rowcount последнего выполненного оператора PL/Plus INSERT/UPDATE/DELETE.

2.7. Скорректирован вызов операций макросами BASE$VALIDATE, BASE$EXECUTE
при повторных вызовах и в типах-ссылках. Ранее вызовы этих макросов в указанных
ситуациях генерировались некорректно.

2.8. Добавлен парсинг типов внешних источников данных (таблиц) через
словарь типов IBSO в режиме расширенного синтаксиса. В частности, могут
использоваться SQL-типы FLOAT/REAL (которые в Oracle являются подтипами
основного типа NUMBER), если они будут заведены в словаре данных IBSO.

2.9. Расширена pragma set_column возможностью указания сортировки
в PL/Plus представлениях (см.также п.2.1 изменений на 10.08.2005).
Сортировка указывается значением атрибута order_by строкой формата:
    <Позиция в сортировке> { /ASC DESC/}
где <Позиция в сортировке> задает последовательность сортировки колонок
  (колонки с меньшей позицией сортируются ранее колонок с большей позицией),
  опции ASC или DESC задают направление сортировки указанной колонки
  по возрастанию или по убыванию, соответственно (если опция не указана,
  то используется сортировка по возрастанию).
Если в выборке задана собственная сортировка (order by clause),
тогда сортировка, задаваемая атрибутом order_by в set_columns, будет
проигнорирована.
                Пример:
         pragma set_column(sname,name,'Сетевое имя');
         pragma set_column(sname,order_by,'1 DESC');
         pragma set_column(name,name,'Полное имя');
         pragma set_column(name,order_by,'2');
         type main is
           select u(u.username:sname,u.name:name) in [USER];


2.10. Скорректировано добавление внешнего соединения в PL/Plus
представлениях при получении значений системных колонок из родительского
типа, если это значение указано первым в списке выборки курсора
main, который также указан первым в списке описаний тела PL/Plus
представления.
                Пример:
         type main is
           select t(t%class:class,t.[job]:job,t.[status]:status) in [TEXT_JOBS];
В прежних версиях такой курсор генерировался соединением родительской
таблицы типа SYSTEM_JOBS по типу outer join вместо inner join,
который используется по умолчанию для иерархических соединений
(см.п.2.4 plphints.txt).


2.11. Реализован новый режим генерации условия проверки поэкземплярного
доступа (как прямого, так и ссылочного) в представлениях. Свойства
нового режима:
1) проверка используется в основном условии проверки (по AND),
   т.е. она вынесена из ветки OR условия проверки доступа, что
   означает применение этой проверки ВСЕГДА, в т.ч. и для пользователей
   с административными правами (владельца или с правами ADMIN_GRP).
2) используется проверка оператором IN, а не EXISTS, что позволяет
   сделать это условие ведущим (высокоприоритетным, в то время как
   EXISTS делал это условие низкоприоритетным) и использовать соединение
   таблиц отталкиваясь именно от этого условия;
3) умолчательное исключение из подзапроса в IN обращения к колонке
   CLASS_ID внешней таблицы, которое заменяется на обращение к строковой
   константе (идентификатору типа), чтобы исключить зависимость подзапроса
   от внешних источников.
Указанный режим в представлениях включается новым свойством |ObjPriority.
Это же свойство соединяет по AND условие others дополнительной
проверки доступа (см. plphints.txt - п.2.11) с основным условием where
и выводит его из ветки OR основного условия проверки доступа (собственно,
этот механизм и реализует свойство 1) нового режима).
                Пример:
         type main is
           select u(u%rowtype) in [USER]
            where u.[depart]%access_ref(true)   -- приоритетное условие
              and u.[depart]%access_ref(false); -- неприоритетное условие
                Преобразуется в:
         cursor MAIN is
            select  a1.C_NAME NAME, a1.C_USERNAME UNAME
              from Z#USER a1
             where
               a1.C_DEPART in
               (select to_number(o.obj_id) from object_rights_ex o, subj_equal e
                 where e.subj_id=SYS_CONTEXT('DEV_SYSTEM','USER') and o.subj_id=e.equal_id
                   and o.right_class_id='USER' and o.class_id='DEPART')
               and exists
               (select 1 from object_rights_ex o, subj_equal e
                 where e.subj_id=SYS_CONTEXT('DEV_SYSTEM','USER') and o.subj_id=e.equal_id
                   and o.obj_id=to_char(a1.C_DEPART) and o.right_class_id=a1.CLASS_ID and o.class_id='DEPART');


2.12. Опубликованы дополнительные типы и функции пакета STANDARD для
использования в операциях (rtl_entries):
  SYS_REFCURSOR - нетипизованный ссылочный курсор (Oracle9i);
  SYS_EXTRACT_UTC - получение времени 0 часового пояса (Oracle9i);
  REGEXP_INSTR,REGEXP_LIKE,REGEXP_REPLACE,REGEXP_SUBSTR - функции
     регулярных выражений (Oracle10g).

2.13. Скорректирован разбор алиасов используемых источников данных
в хинтах PL/Plus запросов псевдофункцией plp$hint в случае нескольких
явно заданных источников.

2.14. Скорректирована обработка явных выражений для параметров
модификаторов %access_ref и %access_obj ранее приводивших к ошибкам
генерации условий проверки.


        3. Разное.

3.1. Оптимизирована процедура перестроения таблиц. Добавлен режим nologging
при создании индексов, опционально может быть использован также режим
parallel. Реализован опциональный хинт для переноса данных при перестроении
таблиц по системной настройке STORAGE_INSERT_HINT. По умолчанию, если
настройка не задана, используется хинт 'APPEND'. Если задано значение
'NOHINT', то хинт при переносе не указывается. В тексте хинта можно
использовать обращение к таблице, в которую осуществляется вставка
данных по алиасу T$, например, 'PARALLEL(T$,4) APPEND'.
Реализован опциональный режим PARALLEL создания объектов хранения по системной
настройке STORAGE_FORCE_PARALLEL. Значения настройки интерпретируются
следующим образом:
- NO,0 или отсутствие настройки - параллельный режим не используется (используется
  опция NOPARALLEL);
- YES,1 - используется автоматический (определяемый Oracle) параллельный режим
  (используется опция PARALLEL);
- N > 1 - используется явно задаваемое количество параллельных процессов
  (используется опция PARALLEL <N>);
Также создана настройка STORAGE_FORCE_PARALLEL в схеме аудита для управления опцией
параллелизации журналов аудита (интерпретация значений такая же, как и для
одноименной системной настройки схемы-владельца).
Расширен интерфейс ряда служебных процедур хранения с грануляцией по типам
(storage_utils: lost_collections, delete_stuff, add_missing_records).
Дополнительно доработаны процедуры секционирования таблиц:
- реализована возможность логического создания архивных секций без
  перестроения таблиц в режиме PARTITION VIEW;
- добавлены глобальные настройки DICT_TABLESPACE, IDXDICT_TABLESPACE
  в STORAGE_PARAMETERS для табличных пространств словаря данных, что
  исключает возможность отключения этих табличных пространств при
  переключении ключей архивации;
- реализовано сохранение параметра BUFFER_POOL при перестроении таблиц,
  параметр BUFFER_POOL может быть также исходно задан в группах настроек
  параметров хранения (словарь STORAGE_PARAMETERS);
- создание ограничений NOT NULL в режиме NOVALIDATE в архивных секциях;
- реализована возможность привязки родительских таблиц внешним соединением
  (OUTER JOIN) в простых представлениях;
- скорректирован расчет экстентов при секционировании в режиме Oracle PARTITIONS;
- скорректировано использование архивных секций при использовании
  модификаторов в PL/Plus выборках (в прежних версиях при использовании
  модификаторов использовалось умолчательное поведение, задаваемое
  системной настройкой PLP_ACTUAL_PARTITION_ONLY или опцией компиляции
  pragma archive, а не задаваемое параметром в списке IN типов для выборки,
  хотя последнее более приоритетно).

3.2. Добавлены новые режимы упрощенной процедуры UPGRADE ТЯ. Реализованы
отдельные пайповые каналы для параллельных процессов UPGRADE (когда они
заданы). Добавлена установка ограниченной временной лицензии, если
исходно лицензия отсутствовала.

3.3. Реализована возможность использования опции сжатия (COMPRESS) данных
архивных секций на платформе Oracle10g (под Oracle9i использование
ограничено багом Oracle - 2421054). Реализован режим параллельного сбора
статистики по таблицам через пакет dbms_stats. Добавлены новые настройки
в словарь STORAGE_PARAMETERS:
- GLOBAL.COMPRESS_OPTION  - признак (значения YES/NO) использования опции
     COMPRESS для архивных разделов таблиц (если настройка не задана, то
     опция сжатия не используется).
- GLOBAL.ESTIMATE_PERCENT - процент обработки данных таблицы при сборе
     статистики в режиме ESTIMATE (если настройка не задана, то по умолчанию
     используется значение 10%).
Исследование опции сжатия на некоторых таблицах документооборота дало следующие
результаты:
  MAIN_DOCUM   - сжатие в 2.2 раза;
  DOCUM_RC     - сжатие в 2.3 раза;
  DOC_RC_AUDIT - сжатие в 3 раза;
  DOCUMENT     - сжатие в 1.6 раза;
  RECORDS      - сжатие в 1.4 раза;
  HISTORY_STATES - сжатие в 2 раза.

3.4. Реализована возможность преобразования данных в типах, архивированных
по механизму PARTITION (Oracle partitioning) в данные, архивированные
по типу PARTVIEW (partition view), и наоборот.

3.5. Разъяснение по использованию конструкций вида PL/Plus
insert as select с автоматической генерацией новых значений
последовательностей (для ID, коллекций и автоматических реквизитов).
Если в конструкции insert as select в коде PL/Plus в select-листе
явно указаны не все значения для ID, коллекций или автоматических
реквизитов, тогда для них используются автоматические выражения
по получению следующих значений соответствующих последовательностей
вида <sequence>.NEXTVAL (для ID и коллекций - это SEQ_ID.NEXTVAL).
В версии ТЯ 6.5.1 и выше если одна и та же последовательность
используется в автоматических выражениях более одного раза
(например, SEQ_ID - для инициализации как ID, так и реквизитов-коллекций),
то для дублирующих выражений используется уже не <sequence>.NEXTVAL,
а вызов функции rtl.next_value('<sequence>'). Связано это с тем,
что выражение <sequence>.NEXTVAL для одной и той же строки выборки
возвращает одно и то же значение, независимо от того, сколько
раз оно используется в выражениях для строки выборки. Вызовы
rtl.next_value генерят всегда разные значения, в т.ч. и при
использовании в выражениях для одной и той же строки выборки.
Эту особенность нужно иметь в виду при использовании insert as select
при указании как явных, так и неявных выражений для инициализации
автоматических значений. В версии ТЯ 6.5.1 о неявных выражениях
можно не заботиться, т.к. на уровне генерации кода дублирования
значений последовательностей не будет. Дополнительно следует
отметить, что использовать директиву distinct в select-листе
нельзя, т.к. список выборки может быть дополнен автоматическими
выражениями вида <sequence>.NEXTVAL, которые несовместимы
c distinct, а также не имеет смысла, т.к. даже явные выражения
должны обеспечивать уникальность значений (которые при вставке
новых записей контролируются соответствующими ограничениями
целостности на уровне БД).
                Пример:
        insert into [RUNS] r (
          ( r.[SES_ID],r.[GROUP_ID] ) =
          ( select x(x.[SES_ID],x.[GROUP_ID]) in [RUNS]
             where not x.[IS_BAD] and rownum<11 )
        );
                Преобразуется в:
        valmgr.check_insert('RUNS');
        insert into Z#RUNS a1 ( ID,C_STATS, C_SES_ID,C_GROUP_ID )
            (
                select SEQ_ID.NEXTVAL,rtl.next_value('SEQ_ID'), b1.C_SES_ID A$1, b1.C_GROUP_ID A$2
                from Z#RUNS b1
                where (b1.C_IS_BAD = '0') and ROWNUM < 11
            );
        Добавлены два новых значения в список выборки - для ID и
        реквизита-коллекции STATS, которые инициализируются из
        одной последовательности (SEQ_ID), но разными способами.

3.6. Реализовано использование заданного имени пайпы для контроля
компиляции списком. Имя пайпы для остановки компиляции списком можно
задать в атрибуте с именем PIPE.STOP_COMPILE пользовательского контекста.
Если имя в контексте не задано, то по умолчанию (как и раньше) используются
имена пайп <Owner>.PROCESS_METHODS для компиляции операций и представлений
и <Owner>.PROCESS_CLASSES для выполнения хранения и компиляции интерфейсных
пакетов типов.

3.7. Доработана процедура ALTER_SEQUENCE в библиотеке SYS_DIARYS.DLIB, -
добавлена обработка ошибок при хаотическом инкременте последовательностей
в других пользовательских сессиях.

----------------------------------------------------------------------
Изменения на 20.06.2006. - версия 6.5 (build 0 Revision 2).

        2. Семантика.

2.1. Усовершенствована процедура разбора комбинированных выражений
ИЛИ (OR) условий (WHERE) выборок в PL/Plus. Обработка таких запросов
приведена в полное соответствие с заявленным описанием (см.пп.2.4-2.6
plphints.txt). Оптимизация выражений ИЛИ (OR) регулируется опцией CODE
прагмы OPTIMIZE.
                Пример:
      1) pragma optimize(true,'code'); -- режим по умолчанию
         locate exact d in [MAIN_DOCUM] where rownum=1 and
          (d.[ACC_DT].[MAIN_V_ID] like shabl1 or d.[ACC_KT].[MAIN_V_ID] like shabl2);
                Преобразуется в:
	 select  a1.id into D
         from Z#AC_FIN a2, Z#MAIN_DOCUM a1
         where ROWNUM = 1 and (
              (a1.C_ACC_DT=a2.id and (a2.C_MAIN_V_ID like SHABL1))
           or (a1.C_ACC_KT=a2.id and (a2.C_MAIN_V_ID like SHABL2)));
      2) pragma optimize(false,'code');
         locate exact d in [MAIN_DOCUM] where rownum=1 and
          (d.[ACC_DT].[MAIN_V_ID] like shabl1 or d.[ACC_KT].[MAIN_V_ID] like shabl2);
                Преобразуется в:
         select  a1.id into D
         from Z#AC_FIN a3, Z#AC_FIN a2, Z#MAIN_DOCUM a1
         where a1.C_ACC_DT=a2.id(+) and a1.C_ACC_KT=a3.id(+) and (ROWNUM = 1
          and (a2.C_MAIN_V_ID like SHABL1 or a3.C_MAIN_V_ID like SHABL2));

2.2. Расширены возможности использования глобальных переменных,
описанных как %rowtable-тип или вложенный массив, в других операциях.
                Пример:
         Операция [METHOD1] типа [CLASS] содержит описание:
            v_tbl [CLASS]%rowtable;
         Операция [METHOD2] типа [CLASS] содержит такой код:
            i := [CLASS]::[METHOD1].v_tbl%id.first;
            [CLASS]::[METHOD1].v_tbl%id.delete;
         (В прежних версиях такое разыменование было невозможно).


        3. Разное.

3.1. Скорректирована инициализация зависимых колонок гридов
по пустой ссылке с уровнем вложенности больше единицы.

3.2. Оптимизирована генерация процедур инициализации функциональных
реквизитов в интерфейсных пакетах типов. Скорректирована
последовательность иерархических вызовов операций-реквизитов
при установке значений функциональных реквизитов.

----------------------------------------------------------------------
Изменения на 10.05.2006. - версия 6.5 (build 0 Revision 1).

        2. Семантика.

2.1. Реализовано преобразование типа BOOLSTRING в тип BOOLEAN при
сохранении колонок PL/Plus представлений, чтобы Навигатор при показе
форматировал такие колонки в соответствии с обычным форматированием
логических реквизитов.

2.2. Реализована возможность указания ID экземпляра, для которого
следует обновлять кэш после использования оператора UPDATE. По умолчанию,
если такой экземпляр не указан, производится сброс кэша всех
экземпляров изменяемого типа, что в случае изменения какого-то
конкретного экземпляра является действием избыточным. Выражение
для такого экземпляра может быть указано в качестве параметра
псевдофункции object_id прагмы hint, предшествующей оператору UPDATE,
либо подсказки-комментария в самом операторе.
                Пример:
         declare
             ac_ref ref [AC_FIN];
             v_sum [SUMMA];
         begin
             ...
             pragma hint('object_id(ac_ref)');
             update a(a.saldo = a.saldo+v_sum) in [AC_FIN] where a=ac_ref;
             update --+ object_id(ac_ref)
                 a(a.saldo = a.saldo-v_sum) in [AC_FIN] where a=ac_ref;
             ...
         end;

2.3. Оптимизирован анализ исполняемых блоков в PL/Plus на предмет
точек входа оператора return. Расширены текстовые сообщения компилятора.

2.4. Реализована корректная проверка соответствия типов для ссылок на
коллекции и самих коллекций. Ранее эти типы формально считались
совместимыми (что фактически не так), в новой версии эта ошибка
устранена, т.е. напрямую типы считаются несовместимыми, при присваиваниях
производится приведение типов (чтение-запись значения по ссылке) с генерацией
предупреждения для таких присваиваний. В процедуру UPGRADE внесен скрипт,
корректирующий неправильное использование ссылок на коллекции и самих
коллекций в предыдущих версиях.
                Пример:
         declare
             v1 ref [ARRAY_REC];
             v2 [ARRAY_REC];
         begin
             v1 := v2;
             v2 := v1;
         end;
                Код PL/SQL прежних версий:
         declare
             V1 number;
             V2 number;
         begin
             V1 := V2;
             V2 := V1;
         end;
                Cкорректированный код новой версии:
         declare
             V1 number;
             V2 number;
         begin
             Z#ARRAY_REC#INTERFACE.set_coll(V1,' ',V2);
             V2 := Z#ARRAY_REC#INTERFACE.get_coll(V1,' ');
         end;


2.5. Расширены возможности использования функциональных реквизитов:
- после вычитывания структуры по ссылке, эта ссылка передается
  в операцию-реквизит, которая может ее использовать;
- расширен набор параметров для модификатора %attrs (см.п.2.6);
- реализованы предупреждающие сообщения при попытках передачи
  ссылки this в другие операции, процедуры и функции в операциях-
  реквизитах (что чревато бесконечной рекурсией);
- реализована специальная сигнатура операции-реквизита, основанная
  на списке используемых ею реквизитов собственного ТБП (которые
  автоматически добавляются к списку используемых реквизитов в
  других операциях при обращении к функциональному реквизиту),
  что позволяет отслеживать зависимые операции при смене набора
  используемых реквизитов;
- список используемых реквизитов в операции-реквизите определяется
  через обращение по ссылке this (обращения непосредственно к полям
  структуры plp$var$ формально допустимы, однако нежелательны, т.к.
  используемые поля этой структуры в список реквизитов НЕ добавляются,
  и, соответственно, могут не заполняться при вычитывании по ссылке).

В результате операция-реквизит может работать в трех режимах:
1) При вызове по ссылке (точечный вызов при получении значения
  отдельного реквизита) в операцию передается ссылка this, пустая
  структура plp$var$, которая заполняется необходимым набором
  реквизитов, используемых при вычислении значения функционального
  реквизита, тип-владелец реквизита в plp$class (исходный режим 1 п.2.11
  изменений на 01.03.2006).
2) При инициализации уже вычитанной структуры (в интерфейсном пакете
  ТБП) в операцию передается пустая ссылка this и заполненная (полностью)
  структура plp$var$, при этом в инициализационном коде операции реквизита
  изначально пустая ссылка заполняется значением поля ID структуры plp$var$,
  а также передается тип-владелец реквизита в plp$class.
3) При инициализации произвольной структуры (не вычитанной из БД)
  в операцию передается пустая ссылка this и структура plp$var$ "как есть",
  при этом никакой инициализации значения this не производится,
  plp$class также передается пустым (исходный режим 2 из п.2.11
  изменений на 01.03.2006).
При разработке операций-реквизитов, во избежание недетерминированности
результата работы этих операций, алгоритм их работы следует строить так,
чтобы во всех трех режимах получался один и тот же результат (особенно
это касается режимов 1 и 2, когда есть привязка к реальному экземпляру,
т.к. эти режимы могут использоваться в одних и тех же ситуациях в зависимости
от настроек кэширования в типах, операциях). Также следует придерживаться
симметричности установки значений функциональных реквизитов в операциях-
реквизитах при отрабатывании секций execute ("Тело", которая вызывается
после чтения данных из БД) и validate ("Проверка", которая вызывается
перед записью данных в БД).

2.6. Расширены возможности использования модификатора %attrs (см.п.2.12
изменений на 01.03.2006) - добавлена обработка следующих параметров
(параметры не обязательные - их отсутствие означает действие по умолчанию).
  Первый параметр может быть только логической константой (false или true),
которая определяет какие вычисления производить: - как при чтении структуры
из БД (при значении false - по умолчанию, т.е. вызовы секций execute - "Тело" -
операций-реквизитов), либо как при записи структуры в БД (при значении true,
т.е. вызовы секций validate - "Проверка" - операций-реквизитов).
  Вторым параметром может быть задано любое логическое выражение, которое определяет,
содержит ли структура ТБП ссылку на экземпляр, из которого она зачитана
(значение false - по умолчанию - структура интерпретируется как отвязанная от БД,
значение true означает, что ссылка содержится в поле ID). Т.е. по умолчанию
(false) операции-реквизиты вызываются в режиме 3 (см.п.2.5), при значении
true операции-реквизиты вызываются в режиме 2 (см.п.2.5).
  Третьим параметром может быть передано строковое выражение, которое
определяет список квалификаторов функциональных реквизитов, которые
следует вычислять модификатору (список должен быть задан с разделителями - запятыми,
начинаться и заканчиваться также должен запятыми). Если список пуст (или не задан),
тогда вычисляются все функциональные реквизиты в структуре заданного ТБП.
  Само вычисление реквизитов (всех или заданных третьим параметром) производится
в строго определенном порядке (см.п.3.2).
                Пример:
         declare
             v_acc ref [AC_FIN];
             v_rec [AC_FIN];
         begin
             v_rec := v_acc; -- чтение структуры из БД
             ...
             v_rec%attrs(false,false,',MAIN_V_ID,DEPART,');
             -- вычисление только функциональных реквизитов MAIN_V_ID и DEPART
         end;

2.7. Расширены возможности использования глобальных переменных,
описанных как %rowtable-тип или вложенный массив, в других операциях.
Такие переменные могут быть разыменованы вплоть до использования методов
массивов, входящих в структуру %rowtable (чего в прежних версиях
сделать было нельзя).
                Пример:
             Операция [CLASS]::[METHOD] содержит такое описание глобальной
           переменной:
         v_tbl [CLASS]%rowtable;
             Код другой операции:
         begin
             ...
             [CLASS]::[METHOD].v_tbl%id.delete;  -- очистка массива ID
                              -- глобальной переменной [CLASS]::[METHOD].v_tbl
             ...
         end;



        3. Разное.

3.1. Реализованы новые типы для сбора статистики (версии 4.0).
Сбор статистики дополнен режимами сбора точной статистики (с точностью
измерения времени выполнения до сотых долей секунды) и расширенной
статистики (сбор статистики ожиданий). Реализована возможность сбора
статистики для отчетов, выполняемых через сервер отчетов.

3.2. Зафиксирован следующий порядок вызова операций для
функциональных реквизитов (внутри интерфейсного пакета ТБП):
- при чтении (вычислении):
  - для иерархически связанных типов (родитель-потомок) сначала
    происходит вычисление реквизитов родительских типов (в направлении
    от верхнеуровневого родителя к нижнеуровневому), а затем собственных
    реквизитов;
  - в пределах одного типа вызовы происходят по порядку следования
    реквизитов в этом типе;
- при установке значений (сохранении в БД) вызовы происходят в
  обратном порядке по отношению к чтению:
  - для иерархически связанных типов (родитель-потомок) сначала
    происходит установка собственных реквизитов, а затем родительских
    (в направлении от нижнеуровневого родителя к верхнеуровневому);
  - в пределах одного типа вызовы происходят в обратном порядке следования
    реквизитов в этом типе.

3.3. Расширены функции для поиска обратных ссылок. Реализован упрощенный
режим поиска в процедуре valmgr.first_referncing_on.

3.4. Введена жесткая проверка возможности изменения ключевых свойств
операций - функциональных реквизитов на уровне триггера БД.

3.5. Реализован расширенный разбор выражений для сортировки и проверок
доступа для PL/Plus представлений, построенных на выборках с использованием
групповых операторов (UNION/MINUS/INTERSECT). В частности, модификаторы
проверки поэкземплярного доступа (%access_obj, %access_ref) разворачиваются
либо в подзапросы, либо обращаются к контексту прав (в зависимости от
настроек системы и представления).

3.6. Реализована проверка изменения интерфейса операции через
сравнение хэш-значений сигнатур операции и ее глобальных описаний.

----------------------------------------------------------------------
Изменения на 01.03.2006. - версия 6.5 (build 0 Revision 0).

        2. Семантика.

2.1. Реализован модификатор %value для получения строковых значений
реквизитов по значению строкового квалификатора, передаваемого
параметром. Применяется как по ссылке, так и к структуре ТБП.
Можно использовать квалификаторы '%id', '%class' , '%state',
'%collection' для получения значений системных реквизитов.
                Пример:
         declare
             v_acc ref [AC_FIN];
             v_rec [AC_FIN];
             v_str string;
         begin
             v_str := v_acc%value('MAIN_V_ID');
             v_str := v_rec%value('MAIN_V_ID');
         end;

2.2. Реализована генерация макросов BASE$EXECUTE, BASE$VALIDATE,
BASE$GETVARS, BASE$SETVARS для операций, наследующих форму другой
операции, как для расширений операций (п.2.4 изменений на 10.07.2005).
В отличие от макросов для расширений, в макросы для вызова операций
с родительской формой BASE$EXECUTE, BASE$VALIDATE параметром нужно
указать ссылку, по которой будет вызвана операция (в расширениях
эта ссылка всегда предопределена, т.е. это ссылка на себя - this,
поэтому она используется безальтернативно).
                Пример:
        declare
          v_ref ref [CLASS];
        begin
          &BASE$SETVARS;
          &BASE$VALIDATE(v_ref);-- вызов валидатора операции-владельца формы
          &BASE$EXECUTE(v_ref); -- вызов тела операции-владельца формы
          &BASE$GETVARS;
        end;

2.3. Реализована возможность отключения выражения для
навигации по ссылке/коллекции в PL/Plus представлениях:
-- Указывается первым параметром (константой false) при
   соответствующем реквизите в составном выражении.
(Процедура обратная к включению выражения для навигации -
см. п.2.5 изменений на 10.07.2005)
                Пример:
         type main is
           select md(
             md.[DATE_DOC] : C_DATE_DOC,
             md.[DOCUMENT_NUM] : C_DOCUMENT_NUM,
             md.[SUM] : C_SUM,
             md.[ACC_DT].[MAIN_V_ID](false) : C_ACC
           ) in ::[MAIN_DOCUM];
       В прежних версиях для выражения с алиасом C_ACC колонка
    для навигации-проваливания (с префиксом REF) создавалась
    автоматически. В новой версии параметр false предписывает
    не создавать колонку префиксом REF для навигации по ссылке.
    Следует отметить, что этот параметр также влияет на
    ближайший оператор ссылки, по которой выбирается реквизит,
    так что при необходимости тип соединения по этой ссылке
    нужно задавать явно (см. п.2.4 plphints.txt).

2.4. Реализована возможность присвоения разноименных структур,
если одна из структур является статическим курсором.
                Пример:
         declare
           type cursor1 is select a(a,a.main_v_id) in [AC_FIN];
           type t_rec1 is record (a1 ref [ac_fin], a2 string);
           type t_rec2 is record (b1 ref [ac_fin], b2 string);
           vc cursor1;
           v1 t_rec1;
           v2 t_rec2;
         begin
           v1 := v2; -- некорректное присваивание
           vc := v2; -- корректное присваивание
           v1 := vc; -- корректное присваивание
           v1%rowtype := v2%rowtype; -- присваивание по полям
           for (select a(a,a.main_v_id) in [AC_FIN]) loop
             vc := a; -- корректное присваивание
             v1 := a; -- корректное присваивание
             v2 := a; -- корректное присваивание
           end loop;
         end;

2.5. Добавлены новые атрибуты для модификатора %rowtype,
которые передаются как опции в первом строковом параметре
(см. также п.2.5 изменений на 20.09.2004 и п.2.13 изменений
на 5.08.2004):
  nomap  - не выводить поля, которые продублированы из родительских
           типов (существенно для rowtype-структуры или для
           rowtable-структуры с опцией self), к таким полям
           также приравниваются ключевые реквизиты (т.к. они
           автоматически дублируются - через колонку ID);
  nofunc - не выводить поля, соответствующие функциональным
           реквизитам (в SQL-операторах INSERT/UPDATE эта опция
           автоматически включена);
  inner  - разворачивать вложенные подструктуры до скалярных
           составляющих (существенно для структур типов,
           содержащих подструктуры), а также переупорядочить
           поля структуры в соответствии с колонками таблицы типа
           (если таковая имеется).
  В версиях ТЯ до 6.4 дублированные колонки для rowtable-структуры
не отключались вообще, а для rowtype-структуры отключались опцией
self (в ТЯ 6.5 опция self для rowtype-структуры игнорируется, т.к.
все поля в ней и так собственные, для отключения дублированных
колонок создана новая опция nomap).

2.6. Реализовано преобразование оператора IS NOT NULL в два оператора
NOT и IS NULL (которые существенно различаются по времени
выполнения в процедурном коде PL/SQL Oracle8i).
                Пример:
         if x is not null then ...
         преобразуется к
         if not x is null then ...

2.7. Реализована возможность получения ссылки на родительский
экземпляр модификатором %parent для экземпляров типов, являющихся
дочерними по отношению к типу, над которым определен тип-коллекция.
                Пример:
         Пусть есть типы:
         CLASS - некий тип;
         CLASS_ARR - массив над CLASS;
         CHILD_CLASS - дочерний от CLASS.
         declare
             v_obj reference;
             v_refclass ref [CLASS];
             v_refchild ref [CHILD_CLASS];
         begin
             v_refclass := v_refchild;
             v_obj :=  v_refclass%parent;
             v_obj :=  v_refchild%parent; -- до версии 6.5 всегда возвращалось
                       -- пустое значение, теперь возвращается то же, что и
                       -- для ссылки на родителя, т.е. совпадает с v_refclass%parent
         end;

2.8. Добавлены стандартные функции COVAR_POP, COVAR_SAMP.

2.9. Реализовано соединение по ссылке с колонкой ID ссылаемого
типа для типизованного модификатора %ID (%%ID).
                Пример:
         begin
           for (select d(d.[DOCUMENT_USER]%%id) in [DOCUMENT] all)
           loop exit; end loop;
         end;
                Было:
         select  a1.C_DOCUMENT_USER A$1
         from Z#DOCUMENT a1;
                Стало:
         select  a2.ID A$1
         from Z#USER a2, Z#DOCUMENT a1
         where a1.C_DOCUMENT_USER=a2.id(+);

2.10. Расширены возможности использования возвращаемых
значений SQL операторов INSERT/UPDATE/DELETE (return clause)
при применении их к подзапросам в соответствии с возможностями
Oracle9i.
                Пример:
         declare
             r ref ac_fin;
         begin
             update a(a.name=a.main_v_id) in ac_fin where rownum=1
                return a into r;
         end;
                Преобразуется:
         update (
                select a2.C_NAME v$1, a1.C_MAIN_V_ID u$1, a1.ID r$1
                from Z#ACCOUNT a2, Z#AC_FIN a1
                where a1.id=a2.id
                  and (ROWNUM = 1)
         ) set v$1=u$1
                returning r$1 -- returning под Oracle8i и версии ТЯ<6.5
                into R;       -- не поддерживаются


2.11. Реализован механизм функциональных реквизитов в PL/Plus.
Чтение и установка значений функциональных реквизитов осуществляется
через вызов типа операций типа "Реквизит" (значение флага операции - 'A').
Операция, соответствующая функциональному реквизиту находится в том же
типе, что и сам реквизит, имеет короткое и полное имена совпадающие с
коротким и полным именами реквизита, возвращаемое значение совпадает
с типом реквизита (при изменении этих свойств у реквизита, свойства
операции-реквизита изменяются автоматически). Операция типа "Реквизит"
не может вызываться пользователем напрямую, поэтому не имеет свойств,
соответствующих пользовательскому интерфейсу (в т.ч. экранную форму).
Операция имеет жесткий интерфейс, поэтому закладки свойств "Параметры"
и "Переменные" не доступны. Текст операции разбивается на стандартные
составляющие. Глобальные и локальные описания могут содержать общие
для основных процедур описания переменных, типов, функций и процедур.

На закладке "Тело" задается функция, возвращающая значение функционального
реквизита:
function [ATTR_ID](this ref [CLASS], plp$class string, plp$var$ in out [CLASS]) return [ATTR_CLASS_ID];
Функция работает в двух режимах:
1) Если задано не пустое значение ссылки this, тогда по этой ссылке
   зачитывается структура plp$var$, затем идет работа со структурой
   plp$var$.
2) Если ссылка this не задана, тогда работа идет со структурой plp$var$,
   которая заполняется перед вызовом функции. При этом системные реквизиты
   в этой структуре в общем случае не определены и использовать их
   не рекомендуется.
Модификация реквизитов this (равно как и plp$var$) внутри
функции запрещена. Если исходный код не задан, то функция будет
всегда возвращать пустое значение.
Эта функция вызывается из интерфейсного пакета ТБП в первом
режиме при получении значения реквизита по ссылке (точечный вызов),
во втором режиме - при вычитывании всей структуры ТБП (сначала
вычитывается структура без функциональных реквизитов, затем
последовательно вызываются операции функциональных реквизитов,
которым передается только структура, и заполняются поля,
соответствующие этим реквизитам).

На закладке "Проверка" задается процедура, которая устанавливает
значения других реквизитов в зависимости от значений функционального
реквизита:
procedure [ATTR_ID](this ref [CLASS], plp$class string, plp$var$ in out [CLASS]);
Процедура работает также в двух режимах:
1) Если задано не пустое значение ссылки this, тогда по этой ссылке
   зачитывается структура plp$var$, затем идет работа со структурой
   plp$var$, затем измененные реквизиты сохраняются в БД по заданной
   ссылке.
2) Если ссылка this не задана, тогда работа идет со структурой plp$var$,
   заполняется перед вызовом функции, измененные значения реквизитов
   при этом в БД не сохраняются, а возвращаются через структуру plp$var$.
Эта процедура вызывается из интерфейсного пакета ТБП в первом
режиме при установке значения реквизита по ссылке (точечный вызов),
во втором режиме - при записи всей структуры ТБП (сначала
процедуре передается исходная структура для сохранения в БД,
затем последовательно вызываются операции установки функциональных
реквизитов, которым передается только структура и которые модифицируют
поля этой структуры, полученная в результате всех этих вызовов структура
сохраняется в БД).
Если исходный код процедуры не задан, тогда в первом режиме будет
сгенерировано исключение, а во втором режиме никаких модификаций
структуры не будет.

Переменные plp$class и plp$var$ - служебные, их обработка и заполнение
происходит на уровне системного кода операций, зависящего от версии ТЯ,
поэтому прямое использование этих переменных категорически не рекомендуется,
т.к. это может нарушить логику работы системного кода. Для обращения к
полям структуры plp$var$ следует использовать стандартные обращения к
реквизитам текущего экземпляра this (т.е. ссылке на себя), которые будут
автоматически преобразованы к полям структуры plp$var$ (по принципу
кэширования экземпляра this в простых операциях, что автоматически
означает невозможность отключение кэша this в операции-реквизите).

2.12. В операциях и PL/Plus представлениях обращения к функциональным
реквизитам транслируются в соответствующие вызовы интерфейсных
пакетов ТБП, которые, в свою очередь, вызывают операцию типа "Реквизит".
Для инициализации произвольной структуры, содержащей функциональные
реквизиты, реализован модификатор %attrs. Он применяется к структуре
типа, так что его поведение сходно с модификатором %init. При
чтении структуры из БД по ссылке вычисление функциональных реквизитов
происходит в момент чтения (соответственно, установка других реквизитов
на основании значений функциональных реквизитов происходит в момент
сохранения структуры в БД), в дальнейшем поля структуры автоматически
не пере вычисляются при модификации полей структуры. Если это требуется
сделать, тогда нужно использовать модификатор %attrs явно.
                Пример:
         declare
             v_acc ref [AC_FIN];
             v_rec [AC_FIN];
         begin
             v_rec := v_acc; -- чтение структуры из БД
             ...
             v_rec%attrs;  -- вычисление функциональных реквизитов
         end;
Если в типе задано несколько функциональных реквизитов, то их вычисление
происходит в том порядке, который задан при описании типа. Установка
значений происходит в обратном порядке.
Внутри самих операций-реквизитов препроцессинг функциональных реквизитов
собственного типа не производится (т.е. собственные функциональные
реквизиты используются только как поля структуры plp$var$ без всяких
вычислений).



2.13. Реализовано SQL-выражение для функциональных реквизитов.
Задается первым выражением выборки, задаваемой глобальным курсором
MAIN в операции-реквизите. Тип выражения должен соответствовать
типу реквизита. Для типа BOOLEAN задать SQL-выражение нельзя,
т.к. этот тип непосредственно в SQL не поддреживается.
При использовании обращений к этому реквизиту из выборок в
других операциях, это обращение будет заменено на заданное
SQL-выражение операции-реквизита. Такая заменане может
использоваться после применения модификаторов, которые могут
быть разыменованы (%parent, %insert, %locate).
Отключить использование SQL-выражения можно, отключив опцию
code в pragma optimize.
                Пример:
         Пусть в типе USER задан функциональный строковый
         реквизит EMAIL, для которого задано SQL выражение:
         type main is
            select u(decode(u.[depart],null,'support@ftc.ru',
                   u.[username]||'@'||u.[depart].[code]||'.ru')
	         ) in [USER];
                Тогда выборка
          select x(x.[document_user].[email]) in [document]
                будет интерпретирована так:
          select x(decode(x.[document_user].[depart],null,'support@ftc.ru',
            x.[document_user].[username]||'@'||x.[document_user].[depart].[code]||'.ru')
           ) in [document]

2.14. В ТЯ 6.5 реализована возможность использования ключевых
реквизитов, которые отображаются на строковую колонку ID таблиц
типов. При использовании ключевых и функциональных реквизитов в
PL/Plus запросах дополнительное соединение по ссылке с целевой
таблицей не делается, используется непосредственно значение самой
ссылки.


        3. Разное.

3.1. Расширены процедуры и функции пакета STDIO для работы
с буфером сессии и пайпами (см. stdio.txt).

3.2. В PL/Plus представлениях реализован анализ выражения выборки
с заданным алиасом ID (определяющим значения идентификаторов
экземпляров, выбираемых представлением) с дальнейшим заполнением
свойств представления BaseClass, BaseClassIncompatible. Ранее
эти свойства определялись исходя из первого типа в списке выборки
основного курсора представления.
                Пример:
         type main is
	        select r (
                   r.stats.group_id : id,
		   count(1) : counter
		 ) in [RUNS]
		group by r.stats->(false)group_id;
         До версии 6.5 тип выборки (BaseClass) определялся как RUNS
         (по выражению в списке in), в версии 6.5 тип определяется
         как RUN_GROUPS (из выражения r.stats.group_id).

3.3. Реализовано отображение типа OBJECT в структуру rtl.object_rec.
Т.е. теперь типы [OBJECT] и rtl.object_rec стали синонимами.
Соответственно и скорректированы модификаторы PL/Plus для обобщенных
ссылок (ссылок на OBJECT).

3.4. Реализован расширенный парсинг PL/SQL пакетов, что позволяет
использовать более строгую типизацию в используемых пакетами типов,
переменных, функций и процедур.

3.5. Реализован дополнительный вызов cast для вложенных таблиц под
Oracle8i в SQL-запросах (workaround баги Oracle).

3.6. Скорректирована генерация временной переменной для циклов
присвоения массивов (п.2.14 изменений на 05.08.2004.) и присвоения
NULL структурам.

3.7. Реализован оптимизированный алгоритм определения типа экземпляра
в интерфейсных пакетах операций в соответствии с настройкой Навигатора
NAV.METH.OVERLAPPING. При включенной настройке интерфейсный пакет
полностью полагается на то значение, которое устанавливается Навигатором
и не перечитывает его.

3.8. Реализован механизм кэширования метаданных словаря IBSO для
оптимизации компиляции. Кэшируются описания типов, их таблиц и
реквизитов. Реализовано в пакете LIB, соответственно, все его
функции работы со словарем используют работу через кэш. Препроцессор
PL/Plus также работает через пакет LIB. Для обновления значения
кэша словаря задействовано новое событие в системе под номером 14.

3.9. Реализованы разные механизмы кэширования в пакетах
VALMGR, LIB, STDIO для версий Oracle8i и Oracle9i.
Кэширование данных под Oracle9i использует массивы со
строковыми индексами.

3.10. Реализована генерация виртуальных родительских
контролов на формах операций для зависимостей параметров,
не имеющих родительских (оптимизировано обновление
ссылок виртуальных контролов).

3.11. Реализована поддержка использования системных реквизитов
(ID,CLASS_ID,STATE_ID,COLLECTION_ID) на формах операций
по квалификаторам %id, %class, %state, %collection.

3.12. В связи с возможностью использования символьных идентификаторов
дополнительно изменены интерфейсы всех функций ТЯ, работающих
с экземплярами, т.е. везде, где в качестве параметров используются
ID экземпляров числовой тип заменен на строковый. В Pl/Plus
тип ссылок определяется в соответствии со свойствами типа.

3.13. Изменена структура и типы колонок системных представлений.
Созданы два представления для экземпляров:
  OBJECTS  - с числовым ID,
  OBJECTSS - со строковым ID (туда включены и таблицы ТЯ, соответствующие
             метаклассам).
Изменен тип колонки OBJECT_ID системных представлений VW_C2O_<CLASS>
и COL2OBJ с числового на строковый.

3.14. Изменены типы колонок таблиц ТЯ, содержащих ID экземпляров,
с числового на строковый:
  OBJ_STATIC.ID
  LONG_DATA.OBJECT_ID
  OBJECT_RIGHTS.OBJ_ID
  OBJECT_RIGHTS_EX.OBJ_ID
  OBJECT_RIGHTS_LIST.OBJ_ID
Соответственно, изменены интерфейсы и логика функций администрирования
и проверки поэкземплярного доступа и трансляции правил доступа.
При смене типа колонки ID в таблице ТБП происходит также конвертация
данных в этих таблицах. При использовании таблиц экземплярного доступа
в подзапросах PL/Plus и условии проверки доступа в представлениях
в необходимых случаях используется явное приведение типов.

3.15. Изменен тип колонки OBJ_ID в журналах схемы AUD с числового
на строковой. Реализованы процедуры конвертации данных (просто
конвертация - без перетрансляции):
Журнал изменения реквизитов - <owner>_VALSH.OBJ_ID
Журнал изменения состояний - <owner>_OSH.OBJ_ID
Журнал изменения коллекций - <owner>_OCH.OBJ_ID
Журнал электронного документооборота - <owner>_EDH.OBJ_ID

3.16. Разработан пользовательский интерфейс для получения информации
по журналам истории изменений (библиотека SYS_DIARYS.HLIB).

----------------------------------------------------------------------
Изменения на 10.08.2005. - версия 6.4 (build 0).

        2. Семантика.

2.1. В PL/Plus представлениях добавлена возможность установки
дополнительных атрибутов колонок через прагму SET_COLUMN.
Прагма SET_COLUMN принимает 3 параметра:
  - алиас колонки, которой устанавливается атрибут;
  - имя атрибута;
  - строковое значение;
и должна быть указана до описания основного курсора MAIN.

Могут быть установлены следующие атрибуты:
NAME  - наименование колонки,
WIDTH - ширина колонки,
DATA_PRECISION - точность значений колонки,
ALIGN - выравнивание значений колонки:
      0 - по левому краю,
      1 - по правому краю,
      2 - по центру;
SIZEABLE - признак изменения размера колонки:
      0 - изменение размера запрещено,
      1 - изменение размера разрешено;
UNVISIBLE - признак видимости колонки:
      0 - колонка видимая (с префиксом C_ в самом представлении)
      1 - колонка невидимая (только для связи, в самом представлении не участвует)
      2 - колонка невидимая (с префиксом U_ в самом представлении);
TARGET_CLASS_ID - переопределение ссылаемого типа (для навигации),
                  тип может быть переопределен только в пределах иерархии
                  типа, которым определено выражение для значения колонки.
Атрибуты, устанавливаемые с помощью прагмы, имеют наивысший приоритет,
т.е. они переопределяют значения, задаваемые в форме редактирования
свойств колонок представления в Администраторе словаря данных.
                Пример:
         pragma set_column(sname,name,'Сетевое имя');
         pragma set_column(sname,align,'2');
         pragma set_column(name,name,'Полное имя');
         pragma set_column(name,width,'50');
         type main is
           select u(u.username:sname,u.name:name) in [USER];

2.2. Добавлена возможность предварительного препарсинга хинтов
для PL/Plus запросов, т.е. реализована функция получения алиасов
таблиц по их квалификатору из PL/Plus запроса. Выражение для
преобразования квалификатора в алиас таблицы распознается в хинтах
как параметр псевдофункции plp$hint, причем plp$hint распознается
простым поиском подстроки, причем именно в нижнем регистре.
В самом выражении можно указать явно для какой таблицы требуется
получить алиас (т.к. для иерархических типов один квалификатор
указывает на весь набор таблиц от текущего типа до всех его
родителей), указав имя таблицы в конце задаваемого выражения
через разделитель '|' (если таблица не указана, тогда выбирается
алиас первой таблицы, которая была присоединена по заданному
квалификатору). Синтаксис квалификатора стандартный, т.е.
список реквизитов, разделенных точками.
                Пример:
         pragma hint('first_rows leading(plp$hint(d.[acc_dt]|Z#AC_FIN))');
         type main is
           select d(d.[acc_dt].[main_v_id] : ac_dt,
                    d.[acc_kt].[main_v_id] : ac_kt,
                    d.[date_prov] : dprov,
                    d.[document_date] : dcreate)
               in [MAIN_DOCUM]
            where d.[acc_dt].[main_v_id] like sys_context(user_context,'MY_ACC') and
               d.[date_prov]>=to_date(sys_context(user_context,'MY_DATE'),'DD/MM/YYYY');
                Примерный результирующий SQL-запрос:
SELECT /*+ first_rows leading( a2 ) */
A1.Id ID, a1.CLASS_ID Class_Id, a1.STATE_ID State_Id,
a2.C_MAIN_V_ID AC_DT,
a3.C_MAIN_V_ID AC_KT,
a1.C_DATE_PROV DPROV,
a4.C_DOCUMENT_DATE DCREATE
from Z#DOCUMENT a4, Z#AC_FIN a3, Z#AC_FIN a2, Z#MAIN_DOCUM partition(Z#MAIN_DOCUM#0) a1
where a1.key=1000 and a1.C_ACC_DT=a2.id and a1.C_ACC_KT=a3.id(+) and a1.id=a4.id
  and (a2.C_MAIN_V_ID like SYS_CONTEXT('DEV_USER','MY_ACC')
  and a1.C_DATE_PROV >= TO_DATE(SYS_CONTEXT('DEV_USER','MY_DATE'),'DD/MM/YYYY'))


        3. Разное.

3.1. В режиме кэширования экземпляра this конструкция вычисления
this%class использует вычисленное ранее значение в локальной
переменной plp$class$. Это сделано для того, чтобы сократить
запросы к БД для определения типа текущего экземпляра. Для
того, чтобы явно выполнить запрос модификатору %class нужно
указать первым параметром значение true. Общее поведение системы
регулируется системным параметром PLP_CACHE_CLASS (в таблице
SETTINGS), который по умолчанию включен и выражение this%class
кэшируется в plp$class$. Проблема с использованием этого
режима может возникать, если в операцию исходно передается
неправильный тип (при вызове из других операций это исключено,
при выполнении через Навигатор этот самый тип задает сам Навигатор,
и в случае вызова операции через представление родительского
типа старые версии Навигатора передают именно родительский
тип, а не фактический тип экземпляра).
                Пример:
        begin
          s := this%class; -- кэшируется по умолчанию (по настройке PLP_CACHE_CLASS)
          s := this%class(true); -- не кэшируется через plp$class$
          s := this%class(false); -- кэшируется через plp$class$
        end;


----------------------------------------------------------------------
Изменения на 10.07.2005. - версия 6.4 (build 0).

        2. Семантика.

2.1. Реализован универсальный формат вызова операций. При
установленном свойстве "Допускает вызов в универсальном формате"
в операции генерируется структура с именем all_params_type и
с полями, соответствующими набору параметров операции, и процедур
execute/validate, которым передается эта структура одним (единственным)
in out параметром с именем p$. При этом универсальный формат вызова
валидаторов перекрывается вызовом расширений (при их наличии -
как и executor-ов). Универсальный формат при вызове распознается
при явном указании имени параметра p$.
                Пример:
        Пусть есть операция [CLASS]::[METHOD], в которой
        определены 3 параметра P1,P2,P3.
        declare
          v_par [CLASS]::[METHOD].all_params_type;
        begin
          ...
          this.[METHOD](v_par.P1,v_par.P2,v_par.P3); -- обычный вызов
             -- должен изменяться при изменении набора параметров
          this.[METHOD]( p$ == v_par ); -- универсальный вызов
             -- не изменяется при изменении набора параметров
        end;

2.2. Добавлен дополнительный параметр (p_info) в
модификатор %lock. Таким образом можно переопределить
сопутствующую блокировке информацию. Таким образом,
полный формат вызова %lock выглядит так:
    v_ref%lock{({/true false/,}p_class string{,p_wait integer{,p_info string}})}
где v_ref - ссылка на экземпляр,
    /true false/ - режим блокировки - не ждущая или ждущая (по умолчанию true -
              не ждущая, ждущая же блокировка подразумевает бесконечное время
              ожидания). Если задано ожидание p_wait, то этот параметр
              не существенен.
    p_class - тип экземпляра (если задан не пустым, то тип экземпляра
              внутри %lock уже не определяется),
    p_wait  - время ожидания блокировки в сек. (если задано не пустым,
              то %lock крутит циклы ожидания в течение указанного времени,
              иначе используются стандартные настройки),
    p_info  - пользовательская информация о блокировке. Если не задана или
              задана пустой, то используется стандартная информация в формате
              [CLASS]::[METHOD] той операции, которая устанавливает блокировку.
                Пример:
        declare
          v_ref    ref [class];
          v_cls    string;
        begin
          v_cls := v_ref%class;
          v_ref%lock(v_cls); -- обычная блокировка
          v_ref%lock(v_cls,null,'Альтернативная информация');
        end;

2.3. Добавлены новые флаги для параметров и переменных
операций для поддержки производных типов ТБП. Полный список
флагов:
A - [CLASS]%rowtype;              -- Rowtype тип (новый флаг)
B - [CLASS]%rowtable;             -- Rowtable тип (новый флаг)
C - varray(0) of [CLASS]%rowtype; -- Вложенный массив Rowtype типа (новый флаг)
D - [CLASS];                      -- Собственно тип
R - ref [CLASS];                  -- Ссылка на тип
T - table of [CLASS];             -- Индексированный массив типа
где CLASS - тип, задаваемый при описании параметра.
(Типы Rowtype, Rowtable - см.п.2.2 изменений от 05.08.2004).
Для флагов С и Т (массивов) в операции дополнительно объявляются
соответствующие декларации типов (через которые и определяются
параметры-массивы):
  type CLASS_TBLROW is varray(0) of [CLASS]%rowtype; -- флаг C
  type CLASS_TABLE  is table of [CLASS];             -- флаг Т
Эти типы публичные и могут использоваться в других операциях.

2.4. Расширены возможности использования расширений операций.
Добавлены специальные макросы для вызова базовой операции
из расширения:
BASE$EXECUTE  - вызов тела базовой операции (передаются одноименные
                параметры расширения)
BASE$VALIDATE - вызов валидатора базовой операции (передаются одноименные
                параметры расширения)
BASE$SETVARS  - установка глобальных переменных базовой операции
                из глобальных переменных расширения
BASE$GETVARS  - установка глобальных переменных расширения
                из глобальных переменных базовой операции
Макросы определены только в расширениях, в остальных операциях
эти макросы содержат в себе null-оператор.
                Пример:
        Стандартный код тела операции-расширения теперь выглядит так:
          begin
          &BASE$SETVARS;
          &BASE$EXECUTE;
          end;
        Стандартный код валидатора операции-расширения теперь выглядит так:
          begin
          &BASE$SETVARS;
          &BASE$VALIDATE;
          &BASE$GETVARS;
          end;

2.5. Реализована возможность указания выражения для
навигации по ссылке/коллекции в PL/Plus представлениях.
-- Указывается первым параметром (константой true) при
   соответствующем реквизите в составном выражении (раньше
   использовался всегда только первый реквизит).
-- Расширена генерация значений квалификаторов для представлений.
   Теперь квалификатор может содержать в себе переопределение
   типа при разыменовании ссылок и коллекций:
   {CLASS1:}ATTR1.{CLASS2:}ATTR2. ...
                Пример:
         type main is
           select md(
             md.[DATE_DOC] : C_DATE_DOC,
             md.[DOCUMENT_NUM] : C_DOCUMENT_NUM,
             md.[SUM] : C_SUM,
             decode(md.[KL_DT].[0],
               1,md.[KL_DT].[1].[2]->[MAIN_V_ID](true),
               2,md.[KL_DT].[2].[1]->[MAIN_V_ID]) : C_ACC,
	     md%State : C_STATE,
             md.[CORRECTION_DOC]->(::[MAIN_DOCUM])[NAZN] : C_COR_NAZN
           ) in ::[MAIN_DOCUM];
       В прежних версиях для выражения с алиасом C_ACC колонка
    для навигации-проваливания (с префиксом REF) не создавалась,
    т.к. исходным выражением для формирования ссылки являлось
    первое выражение (md.[KL_DT].[0]), для которого источником
    является базовая таблица с алиасом md (в такой ситуации колонка
    REF не создается). В версии 6.4 исходным выражением задано
    выражение md.[KL_DT].[1].[2]->[MAIN_V_ID] (указан параметр true),
    для которого источником является ссылка на счета, поэтому
    будет сформировано выражение для колонки REF - md.[KL_DT].[1].[2],
    которое будет использоваться при навигации. Соответственно,
    из этого же выражения будет сформирован квалификатор этой колонки.
    Для выражения с алиасом C_COR_NAZN будет сформирован расширенный
    квалификатор (CORRECTION_DOC.MAIN_DOCUM:NAZN), т.к. использовано
    переопределение типа.


2.6. Реализованы представления для просмотра вложенных массивов
(при проваливании по реквизиту - вложенному массиву).

  Представления для просмотра вложенных массивов могут
быть только PL/Plus-типа и в них должен быть задан квалификатор
родительского реквизита типа NESTED TABLE в расширенном
формате (п.2.5), т.е. <parent class>:<parent qual>,
который задается атрибутом NESTED_QUAL представления
(колонкой в CRITERIA).
  В описании курсора PL/Plus обращение ко вложенному массиву,
по которому строится представление, осуществляется по
имени V$NESTED (эта переменная объявляется автоматически).
Такие представления могут использоваться только для просмотра
вложенных массивов (т.е. при проваливании по вложенному массиву).
При этом в представления автоматически добавляется колонка с
алиасом NT$ID, куда выбирается значение ID родительского
экземпляра-контейнера (если такая колонка в представлении определена
явно, тогда используется явное описание, как и для других системных
колонок).

  Колонка - вложенный массив в родительском представлении
имеет следующий вид при показе в Навигаторе (по аналогии
с обычными коллекциями):
  Колонка-значение (c префиксом С_)
    если не задана точность - DATA_PRECISION (или задана 0)
      [...] - пустой массив
      [***] - не пустой массив
    если задана точность (не равная 0), тогда
      [N] - где N - количество элементов массива
  Колонка-ссылка (c префиксом REF) для навигации (проваливания):
    значение ID родительского экземпляра-контейнера вложенного
    массива.

Атрибуты колонки вложенного массива (таблица CRITERIA_COLUMNS):
  REF_TYPE='2'
  BASE_CLASS_ID='TABLE'
  TARGET_CLASS_ID - ID целевого типа (куда осуществляется проваливание)
  REF_QUAL - квалификатор (реквизит) родительского экземпляра-контейнера

Навигация (проваливание) осуществляется так:
- Определяется квалификатор вложенного массива (nested_qual для
  целевого типа):
  - если ref_qual пуст, то он равен квалификатору колонки,
    а ID и тип родительского экземпляра определяются колонками
    ID и CLASS_ID представления (т.е. nested_qual = <class_id>:QUAL)
  - если ref_qual не пуст, то nested_qual = TARGET_CLASS_ID:REF_QUAL.
- В целевом типе ищутся представления с получившимся значением
  NESTED_QUAL и накладывается условие на колонку NT$ID (ID родительского
  экземпляра-контейнера).
                Пример:
        Пусть есть типы:
          [CLASS]  - некий тип
          [TARGET] - другой тип
          [TARGET_ARR] - тип вложенный массив над типом [TARGET]
        В типе [CLASS] определены реквизиты [ATTR] (скалярного типа) и
        [PARENT_ATTR] (типа [TARGET_ARR], т.е. вложенный массив элементов
        типа [TARGET]).
        В типе [TARGET] определены скалярные реквизиты [ATTR1] и [ATTR2].
        В типе [CLASS] создано некое представление, определенное так:
          type main is
            select c(
              c.[attr]:c_attr,       -- квалификатор колонки будет ATTR
              c.[parent_attr]:c_arr  -- квалификатор колонки будет PARENT_ATTR
            ) in [CLASS];
        В типе [TARGET] создано представление для вложенных массивов
        (у которого NESTED_QUAL равен CLASS:PARENT_ATTR, соответственно,
        это представление может использоваться для навигации из описанного
        выше представления из колонки c_arr), определенное так:
          type main is
            select c(
              c.[attr1],
              c.[attr2]
            ) in V$NESTED;


2.7. Препроцессором PL/Plus разрешен вызов в SQL-выражениях
функций, не обладающих прагмой restrict_references. Добавлена
дополнительная диагностика при использовании boolean типа в
SQL-выражениях. Теперь при использовании функций, не обладающих
прагмой restrict_references (WNDS) производятся следующие
действия:
   а) если в фактических параметрах функции нет используемых
      в запросе колонок таблиц, то такая функция выносится
      из SQL-выражения, т.е. заменяется на используемую временную
      переменную, которой предварительно присваивается значение
      функции.
   б) если в фактических параметрах функции используются колонки
      таблиц из запроса, то выдается предупреждение (в прежних версиях
      была ошибка) и функция остается в SQL-выражении.


2.8. Реализована возможность указания в обобщенной ссылке (reference)
типа экземпляра в формате CLASS_ID:OBJECT_ID. Процедуры обработки
обобщенных ссылок в пакете RTL (rtl.object..., rtl.get_value,
rtl.set_value, rtl.change_state, rtl.lock_object, rtl.get_object)
правильно разбирают такой формат. Собственно, для разбора ссылки
используется одна процедура rtl.get_class.
                Пример:
        declare
          v_ref reference;
          v_pr ref [PRODUCT];
          b boolean;
        begin
        ...
          v_ref%id := v_pr%class||':'||v_pr%id;
          [OBJ_REF]:= v_ref;  -- присвоение реквизиту - обобщенной ссылке,
            -- в Навигаторе по такой ссылке можно будет попасть сразу в нужный тип
          b := v_ref%class=v_pr%class; -- вернет true, т.к. v_ref%class возвращает
            -- значение через функцию rtl.object_class, которая правильно
            -- распознает расширенный формат обобщенной ссылки.
        ...
        end;



        3. Разное.

3.1. Реализована синхронизация описаний глобальных переменных,
функций, процедур операций и их синонимов. Это исключает
разное прочтение обращений к таким глобальным описаниям,
которые делаются через прямое обращение к операции или
опосредованно, через синоним.
                Пример:
        Пусть есть операция [RUNTIME]::[STDLIB], в которой
        определена функция USERID и для которой создан синоним
        STDLIB:
           function USERID return ref [USER];
        declare
          s string;
          pragma pl_sql(true);
        begin
          s := [STDLIB].UserID.Username; -- обращение напрямую
          s := STDLIB.UserID.Username; -- обращение через синоним
          -- в ранних версиях это привело бы к ошибке, т.к. в описании
          -- синонима функция UserID имела бы тип number, а не ref [USER].
        end;

3.2. Оптимизированы процедуры компиляции операций по зависимостям.
Теперь сами эти процедуры выстраивают правильный порядок компиляции
(раньше порядок был случайный, не зависящий от перекрестных ссылок).
Оптимизирована процедура разбора pl/sql пакетов method.parse_packages.
(Удаление неиспользуемых описаний по окончании разбора всех пакетов
- в отдельной транзакции. Раньше все описания сначала полностью
удалялись, затем создавались новые, при этом в случае ошибки
выполнения method.parse_packages описания для не разобранных
пакетов отсутствовали).

3.3. Добавлена возможность прерывания процесса компиляции операций
и выполнения хранения типов (списком). Эти процессы периодически
вычитывают командные пайпы <OWNER>.PROCESS_METHODS и
<OWNER>.PROCESS_CLASSES, соответственно. При получении из этих
пайпов команды STOP, процесс компиляции завершается (эту
команду посылает процедура method.set_stop_flag)

3.4. Реализована возможность прямых вызовов операций
переходов в интерфейсных пакетах типов при смене
состояний. Это позволяет снизить накладные расходы на
динамический вызов операций переходов, а также получить
полноценный стек ошибок в случае возникновения исключений.

3.5. Кэширование экземпляров на уровне интерфейсных пакетов
типов получило дальнейшее развитие. Реализована возможность
указания отдельных некэшируемых реквизитов, которые часто
изменяются. Реализован кэш THIS операций через использование
кэша интерфейсных пакетов.

3.6. Добавлен ряд сервисных процедур и функций в пакеты LIB и RTL:
    LIB.SOFT_REPLACE  - поиск и замена case insensitive (регулярного выражения)
    RTL.GET_DEBUG_ALL - получение ВСЕХ атрибутов отладчика пакета RTL
    RTL.SET_DEBUG_ALL - установка ВСЕХ атрибутов отладчика пакета RTL

----------------------------------------------------------------------
Изменения на 20.01.2005. - версия 6.3 (build 1).

        2. Семантика.

2.1. Реализована возможность вызова конструктора для создания экземпляра
дочернего типа в коллекции родительского. Это можно сделать путем
стандартного переопределения типа в операторе ссылки (т.е. указанием
в качестве параметра того ТБП, в котором требуется создать экземпляр),
применяемой к коллекции.
                Пример:
        Пусть есть типы
        некий [PARENT_CLASS],
        дочерний от него [CHILD_CLASS],
        тип-коллекция [PARENT_CLASS_ARR], ссылающийся на [PARENT_CLASS],
        конструктор [NEW#AUTO] в типе [PARENT_CLASS] - без параметров;
        declare
          pr ref [PARENT_CLASS];
          cr ref [CHILD_CLASS];
          cl [PARENT_CLASS_ARR];
        begin
          pr := [PARENT_CLASS]::[NEW#AUTO]; -- создание экземпляра типа [PARENT_CLASS]
          сr := [CHILD_CLASS]::[NEW#AUTO]; -- создание экземпляра типа [CHILD_CLASS]
          pr := cl.[NEW#AUTO]; -- создание экземпляра типа [PARENT_CLASS] в коллекции cl
          cr := cl->(::[CHILD_CLASS])[NEW#AUTO]; -- создание экземпляра типа [CHILD_CLASS]
                               -- в коллекции cl родительского типа [PARENT_CLASS]
        end;

2.2. Добавлена прагма TYPED_JOINS, которая определяет режим использования
типизованных ссылок. Когда включается режим типизованных ссылок (с помощью
указания значения true в качестве параметра), то все обращения по любым ссылкам
(а также модификаторам) интерпретируются как типизованные. Если режим
выключается (false в качестве параметра), то типизация ссылки или модификатора
может быть указана только явно (символом '%' - см.п.1.8 изменений на 05.08.2004).

        3. Разное.

3.1. Разъяснение по использованию оператора проверки на пустое значение
(операторы is null, is not null) и массивов. Такая проверка имеет смысл
только для вложенных (nested) массивов и фиксированных (varray) массивов,
которые могут иметь пустое значение. Обычные же индексированные (index by)
массивы пустого значения иметь не могут, поэтому проверка на пусто для
них бессмысленна, для них следует проверять наличие или отсутствие
элементов в массиве.

3.2. Более строгими стали проверки структуры выражений и списков
выражений и операторов. Старые версии препроцессора PL/Plus могли
пропускать ошибку отсутствия точки при разыменовании полей структур
или по ссылке, а также могли пропускать ошибку отсутствия разделителей
в списках: например, отсутствие запятой при формировании списков
фактических значений в вызовах функций и процедур, или отсутствие
точки с запятой между исполняемыми операторами внутри операторов-блоков.
                Пример:
    1. Пропущенный разделитель "запятая"
    -- в описании параметров функций и процедур
        function sub1(
	  par1 in varchar2
	  par2 number
         );
        function sub2(par2 in varchar2 nocopy);
    -- в списке фактических параметров при вызове операции
        [METHOD](v_ref.[ATTR1] par_value)
    -- в списке IN
        select a(a%id) in [CLASS_1] where a.[ATTR_1] in ('1' this.[ATTR1] v_var)

    2. Разделитель "точка с запятой"	
        begin
	  [METHOD_1]
	  [METHOD_2]
        end;

    3. Разделитель %
        [COLLECTION_1]insert

    4. Разделитель "точка"
        [REF_1][ATTR_1]

Скрипты обновления версии ТЯ пытаются исправлять некоторые из указанных ошибок,
однако они не гарантируют полного исправления всех таких ошибок, поэтому
некоторые операции могут быть модифицированы только вручную.

3.3. Изменена схема отображения индексированных массивов, элементами
которых являются типы-ссылки на метаклассы. В прежних версиях такие
типы отображались на системный PL/SQL тип RTL.REFERENCE_TABLE, который
представляет собой индексированный массив чисел. Т.к. значения ссылок
на метаклассы могут быть строковыми, то этот тип не подходил для
хранения таких ссылок. Поэтому в версии 6.3 массивы ссылок на
метаклассы стали отображаться на другой системный PL/SQL тип
RTL.REFSTRING_TABLE, который представляет собой индексированный массив
строк длины 128, этот тип является более универсальным и может
хранить в себе и числа (каковыми являются ссылки на обычные ТБП) и строки
(каковыми являются ссылки на метаклассы). В связи с этим, не рекомендуется
использовать системные PL/SQL типы-массивы пакетов RTL или CONSTANT
непосредственно. Рекомендуется объявлять собственные PL/Plus типы
(например, основанные на ТБП - см.п.2.2 изменений на 05.08.2004),
которые и будут отображены в необходимых случаях на системные
типы (см.п.2.4 изменений на 05.08.2004), в противном случае возможна
несовместимость с предыдущими версиями при использовании массивов-
ссылок на метаклассы и явным использованием системных типов
RTL.REFERENCE_TABLE и RTL.REFSTRING_TABLE.

----------------------------------------------------------------------
Изменения на 25.10.2004. - версия 6.3 (build 1).
	
        2. Семантика.

2.1. Синтаксис типизованной ссылки (п.1.8 изменений на 05.08.2004) при применении
к ссылке на ссылку не проваливается через ссылаемый тип, как это делает обычный
оператор ссылки.
                Пример:
        declare
          u ref [USER_REF];
        begin
          u.[DELETE#AUTO]; -- вызов деструктора в типе [USER_REF]
          u->[DELETE#AUTO]; -- вызов деструктора в типе [USER], на который ссылается [USER_REF]
          u%->[DELETE#AUTO]; -- вызов деструктора в типе [USER_REF]
        end;

2.2. Новая версия процесса LOCK_INFO способна работать со списками
блокировок, задаваемых таблицами TYPE_NUMBER_TABLE,TYPE_REFSTRING_TABLE
(п.2.4 изменений на 05.08.2004). Для работы со списком блокировок
массивы таких блокировок нужно передать через процедуру RTL.SET_IDS,
после чего в следующем вызове процедуры работы с блокировками (
RTL.LOCK_PUT,RTL.LOCK_PUT_GET,RTL.LOCK_PUT_PUSH,RTL.LOCK_GET,
RTL.LOCK_GET_PUSH,RTL.LOCK_DEL) следует указать пустое значение
для параметра P_OBJECT. В более высокоуровневую процедуру
EXECUTOR.LOCK_REQUEST список блокировок можно передать через
строковый параметр P_OBJECT, причем в этом случае ID блокировок
в списке должны быть разделены запятыми, а сам список должен начинаться
с запятой.

        3. Разное.

3.1. Реализована поддержка расширений операций и представлений.
Вызовы EXECUTE секции операции, которая имеет расширение, автоматически
перенаправляются на вызов расширения. В операции-расширении должен
обязательно присутствовать вызов расширяемой операции.

3.2. Реализовано опциональное кэширование экземпляров на уровне интерфейсных
пакетов типов. Синхронизация кэшей реализована через события и их
рассылку в пакете CACHE_MGR. В типах, в которых включено кэширование,
при компиляции операторов управления транзакциями commit и rollback,
автоматически используются процедуры CACHE_MGR.CACHE_COMMIT и
CACHE_MGR.CACHE_ROLLBACK независимо от флага компиляции "Использовать
функции кэширования". Рекомендуется использовать новую возможность
для типов, в которых изменения экземпляров происходят редко, что подходит
для большинства справочников.

3.3. Реализована возможность корректировки ссылаемого типа в PL/Plus
представлениях (в пределах иерархической связи родитель-потомок). В прежних
версиях переопределение ссылаемого типа возможно было только через
функцию cast_to в тексте курсора, по которому строилось представление.

----------------------------------------------------------------------
Изменения на 20.09.2004. - версия 6.3 (build 0).
	
        2. Семантика.

2.1. Реализован новый тип массивов - вложенные массивы (NESTED TABLES) на
уровне словаря данных IBSO. Для поддержки этого реализовано автоматическое
создание соответствующих типов Oracle, которые отображаются в rowtype-типы
описанные ранее (пп. 2.2.1.1 и 2.2.1.2 изменений на 05.08.2004).

2.2. Реализован синтаксис использования и разыменования NESTED TABLES типов
и реквизитов в PL/Plus запросах. Разыменование возможно как обычным способом
(через точку или оператор ссылки), так и в IN-списке.
		Пример:
    Пусть есть тип "Ссылка на пользователя" USER_TREF (который не имеет
    таблицы, так что структура для [USER_TREF]%rowtype содержит всего
    одно поле C_VALUE, содержащую ссылку на [USER]), над которой определен
    вложенный массив USER_REF_TBL. В неком справочнике STRUCT имеется реквизит
    T7, определенный как вложенный массив USER_REF_TBL:
        declare
          s string;
          t [USER_REF_TBL];
          u [USER_TREF]%rowtype;
        begin
          select x(x.[T7]) in [STRUCT] where rownum=1
            into t; -- заполнение массива t непосредственно из реквизита
          for (select x(x.[].[USERNAME]) in t )
          loop s:=x.a$1; exit; end loop; -- цикл по вложенному массиву (переменной)
          for (select x(x.[T7].[].[USERNAME]) in [STRUCT] )
          loop s:=x.a$1; exit; end loop; -- цикл по вложенному массиву (реквизиту)
          for (select x(y.[].[USERNAME]) in [STRUCT], (x.[T7] : y) )
          loop s:=x.a$1; exit; end loop; -- то же, с разыменованием в IN-списке
        end;
ПРИМЕЧАНИЕ: При разыменовании вложенных таблиц порядок таблиц в результирующем
   from-листе всегда используется прямой (независимо от флагов компиляции),
   т.к. выражения для вложенных таблиц ссылаются на ранее идущие таблицы списка.

2.3. Реализован также синтаксис приведения подзапросов к NESTED TABLE
типу через CAST(MULTISET). Синтаксис:
        CAST([CURSOR](subquery),typename)
где
    subquery - PL/Plus подзапрос. Если в подзапросе выбирается только одна
               колонка, то указание ключевого слова CURSOR не обязательно
    typename - тип Вложенный массив, к которому приводится выборка подзапроса
               (выбираемые значения в подзапросе должны быть совместимы по
               типу с полями элементов вложенного массива)
		Пример (в соответствии с определениями п. 2.2):
          for (
          	select a(a,a.[arc_move],
                       cast(
          	         (select r(r.[doc].[document_user]) in a.[arc_move])
          	         ,[USER_REF_TBL])
          	  ) in [AC_FIN] where a.[main_v_id] like s
          ) loop t := a.a$3; exit; end loop;
          -- выборка вложенной таблицы ссылок на пользователей внутри цикла
          -- по выпискам финансовых счетов
ПРИМЕЧАНИЕ: При приведении подзапросов к NESTED TABLE через CAST следует
    учитывать текущую структуру элементов массива, к которому делается
    CAST. Элементами вложенного массива является структура %rowtype, которая
    существенно зависит от свойств самого типа (например, для скалярных
    типов, имеющих таблицы, эта структура помимо поля C_VALUE будет
    содержать еще как минимум поля ID и CLASS_ID, - принципы формирования
    rowtype типа описаны ранее в п.2.2 изменений на 05.08.2004).

2.4. Добавлена возможность использования модификатора %rowtype (п.2.13
изменений на 05.08.2004) по связанным ссылкам, а не только по основной
таблице. Также добавлена возможность использования %rowtype для развертывания
списка приемников в операторе FETCH (FETCH_LIMIT).

2.5. Добавлена возможность указания префикса для формирования имен алиасов
в выборках при развертывании списков с помощью оператора %rowtype (п.2.13
изменений на 05.08.2004). Для указания префикса нужно в строковую константу,
передаваемую первым параметром, добавить опцию:
        prefix=<текст префикса>
		Пример:
        for (
              select d(
                 d.[acc_kt]%rowtype('prefix=KT'), -- реквизиты кредитового счета
                 d.[acc_dt]%rowtype('prefix=DT')  -- реквизиты дебетового счета
               ) in ::[main_docum] where d=myID
        ) loop null; end loop;

        3. Разное.

3.1. На уровне поддержки хранения вложенных таблиц реализована возможность
создания индексов на вложенных таблицах. Системой автоматически создается
индекс по колонке NESTED_TABLE_ID, которая присутствует во вложенных
таблицах автоматически (по аналогии с COLLECTION_ID обычных массивов).
Можно также создавать и пользовательские индексы на вложенных таблицах,
использующих поля rowtype-типа, а также колонку NESTED_TABLE_ID.

3.2. Элементы вложенных таблиц, используемых в качестве колонок таблиц ТБП,
формально могут иметь системные поля ID,CLASS_ID,COLLECTION_ID,STATE_ID
(в соответствии со структурой rowtype), однако заполнение этих полей
во вложенных таблицах ТЯ не контролируется и они могут использоваться
для хранения дополнительной прикладной информации. Также ТЯ не
контролируется целостность значений полей-ссылок вложенных таблиц,
т.к. Oracle не позволяет создавать ссылочные ограничения целостности
на вложенных таблицах (равно как и триггеры). Контроль заполнения
таких ссылок осуществляется только на уровне проверки типов в PL/Plus.

----------------------------------------------------------------------
Изменения на 05.08.2004. - версия 6.3 (build 0).
	
	1. Синтаксис.
1.1. Расширен синтаксис сортировки в выборках (ORDER BY clause). Теперь
в иерархических выборках (синтаксис connect by) в order by может использоваться
ключевое слово siblings, что указывает на сортировку внутри ветвей иерархической
выборки. При указании режима сортировки (asc/desc) можно также указать порядок
следования пустых значений. Полный синтаксис:
    ORDER {SIBLINGS} BY expr_1 {/ASC DESC/ {NULLS /FIRST LAST/}}
                      {,expr_2 {/ASC DESC/ {NULLS /FIRST LAST/}}, ...}
		Пример:
        for (
              select d(rpad('*',level*2)||d.code) in ::[depart]
	     connect by prior d=d.high
	       start d.high is null
               order siblings by d.code desc nulls last
        ) loop null; end loop;

1.2. Расширен синтаксис иерархической выборки connect by ключевым
словом nocycle (Oracle10g), позволяющим выполнить такую выборку
даже при наличии циклически замкнутых ветвей:
    CONNECT {NOCYCLE} BY condition
Также добавлен унарный оператор CONNECT_BY_ROOT (аналог PRIOR, только
возвращающий верхнеузловую запись текущей ветви), а также функции
CONNECT_BY_ISCYCLE, CONNECT_BY_ISLEAF.

1.3. Расширен синтаксис группировки в выборках (group by), позволяющим выполнять
группировку по наборам значений (grouping sets). Этот синтаксис реализован
через псевдо-функции GROUPING_SETS и SET (аналогично ROLLUP и CUBE), соответственно,
добавлены и функции GROUP_ID, GROUPING_ID для самой выборки:
    GROUP BY GROUPING_SETS(SET(expr1_1,expr1_2...),SET(expr2_1,expr2_2..)), ...
		Пример:
        for(
             select u( grouping(u.username),group_id,
                       grouping_id(u.name,u.depart.name),u.username)
                 in [USER]
              group by rollup(u.username),
                       grouping_sets(set(u.name,u.depart.name),
                                     set(u.username,u.depart.code))
        ) loop exit; end loop;

1.4. Расширен синтаксис ждущей блокировки в выборках. В синтаксисе lock wait
можно указать явно целую константу, указывающую количество секунд ожидания
блокировки. Если указано значение 0, то блокировка считается не ждущей
(nowait), если указано значение большее 998, то блокировка ждет без
ограничения по времени (обычный lock wait):
    LOCK /WAIT{ integer_constant} NOWAIT/...
		Пример:
        locate exact u in [user] where u.[username]=p_name lock wait 10;
        select u(u.name) in [user] where u.[username]=p_name
          lock wait 10 (u)
          into v_str;

1.5. Расширен синтаксис forall (для операторов INSERT/UPDATE/DELETE).
Внутренний цикл для этих операторов имеет следующий синтаксис:
a)  FOR index_var IN index_expr1 .. index_expr2 /LOOP EXCEPTIONLOOP/
Для Oracle10g поддерживается дополнительный синтаксис:
b)  FOR index_var IN index_array {INDEX index_expr1 .. index_expr2} /LOOP EXCEPTIONLOOP/
c)  FOR index_var INDEX index_array  /LOOP EXCEPTIONLOOP/
Ключевое слово exceptionloop указывает на возможность выполнения
всего оператора в случае, когда для отдельных итераций он не выполняется.
При этом возникает исключение RTL.DML_ERRORS и в массив
RTL.BULK_EXCEPTIONS (эквивалент SQL%BULK_EXCEPTIONS) заносится информация
о записях исходного массива данных, на которых произошла ошибка
при выполнении всего оператора. Массив BULK_EXCEPTIONS представляет
собой PL/SQL таблицу записей с полями ERROR_INDEX (индекс в исходном
массиве данных) и ERROR_CODE (код ошибки Oracle).
    Синтаксис b) (Oracle синтаксис indices of) указывает, что в операторе
будут использоваться только индексы указанного массива index_array (либо все,
либо в заданном диапазоне index_expr1..index_expr2). Причем, в отличие от
синтаксиса a), индексы могут иметь пропуски в соответствии с тем как заполнен
массив index_array.
    Синтаксис c) (Oracle синтаксис values of) указывает, что в операторе
будут использоваться индексы, получаемые в качестве значений указанного массива
index_array (т.о. index_array должен быть массивом целых чисел). При этом
могут быть как и пропуски, так и повторяющиеся значения индексов, важно,
чтобы они существовали на момент выполнения оператора.
		Пример:
        update
          for i in 1..100 exceptionloop
             x( x.name=s  ) in [USER] where x=tn(i) ;

1.6. Расширены возможности описания PL/SQL таблиц, использующих
строковые индексы. Это может быть удобно для хранения и сбора
упорядочиваемой по строкам информации, однако использовать такие
таблицы в BULK и FORALL операторах нельзя. При этом соответствующие
операторы (FIRST,LAST,PRIOR,NEXT) будут возвращать строковые
значения.
		Пример:
        type t_num_str is table of number index by string(100);

1.7. Реализован синтаксис объявления TIMESTAMP/INTERVAL типов через
SQL синтаксис. Таким образом, следующие объявления эквивалентны:
    TIMESTAMP(size,1)  <--> TIMESTAMP(size) WITH TIME ZONE
    TIMESTAMP(size,2)  <--> TIMESTAMP(size) WITH LOCAL TIME ZONE
    INTERVAL           <--> INTERVAL DAY TO SECOND
    INTERVAL(size)     <--> INTERVAL YEAR(size) TO MONTH
    INTERVAL(size,prec)<--> INTERVAL DAY(size) TO SECOND(prec)

ПРИМЕЧАНИЕ: Синтаксис пп. 1.1 - 1.7 применим только на платформе Oracle9i
    кроме тех случаев, где явно не оговорена версия Oracle10g. Под Oracle8i
    может быть использован синтаксис сортировки пустых значений (п.1.1 -
    nulls first/last) и то только для генерации представлений, а также
    forall вариант a) п.1.5 без exceptionloop. Также реализация п.1.7
    решает проблему разбора пакета DBMS_SQL версии 8.1.6, т.к. на этот
    пакет завязаны ссылки на типы из других пакетов ядра, что не позволяло
    использовать переопределенные типы этих пакетов на версии 8.1.6.
	
1.8. Реализован синтаксис типизованных ссылок (%->, %=>) и типизованного
оператора-модификатора (%%), которые при использовании в выборках всегда
соединяются с той таблицей, которой определена разыменовываемая этими
операторами ссылка, даже если указанные реквизиты не находятся в
собственной таблице:
		Пример:
        declare
          ac ref [AC_FIN];
          v_name string;
        begin
          locate exact ac in [AC_FIN]
           where ac.fintool->name  like v_name and ac.fintool%class='FT_MONEY'  and rownum=1;
          locate exact ac in [AC_FIN]
           where ac.fintool%->name like v_name and ac.fintool%%class='FT_MONEY' and rownum=1;
        end;
                Преобразуется:
declare
        AC	number;
        V_NAME	varchar2(128);
begin
        begin
                        select  a1.id
                        into AC
                        from Z#AC_FIN a1, Z#FINTOOL a2
                        where a1.C_FINTOOL=a2.id
                          and (a2.C_NAME like V_NAME and a2.CLASS_ID = 'FT_MONEY' and ROWNUM = 1);
        exception
                when NO_DATA_FOUND then raise rtl.NO_DATA_FOUND;
                when TOO_MANY_ROWS then raise rtl.TOO_MANY_ROWS;
        end;
        begin
                        select  a1.id
                        into AC
                        from Z#AC_FIN a1, Z#FT_MONEY a2, Z#FINTOOL a3
                        where a1.C_FINTOOL=a2.id and a2.id=a3.id
                          and (a3.C_NAME like V_NAME and a3.CLASS_ID = 'FT_MONEY' and ROWNUM = 1);
        exception
                when NO_DATA_FOUND then raise rtl.NO_DATA_FOUND;
                when TOO_MANY_ROWS then raise rtl.TOO_MANY_ROWS;
        end;
end;

1.9. Реализован оператор INSERT, аналогичный SQL оператору INSERT.
Применяться он может только для типов, в которых отключено журналирование
состояний, коллекций, реквизитов, а также отсутствует прикладной
триггер на вставку. Синтаксис:
а)  INSERT INTO class_expression
      {forall_loop}
	  alias(var_1 = expr_1, var_2 = expr_2, ...)
      {WHERE where_expression}
      {RETURN expression_list INTO variables_list};
b)  INSERT INTO class_expression
       {forall_loop}
	  alias( ( var_1, var_2, ... ) = ( subquery ) )
      {WHERE where_expression};
где
    forall_loop - внутренний forall цикл (синтаксис см.п.1.5),
    var_1, var_2 - устанавливаемые реквизиты типа,
    expr_1, expr_2 - присваиваемые им значения при вставке записи,
    subquery - выборка значений реквизитов для вставки,
    alias - имя алиаса переменной-ссылки на тип (задаваемый в
        class_expression), через которую осуществляется обращение
        к реквизитам,
    class_expression - выражение для типа/коллекции,
    where_expression - логическое выражение, содержащее условие на вставляемые
        данные (если оно указано, то осуществляется вставка в подзапрос с
        использванием CHECK OPTION)
    expression_list  - список выражений, которые требуется извлечь (после вставки),
    variables_list   - список переменных-приемников.
Синтаксис а) транслируется в insert into ... values (...).
Синтаксис b) транслируется в insert into ... (subquery).
Если в списке значений отсутствуют какие-либо автоматические реквизиты
(автонумераторы или коллекции), то при генерации оператора INSERT
для них добавляются значения из соответствующих последовательностей.
		Пример:
  insert into [document] for i in 1..n_1.count loop
    x( x.document_user=n_1(i),
       x.document_date=[SYSTEM]::[OP_DATE],
       x%class = [MAIN_DOCUM]%class,
       x%state =  '2984' )
  return x into tn;

  insert into [main_docum] for i in 1..n_1.count loop
    x( x.document_user=n_1(i),
       x.document_date=[SYSTEM]::[OP_DATE],  	
       x.prov_user=stdlib.user_id,
       x.date_prov=[SYSTEM]::[OP_DATE],
       x%state =  '2984',
       x%id = tn(i) );


ПРИМЕЧАНИЕ: Оператор INSERT действует только в рамках одной из таблиц ТБП.
   Если ТБП устроен иерархически, то операторы INSERT должны заполнять
   таблицы, начиная с родительской, при этом на совесть разработчика
   ложится согласованность и непротиворечивость этих операторов (при этом
   нужно также корректно заполнять дублированные и служебные колонки -
   CLASS_ID, STATE_ID, COLLECTION_ID, т.е. для разных дочерних типов
   нужно указывать корректные значения для заполнения родительской
   таблицы, что требует достаточно глубоких знаний об устройстве
   механизма отображения ТБП в таблицы Oracle). Поэтому для иерархически
   устроенных типов использовать этот оператор не рекомендуется.

1.10. Реализован синтаксис определения массивов типа nested tables и
varrays (пока только на уровне операций, т.е. PL/SQL, использовать
такие массивы в SQL выражениях нельзя, т.к. им невозможно указать
SQL-тип через CAST):
   Nested Table:   TYPE type_name IS VARRAY(0) OF element_type;
   Varray:     TYPE type_name IS VARRAY(max_size) OF element_type;
где
   type_name - имя типа массива,
   element_type - тип элементов массива (может быть вида ref [CLASS]),
       однако это могут быть только SQL-типы (PL/SQL типы boolean
       и integer использовать нельзя),
   max_size  - максимальный размер varray массива.
Такие массивы могут использоваться в bulk операциях и forall циклах
наряду с обычными индексированными таблицами. Над такими массивами
определены операторы EXTEND (добавление элементов), TRIM (удаление
элементов с конца), для VARRAY определен оператор LIMIT (возвращает
максимальный размер VARRAY).


        2. Семантика.
2.1. Добавлены новые системные типы INTEGER (отображаемый в pls_integer,
он был и раньше, теперь выделен как системный), BOOLSTRING (строка
размером 1, на которую отображается PL/SQL тип BOOLEAN), REFSTRING
(строка размером 128, на которую отображаются строковые ссылки -
в текущей реализации ссылки на системные типы).

2.2. Добавлены новые типы для использования в новых конструкциях
PL/Plus (см.ниже):
   1.1. Rowtype тип, представляющий собой планарную структуру,
        соответствующую таблице типа (если таковая имеется), где
        все вложенные подструктуры развернуты до скалярных реквизитов
        (в эту структуру не входят родительские реквизиты, если только
        они не являются дублированными). При этом PL/SQL типы
        приводятся к SQL типам (INTEGER - NUMBER, BOOLEAN - BOOLSTRING,
        размеры строк, большие 4000, обрезаются значением 4000).
        В структуру также входят и поля, соответствующие системным
        реквизитам (ID,CLASS_ID,COLLECTION_ID,STATE_ID), которые есть
        в таблице типа (если таковая имеется).
        Обращения к полям такой структуры аналогичны обращениям к полям
        обычной PL/SQL структуры ТБП (тип 2.1 - см. ниже), однако если
        конечный реквизит не будет скалярным, то такое разыменование
        будет ошибочным. Также будет ошибочным обращение к реквизитам
        родительских типов (если они не продублированы в дочернем).
        Последовательность полей и их имена в планарной структуре (Rowtype типа)
        соответствуют колонкам собственной таблицы типа. При наличии таблицы
        системные поля ID,CLASS_ID, а также COLLECTION_ID, STATE_ID (при их
        наличии, см.п.3.10) находятся в начале структуры в указанном порядке,
        при отсутствии таблицы порядок полей определяется так же, как и для
        обычной структуры (т.е. порядковыми номерами собственных реквизитов,
        см. тип 2.1), а системные поля отсутствуют.
   Определение типа:   [CLASS]%rowtype
                Пример:
        declare
          m [MAIN_DOCUM]%rowtype;
        begin
          stdio.put_line_buf(m.[KL_KT].[1].[2].[MAIN_V_ID]);
        end;
                Преобразуется:
        declare
                M  Z#MAIN_DOCUM#INTERFACE.CLSROW#MAIN_DOCUM;
        begin
                STDIO.PUT_LINE_BUF(Z#AC_FIN#INTERFACE.get_str(M.C_KL_KT#1#2,'MAIN_V_ID'));
        end;
   1.2. Таблица NESTED TABLE rowtype типа:
   TYPE type_name IS VARRAY(0) OF [CLASS]%rowtype;
        Этот тип, главным образом, предназначен для BULK операций.
Типы 1.1 и 1.2 в дальнейшем предполагается расширить до SQL-типов Oracle,
тогда NESTED TABLES смогут использоваться как новый тип коллекций, и,
соответственно, смогут участвовать в SQL запросах через CAST преобразование.
   2.1. PL/SQL тип, соответствующий ТБП. Этот тип существовал всегда,
        приводится для общности. В версии 6.0 в структуру типа
        (если тип - структура) добавлены также системные поля (ID,CLASS_ID,
        COLLECTION_ID,STATE_ID). Доступ к системным полям структуры 2.1
        (равно как и rowtype-структуры 1.1, которая есть и у скалярных типов),
        осуществляется через операторы-модификаторы %ID,%CLASS,%COLLECTION,
        %STATE, соответственно. Поля PL/SQL структуры типа упорядочиваются
        в соответствии с заданным порядковым номером реквизита в типе (при
        совпадении порядковых номеров реквизитов последовательность полей
        структуры определяется алфавитным порядком коротких имен реквизитов).
        Системные поля ID,CLASS_ID,COLLECTION_ID,STATE_ID всегда находятся
        в начале структуры в указанном порядке.
   Определение типа:   [CLASS]
   2.2. PL/SQL таблица (index by binary_integer) PL/SQL типа, соответствующего
        ТБП (тип 2.1):
   TYPE type_name IS TABLE OF [CLASS];
        Описание этих структур появилось начиная с версии 6.0. В версии Oracle8i
        этот тип нельзя объявлять, если структура ТБП содержит подструктуры.
   2.3. Rowtable тип - планарная структура PL/SQL таблиц (index by binary_integer).
        Эта структура содержит набор полей, развернутых до скалярных типов,
        а сами поля структуры определены как PL/SQL таблицы SQL-типов
        (образованных по принципу rowtype-типа 1.1) скалярных реквизитов,
        им соответствующих. Порядок разыменования полей тот же, что и для
        rowtype типа. В эту структуру входят, в отличие от rowtype-типа, поля
        всех реквизитов, в т.ч. родительских. Последовательность полей и их имена
        соответствуют колонкам таблиц типа (как собственной, так и родительских),
        причем сначала идут поля, соответствующие собственной таблице,
        затем идут поля ближайшей родительской таблицы, далее поля следующей
        по уровню иерархии родительской таблицы - вплоть до самого верхнеуровневого
        родителя. Структура Rowtable также содержит все системные поля ID,CLASS_ID,
        COLLECTION_ID,STATE_ID, которые всегда находятся в начале структуры
        в указанном порядке и доступны через модификаторы %ID,%CLASS,%COLLECTION,
        %STATE, соответственно. При отсутствии собственной таблицы типа порядок полей
        в пределах каждого из уровней иерархии определяется порядковым номером реквизита,
        (или алфавитным порядком коротких имен реквизитов при совпадении порядковых
        номеров).
   Определение типа:   [CLASS]%rowtable
                Пример:
        declare
          ut [USER]%rowtable;
        begin
          select u(u%id,u.name,u.username) in [USER] all
            into ut%id,ut.name,ut.username;
        end;
                Преобразуется:
        declare
                UT Z#USER#INTERFACE.CLSTBL#USER;
        begin
                select  a1.ID, a1.C_NAME, a1.C_USERNAME
                bulk collect into UT.ID, UT.C_NAME, UT.C_USERNAME
                from Z#USER a1;
        end;

2.3. Расширены возможности оператора %init для преобразования типов п.2.2
между собой. Приемником служит переменная слева от %init, а источник
передается параметром. Для наглядности определим следующие переменные:
        type t12 is varray(0) of [class]%rowtype;
        type t22 is table of [class];
        type pt22 is table of [parentclass];
        v11 [class]%rowtype; -- тип 2.2.1.1
        v12 t12;             -- тип 2.2.1.2
        v21 [class];         -- тип 2.2.2.1
        v22 t22;             -- тип 2.2.2.2
        v23 [class]%rowtable;-- тип 2.2.2.3
        p21 [parentclass];         -- тип 2.2.2.1 для родительского к [class]
        p22 pt22;                  -- тип 2.2.2.2 для родительского к [class]
        p23 [parentclass]%rowtable;-- тип 2.2.2.3 для родительского к [class]
    a) Инициализация переменных:
        v21%init{(stat boolean{,seq boolean})}
        v22%init{(stat boolean{,seq boolean{,first integer{,last integer}}})}
        v23%init{(set integer)} -- очистка вложенных таблиц
    b) Преобразования типов:
      [class]%rowtype <-- [class]
        v11%init(v21{,seq boolean})
      [class] <-- [class]%rowtype
        v21%init(v11{,seq boolean})
      table [class]%rowtype <-- table [class]
        v12%init(v22{,seq boolean{,first integer{,last integer{,set integer}}}})
      table [class] <-- table [class]%rowtype
        v22%init(v12{,seq boolean{,first integer{,last integer{,set integer}}}})
      table [class] <-- [class]%rowtable
        v22%init(v23{,seq boolean{,first integer{,last integer{,set integer}}}})
      [class]%rowtable <-- table [class]
        v23%init(v22{,seq boolean{,first integer{,last integer{,set integer}}}})
      table [class]%rowtype <-- [class]%rowtable
        v12%init(v23{,seq boolean{,first integer{,last integer{,set integer}}}})
      [class]%rowtable <-- table [class]%rowtype
        v23%init(v12{,seq boolean{,first integer{,last integer{,set integer}}}})
    c) Преобразования типов иерархическое(parent<-->child):
      [parentclass] <-- [class]
        p21%init(v21{,seq boolean})
      [class] <-- [parentclass]
        v21%init(p21{,seq boolean})
      table [parentclass] <-- table [class]
        p21%init(v21{,seq boolean{,first integer{,last integer{,set integer}}}})
      table [class] <-- table [parentclass]
        v22%init(p22{,seq boolean{,first integer{,last integer{,set integer}}}})
      [parentclass]%rowtable <-- [class]%rowtable
        p23%init(v23{,seq boolean})
      [class]%rowtable <-- [parentclass]%rowtable
        v23%init(p23{,seq boolean})
где могут быть заданы следующие умолчательные параметры:
    stat - признак корректировки статических реквизитов из статического экземпляра
           (по умолчанию true), если true - корректировка делается, иначе - нет.
    seq  - a) признак генерации автоматических значений (по умолчанию false),
              если true - то безусловная генерация, иначе генерация только в случае
              пустых значений в инициализируемой переменной.
           b-с) признак пере присвоения автоматических значений (по умолчанию true),
              если true - то значения присваиваются из источника, иначе - нет.
    first- начальный индекс источника для переноса данных (по умолчанию - первый
           существующий индекс).
    last - конечный индекс источника для переноса данных (по умолчанию - последний
           существующий индекс).
    set  - a) количество инициализируемых пустых значений в поле ID (по умолчанию
              поле ID не инициализируется, что эквивалентно значению 0).
           b-c) индекс приемника, за которым будут помещаться данные из источника
              (по умолчанию - последний существующий индекс, т.е. данные по умолчанию
              добавляются в конец существующим).
ПРИМЕЧАНИЕ: для типа 2.2.2.3 (rowtable) индексы first-last-set относятся к полю ID,
    так что при заполнении других полей индексы синхронизируются с полем ID, а при
    переносе данных из структуры в другие приемники из полей, в которых отсутствуют
    индексы, переносится значение null.

2.4. Добавлены SQL-типы для NESTED TABLES скалярных типов:
        type TYPE_STRING_TABLE  is table of varchar2(32767)
        type TYPE_MEMO_TABLE    is table of varchar2(4000)
        type TYPE_REFSTRING_TABLE  is table of varchar2(128)
        type TYPE_DEFSTRING_TABLE  is table of varchar2(256)
        type TYPE_BOOLSTRING_TABLE is table of varchar2(1)
        type TYPE_DATE_TABLE       is table of date
        type TYPE_NUMBER_TABLE     is table of number
        type TYPE_RAW_TABLE        is table of raw(2000)
        type TYPE_LONGRAW_TABLE    is table of raw(32767)
        type TYPE_BLOB_TABLE       is table of blob
        type TYPE_CLOB_TABLE       is table of clob
        type TYPE_BFILE_TABLE      is table of bfile
        type TYPE_TIMESTAMP_TABLE      is table of timestamp_unconstrained
        type TYPE_TIMESTAMP_TZ_TABLE   is table of timestamp_tz_unconstrained
        type TYPE_TIMESTAMP_LTZ_TABLE  is table of timestamp_ltz_unconstrained
        type TYPE_INTERVAL_TABLE       is table of dsinterval_unconstrained
        type TYPE_INTERVAL_YM_TABLE    is table of yminterval_unconstrained
        synonym TYPE_REFERENCE_TABLE for TYPE_NUMBER_TABLE
        synonym TYPE_LONG_TABLE for TYPE_STRING_TABLE
        synonym TYPE_LONG#RAW_TABLE for TYPE_LONGRAW_TABLE
    Соответственно, при определении аналогичных типов в PL/Plus, происходит
автоматическое переопределение типов:
TYPE name IS VARRAY(0) OF REF[class]       <-->  TYPE_NUMBER_TABLE
TYPE name IS VARRAY(0) OF [class_ARR]      <-->  TYPE_NUMBER_TABLE
TYPE name IS VARRAY(0) OF REF[kernelclass] <-->  TYPE_REFSTRING_TABLE
TYPE name IS VARRAY(0) OF STRING{(size)}   <-->  TYPE_MEMO_TABLE
TYPE name IS VARRAY(0) OF MEMO             <-->  TYPE_MEMO_TABLE
TYPE name IS VARRAY(0) OF REFSTRING        <-->  TYPE_REFSTRING_TABLE
TYPE name IS VARRAY(0) OF BOOLSTRING       <-->  TYPE_BOOLSTRING_TABLE
TYPE name IS VARRAY(0) OF BOOLEAN          <-->  TYPE_BOOLSTRING_TABLE
TYPE name IS VARRAY(0) OF DATE             <-->  TYPE_DATE_TABLE
TYPE name IS VARRAY(0) OF NUMBER{(sz{,pr})}<-->  TYPE_NUMBER_TABLE
TYPE name IS VARRAY(0) OF INTEGER          <-->  TYPE_NUMBER_TABLE
TYPE name IS VARRAY(0) OF RAW{(size)}      <-->  TYPE_RAW_TABLE
TYPE name IS VARRAY(0) OF BLOB             <-->  TYPE_BLOB_TABLE
TYPE name IS VARRAY(0) OF CLOB             <-->  TYPE_CLOB_TABLE
TYPE name IS VARRAY(0) OF BFILE            <-->  TYPE_BFILE_TABLE
TYPE name IS VARRAY(0) OF LONG             <-->  TYPE_STRING_TABLE
TYPE name IS VARRAY(0) OF LONG RAW         <-->  TYPE_LONGRAW_TABLE
TYPE name IS VARRAY(0) OF TIMESTAMP{(size)}<-->  TYPE_TIMESTAMP_TABLE
TYPE name IS VARRAY(0) OF TIMESTAMP(size,1)<-->  TYPE_TIMESTAMP_TZ_TABLE
TYPE name IS VARRAY(0) OF TIMESTAMP(size,2)<-->  TYPE_TIMESTAMP_LTZ_TABLE
TYPE name IS VARRAY(0) OF INTERVAL{(sz,pr)}<-->  TYPE_INTERVAL_TABLE
TYPE name IS VARRAY(0) OF INTERVAL(size)   <-->  TYPE_INTERVAL_YM_TABLE
    Напомню также правила переопределения типов для index by integer таблиц:
TYPE name IS TABLE OF REF[class]       <-->  CONSTANT.NUMBER_TABLE
TYPE name IS TABLE OF [class_ARR]      <-->  CONSTANT.NUMBER_TABLE
TYPE name IS TABLE OF REF[kernelclass] <-->  CONSTANT.REFSTRING_TABLE
TYPE name IS TABLE OF STRING{(size)}   <-->  CONSTANT.STRING_TABLE
TYPE name IS TABLE OF MEMO             <-->  CONSTANT.STRING_TABLE
TYPE name IS TABLE OF REFSTRING        <-->  CONSTANT.REFSTRING_TABLE
TYPE name IS TABLE OF BOOLSTRING       <-->  CONSTANT.BOOLSTRING_TABLE
TYPE name IS TABLE OF BOOLEAN          <-->  CONSTANT.BOOLEAN_TABLE
TYPE name IS TABLE OF DATE             <-->  CONSTANT.DATE_TABLE
TYPE name IS TABLE OF NUMBER{(sz{,pr})}<-->  CONSTANT.NUMBER_TABLE
TYPE name IS TABLE OF INTEGER          <-->  CONSTANT.INTEGER_TABLE
TYPE name IS TABLE OF RAW{(size)}      <-->  CONSTANT.RAW_TABLE
TYPE name IS TABLE OF BLOB             <-->  CONSTANT.BLOB_TABLE
TYPE name IS TABLE OF CLOB             <-->  CONSTANT.CLOB_TABLE
TYPE name IS TABLE OF BFILE            <-->  CONSTANT.BFILE_TABLE
TYPE name IS TABLE OF LONG             <-->  CONSTANT.STRING_TABLE
TYPE name IS TABLE OF LONG RAW         <-->  CONSTANT.RAW_TABLE
TYPE name IS TABLE OF TIMESTAMP{(size)}<-->  CONSTANT.TIMESTAMP_TABLE
TYPE name IS TABLE OF TIMESTAMP(size,1)<-->  CONSTANT.TIMESTAMP_TZ_TABLE
TYPE name IS TABLE OF TIMESTAMP(size,2)<-->  CONSTANT.TIMESTAMP_LTZ_TABLE
TYPE name IS TABLE OF INTERVAL{(sz,pr)}<-->  CONSTANT.INTERVAL_TABLE
TYPE name IS TABLE OF INTERVAL(size)   <-->  CONSTANT.INTERVAL_YM_TABLE
    При определении типов полей структуры rowtable (2.2.2.3) действуют
те же правила, что и для index by таблиц, кроме:
TYPE name IS TABLE OF STRING{(size)}   <-->  CONSTANT.MEMO_TABLE
TYPE name IS TABLE OF MEMO             <-->  CONSTANT.MEMO_TABLE
TYPE name IS TABLE OF BOOLEAN          <-->  CONSTANT.BOOLSTRING_TABLE

2.5. Расширено применение модификатора %lock:
        v_ref    ref [class];
   type t_ref is varray(0) of ref [class];
        v_reftbl t_ref;
   а) Блокировка по ссылке:
        v_ref%lock{(class string{,wait integer})}
   b) Блокировка по массиву ссылок:
        v_reftbl%lock
где
   class - фактический тип экземпляра (a) или экземпляров (b) в массиве
           (если не задается, то используется тип ссылки, к которой применен
           модификатор).
   wait  - время (в секундах) ожидания блокировки экземпляра (по умолчанию
           не задается, так что используется используются текущие настройки
           системы LOCK_DELAY*LOCK_RETRY). Если указано значение 0, то блокировка
           считается не ждущей (nowait), если указано значение большее 998, то
           блокировка ждет без ограничения по времени (обычный lock_wait).
В случае b) блокировка более эффективна, т.к. записи блокируется
единовременно по всему массиву ссылок (через select for update ... и
CAST(v_reftbl as type_number_table)).

2.6. Расширено применение модификатора %delete. Он может применяться
к массиву NESTED TABLE ссылок на ТБП (определения см.п.2.5):
      v_reftbl%delete{(lock boolean)};
где
   lock  - признак предварительной блокировки передаваемого массива ссылок (по
           умолчанию true), если true, то происходит групповая блокировка
           (п.2.5 - b)), иначе - нет.
Указанная конструкция эффективна (реализация delete forall) при условии
отсутствия журналирования реквизитов, состояний, коллекций и триггера на
удаление, в противном случае происходит циклическое удаление экземпляров
по одному.

2.7. Расширены возможности оператора-модификатора %INSERT и соответствующего ему
оператора INSERT для новых типов. Добавлена возможность указания начального состояния
при создании экземпляра. В соответствии с определениями пп.2.3,2.5:
  a) Создание экземпляра из структуры ТБП:
      insert{(id ref[class]{,stat boolean{,state string{,seq boolean}}})} v21 into coll;
      coll%insert(v21{,id ref[class]{,stat boolean{,state string{,seq boolean}}}});
  b) Создание экземпляров из массива структур ТБП:
      insert{(state string{,seq boolean{,stat boolean}})} v22 into coll;
      coll%insert(v22{,state string{,seq boolean{,stat boolean}}});
  c) Создание экземпляров из структуры rowtable ТБП:
      insert{(state string{,seq boolean})} v23 into coll;
      coll%insert(v23{,state string{,seq boolean}});
  d) Перемещение существующих экземпляров (задаваемых массивом NESTED TABLE
     элементов-ссылок на ТБП) в новую коллекцию:
      insert{(lock boolean)} v_reftbl into coll;
      coll%insert(v_reftbl{,lock boolean});
где могут быть заданы следующие умолчательные параметры:
    id   - значение ID для создаваемого экземпляра (по умолчанию берется из
           глобальной последовательности SEQ_ID).
    stat - признак корректировки статических реквизитов из статического экземпляра
           (по умолчанию для a) - true,  для b) - false), если true - корректировка
           делается, иначе - нет.
    seq  - признак генерации автоматических значений (по умолчанию для a) - false,
           для b-c) - true), если true - то безусловная генерация, иначе генерация
           только в случае пустых значений.
    state- ID начального состояния при создании экземпляров (по умолчанию - начальное
           состояние, задаваемое в типе).
    lock - признак предварительной блокировки передаваемого массива ссылок (по
           умолчанию true), если true, то происходит групповая блокировка
           (п.2.5 - b)), иначе - нет.
Конструкция %INSERT для a) возвращает ссылку (ID) на созданный экземпляр, для
b-c) возвращает целое число, указывающее сколько экземпляров было создано, для
d) возвращает количество перемещенных экземпляров из одной коллекции в другую.
В случае с) записи в полях должны быть заполнены по порядку, начиная с 1
(если seq=true, то поля, соответствующие автоматическим реквизитам могут
быть не заполнены), после выполнения оператора системные поля ID,CLASS_ID,
COLLECTION_ID,STATE_ID заполняются значениями соответствующих системных
реквизитов, в случае seq=true заполняются и поля, соответствующие
автоматическим реквизитам. Конструкции b-c) наиболее эффективно работают
в случае отсутствия журналирования реквизитов, коллекций, состояний и
прикладных триггеров на вставку, т.к. используют конструкцию insert forall
при создании экземпляров (причем вариант b) работает через c)). Если же
эти условия не выполняются, тогда создание экземпляров идет в процедуре
b) в цикле создания экземпляров по одному через вариант a) (причем c),
в свою очередь, идет через b)), если же в типе нельзя определить pl/sql
таблицу (в случае Oracle8i и подструктур), то создание экземпляров по
типу b) невозможно (если тип не обладает нужными свойствами, то и вариант
c) тоже может быть невозможен).

2.8. Добавлен новый модификатор %getcollection. Принимает параметром
структуру типа rowtable (2.2.2.3). Применяется к типу-коллекции,
возвращает количество извлеченных элементов коллекции, а в передаваемом
параметре возвращает сами элементы.
                Пример:
        declare
          type t_refrec is varray(0) of ref [RECORDS];
          ac1 ref [ac_fin];
          ac2 ref [ac_fin];
          recs [RECORDS]%rowtable;
          refs  t_refrec;
          n integer;
        begin
          n:=ac1.[ARC_MOVE]%getcollection(recs); -- зачитываем выписки счета ac1
          if n>0 then
            refs := recs%id;  -- заполняем массив ссылок (см.п.2.13)
            refs%lock; -- блокируем извлеченные выписки
            insert recs into ac2.[ARC_MOVE];  -- создаем выписки для счета ac2
            refs%delete(false);  -- удаляем выписки счета ac1
                                 -- без блокировки, т.к. блокировали раньше
          end if;
        end;

2.9. Для поддержки работы с VARRAYS/NESTED TABLES добавлены специфичные
для них исключения:
        COLLECTION_IS_NULL - действие c неинициализированным массивом,
        SUBSCRIPT_BEYOND_COUNT  - индекс превышает фактическое количество
                            элементов в массиве (требуется EXTEND),
        SUBSCRIPT_OUTSIDE_LIMIT - индекс вне допустимого диапазона
                            (например, отрицательный, что недопустимо для
                            таких коллекций, либо превышает максимальный
                            размер для VARRAY).
Также реализован механизм инициализации таких массивов через модификатор
%INIT, который можно к ним применять, передавая ему в качестве параметров
значения для элементов массива. Если параметров не передавать, то
массив будет инициализирован без элементов, иначе будет создано столько
элементов, сколько параметров было передано.
                Пример:
        declare
          type t_refrec is varray(0) of ref [RECORDS];
          refs  t_refrec;
          rec  ref [RECORDS];
        begin
          refs.extend;  -- COLLECTION_IS_NULL (массив не инициализирован)
          refs%init(null,null,null); -- создается 3 пустых записи в массиве refs
          refs.extend;  -- добавился четвертый пустой элемент
          rec := refs(0); -- SUBSCRIPT_OUTSIDE_LIMIT (индекс должен быть >0)
          rec := refs(10); -- SUBSCRIPT_BEYOND_COUNT (индекс должен быть <=4)
        end;

2.10. Модификатор %INIT в режиме расширенного синтаксиса может также
использоваться для инициализации переменных, объявленных как SQL-типы
Oracle. Передаваемый список параметров передается умолчательному
конструктору Oracle типа.
                Пример:
   пусть есть тип Oracle
   create type1 as object(x number,s varchar2(100));
        declare
          x  type1%object;
        begin
          x%init(0,'xxxxxxxx');
        end;

2.11. Конструкторы типов Oracle могут вызываться и напрямую в режиме
расширенного синтаксиса (аналог примера п.2.10):
        declare
          x  type1;
        begin
          x := type1(1,'yyyyyyy');
        end;

2.12. Добавлены новые стандартные функции Oracle:
Простые функции:
        CONCAT
        CAST  (для скалярных типов)
        ASCIISTR (Oracle9i)
        UNISTR (Oracle9i)
        NULLIF (Oracle9i)
        WIDTH_BUCKET (Oracle9i)
        BIN_TO_NUM (Oracle9i)
        CONNECT_BY_ISCYCLE (Oracle10g)
        CONNECT_BY_ISLEAF (Oracle10g)
Функции группировки:
        GROUP_ID (Oracle9i)
        GROUPING_ID (Oracle9i)
Групповые функции:
        CORR
        COVAR_POP
        COVAR_SAMP
        REGR_XXX (XXX=/SLOPE INTERCEPT COUNT R2 AVGX AVGY SXX SYY SYY/)
        STDDEV_POP
        STDDEV_SAMP
        VAR_POP
        VAR_SAMP
Аналитические функции:
	LISTAGG
        CUME_DIST
        DENSE_RANK
        PERCENT_RANK
        RANK
        FIRST_VALUE
        LAST_VALUE
        LAG
        LEAD
        NTILE
        RATIO_TO_REPORT
        ROW_NUMBER
        PERCENTILE_CONT (Oracle9i)
        PERCENTILE_DISC (Oracle9i)
Для вызова аналитических функций и групповых в режиме аналитических
добавлена специальная псевдо-функция ANALYTIC. Формат ее вызова:
        ANALYTIC(group_func(params),template,expr1,expr2,...)
где
    group_func - вызов групповой или аналитической функции из указанных выше,
    params - собственный набор параметров функции group_func,
    template - строковая константа, определяющая опции вызова аналитической
               функции (over_clause, query_partition_clause, order_by_clause,
               windowing clause,within_group_clause,keep_clause) в формате
               Oracle SQL, содержащая place_holders для выражений, используемых
               в этих опциях, в виде [<порядковый номер>]
    expr1,expr2,... - выражения, которыми заменяются place_holders в шаблоне
               опций аналитической функции (template). Причем выражение
               expr1 заменяет все вхождения подстроки '[1]' в указанном
               шаблоне, expr2 заменяет вхождения '[2]' и т.д.

2.13. Добавлен новый оператор-модификатор %rowtype. Это оператор развертывания
структурных типов по их полям. Этот модификатор может использоваться
в местах, где операторами SQL предусмотрены списки (SELECT-списки, RETURN-
списки, SELECT_INTO/RETURN_INTO списки, UPDATE/INSERT списки), а также
в операторе присваивания структур между собой (таким образом можно присвоить
РАЗНЫЕ структуры друг другу, лишь бы они были совместимы по типу полей и
их количеству). Модификатор может применяться как к структурам PL/SQL,
так и к структурам ТБП (пп.2.2.1.1, 2.2.2.1, 2.2.2.3). При применении
к структурам типов можно дополнительно указывать следующие опции, которые
могут дополнительно указывать подмножество полей структур типов, которые
указываются параметрами к модификатору:
  первый параметр - строковая константа, которая может содержать такие
     опции (опций может быть несколько, тогда они перечисляются через
     запятую):
     all - вывод всех полей структуры,
     nosys - поля, соответствующие системным реквизитам ID, CLASS_ID,
             COLLECTION_ID, STATE_ID не выводятся,
     self  - выводятся только собственные поля структуры (в случае
             когда структура может содержать поля родительских типов).
  второй параметр - переопределение типа (выражение для типа), который
             предписывает поля какой структуры выводить (т.е. можно
             переопределить тип на родительский по отношению к типу
             переменной, к которой применяется модификатор).
Модификатор %rowtype может применяться и к переменной-алиасу в PL/Plus
выборках и операторах UPDATE/INSERT, которая формально является ссылкой,
при этом такая конструкция разворачивается как соответствующий
rowtype-тип (2.2.1.1). В этом случае (при применении по ссылке) могут
быть указаны дополнительные параметры (после указанных двух), которые
автоматически будут использованы в соответствующем операторе ссылки
при разыменовании полей по реквизитам, алиасы выбираемым значениям
назначаются в соответствии с именами полей rowtype структуры (2.2.1.1),
т.е. соответствуют именам колонок таблицы. Также в этом случае можно
переопределить тип не только на родительский, но и на дочерний, только
это переопределение нужно делать два раза - один раз для переопределения
оператора %rowtype, другой раз для переопределения самой ссылки (в
генерируемом операторе ссылки).
    В случае применения модификатора %rowtype к типу rowtable,
дополнительным параметром может быть указано целое выражение, которое
интерпретируется как индекс для табличных полей структуры rowtable.
    Если параметры оператору %rowtype не указаны, то по умолчанию
выводятся все поля (т.е. с опцией all), во всех случаях кроме списков
операторов INSERT/UPDATE, где по умолчанию не задействуются системные
колонки (т.е. опция all,nosys). Соответственно, если не указан второй
параметр, то используемым типом является тип переменной, к которой
применяется модификатор.
                Пример 1:
        declare
          type t_refrec is varray(0) of ref [RECORDS];
          ac1 ref [ac_fin];
          ac2 ref [ac_fin];
          recs [RECORDS]%rowtable;
          refs  t_refrec;
          n integer;
        begin
          select r( r%rowtype([OBJECT]), -- зачитываем системные поля,
                                         -- которые являются собственными для [OBJECT]
                    r%rowtype('nosys')   -- зачитываем реквизиты выписки
                  ) in ac1.[ARC_MOVE]    -- зачитываем выписки счета ac1
            into recs%rowtype;
          n := recs%id.count;
          if n>0 then
            refs := recs%id;  -- заполняем массив ссылок (см.п.2.13)
            refs%delete;      -- удаляем выписки счета ac1
            insert into ac2.[ARC_MOVE] -- создаем выписки для счета ac2
              for i in 1..n loop
              r( r%rowtype=recs%rowtype(i)); -- nosys не нужен, т.е. в insert это
                                          -- используется по умолчанию
          end if;
        end;
                Пример 2 (присвоение):

        declare
          u [user];
          u1 [user_1]; -- дочерний от [USER]
          u2 [users2]; -- дочерний от [USER_1]
          ur [user]%rowtype;
          ur1 [user_1]%rowtype;
          ur2 [users2]%rowtype;
          ut [user]%rowtable;
          ut1 [user_1]%rowtable;
          ut2 [users2]%rowtable;
        begin
          -- присвоение реквизитов [USER] + системные реквизиты
	  u2%rowtype('self',[USER]):=u%rowtype;
          -- присвоение только реквизитов [USER_1]
	  u2%rowtype('self,nosys',[USER_1]):=u1%rowtype('self,nosys');
          -- присвоение только реквизитов [USERS2]
          -- в случае отсутствия подструктур типы [CLASS] и [CLASS]%rowtype совместимы
	  u2%rowtype('self,nosys'):=ur2%rowtype('nosys');
	  u2%rowtype('self,nosys'):=uu2%rowtype('self,nosys');
          -- присвоение реквизитов [USER] + системные реквизиты
	  ut2%rowtype('self',[USER]):=ut%rowtype;
          -- присвоение только реквизитов [USER_1]
	  ut2%rowtype('self,nosys',[USER_1]):=ut1%rowtype('self,nosys');
        end;

2.14. Реализована возможность присвоения разнотипных PL/SQL таблиц между
собой, если элементы этих таблиц совместимы с точностью до умолчательного
преобразования типов без использования функций преобразования. Такое
присвоение производится в цикле поэлементно (при этом выдается предупреждение,
т.к. если такое присвоение производится с участием NESTED TABLES и VARRAYS,
то умолчательный цикл не гарантирует от исключений, свойственных этим
типам, вследствие ограничений на используемые в них индексы (такое присвоение
уже использовалась в примерах пп. 2.8 и 2.12).
                Пример 1:
        declare
          type t_vnum is varray(100) of string;
          type t_int  is table of integer;
          t1 t_vnum;
          t2 t_int;
        begin
          t1%init;
          t1.extend(100);
          for i in 1..100 loop t1(i):=i; end loop;
          t2:=t1;
        end;
                Преобразуется:
        declare
                plp$LOOP_2    pls_integer;
                type T_VNUM is varray(100) of varchar2(128);
                T1    T_VNUM;
                T2    "CONSTANT".INTEGER_TABLE;
        begin
                T1 := T_VNUM();
                T1.EXTEND(100);
                for I in  1..100 loop
                    T1(I) := I;
                end loop;
                T2.delete; plp$LOOP_2:=T1.first;
                while plp$LOOP_2 is not null loop
                    T2(plp$LOOP_2) := T1(plp$LOOP_2); plp$LOOP_2 := T1.next(plp$LOOP_2);
                end loop;
        end;
	
----------------------------------------------------------------------
Изменения на 1.06.2004. - версия 6.2 (0).
	
        3. Разное.
3.1. Версия 6.2 реализует функционал по защите прикладного ядра (словаря
данных) по уровням доступа. Изменений языка PL/Plus по сравнению с последними
выпусками ядра 6.1 она не содержит.

3.2. На уровне словаря данных добавлена возможность указания NOT NULL
ограничения целостности в таблицах типов.

3.3. Скорректирована процедура проверки соответствия контролов формы операции
ее параметрам и переменным для операций типа "Печать". Некритические ошибки
разыменования ссылок в контролах операций "Печати" игнорируются.

3.4. Реализован кэш системных словарей (настроек - SETTINGS, профилей -
PROFILES) в пакете STDIO. Для поддержки обновления кэша при изменении
данных добавлены дополнительно два новых события (9 и 10). В пакете
VALMGR также кэшируется набор контролируемых прикладным триггером
реквизитов (сделано для оптимизации проверок возможности выполнения
оператора UPDATE), а также начальные состояния типов (для оптимизации
создания экземпляров, имеющих состояния).

3.5. Разъяснение по поводу версии ТЯ 6.1.Х и выше и Oracle9i. Версия
ТЯ 6.1 декларируется как совместимая с версией Oracle9i. Расширения
PL/SQL и SQL версии 9i реализованы в PL/Plus практически в полном
объеме, однако реализованы также и некоторые ограничения, сопутствующие
Oracle9i. В частности, - это более строгая проверка спецификаций
функций и процедур в глобальных и локальных описаниях (пакете и теле
пакета - если апеллировать к понятиям Oracle). Версия ТЯ при генерации
текста пакетов не контролирует версию Oracle, поэтому некоторые
конструкции (например, вложенные PL/SQL таблицы или таблицы PL/SQL
структур с вложенными подструктурами и другими PL/SQL таблицами,
bulk выборка в таблицу PL/SQL структур), корректные для Oracle9i,
будут приводить к ошибкам в теле пакетов PL/SQL для версии Oracle8i.
Также отмечу, что в версии Oracle8i SQL-выражения, используемые
в PL/SQL, ориентированы на SQL-синтаксис Oracle7 и в них нельзя
использовать синтаксис, разрешенный в непосредственном SQL (в
частности, это подзапросы в выборках и case выражения), так что
такой синтаксис в версии Oracle8i может использоваться только
для генерации текста представлений.

----------------------------------------------------------------------
Изменения на 30.03.2004. - версия 6.1 (build 0-1).
	
	2. Семантика.
2.1. Реализована поддержка использования SQL-типов в PL/Plus в режиме
расширенного синтаксиса (допускается использование обращений к атрибутам
и методам, в случае вызова методов проверки передаваемых фактических
значений типам параметров не производится):
		Пример:
    create type type1 as object(field1 number,field2 varchar2(100));
    create type type2 as object(x number,y type1);
                Фрагмент PL/Plus:
        declare
	   pragma pl_sql(true);
           x       type1%object;
           y       type2;
        begin
           x.field1 := 1;
           x.field2 := '1';
           y.x := 0;
           y.y := x;
           stdio.put_line_buf(y.y.field2);
        end;
    Если есть пересечение по именам со словарем IBSO или локальными для
операции переменными/типами, то обращение к SQL типам идентифицируется
модификатором %object.

2.2. Расширены возможности выборки данных в переменные-структуры или
PL/SQL таблицы структур (последнее только для Oracle 9i). Такие структуры
не должны иметь вложенных подструктур (ограничение Oracle) и могут
использоваться в конструкциях select into, return into, fetch.
		Пример:
        declare
            type cr is record(a string,	b number);
            type t_cr is table of cr;
            v_cr cr;
            v_tr t_cr;
        begin
            select u(u.name,u) in [USER] where rownum=1
              into v_cr;
            select u(u.name,u) in [USER]
             order by u.username
              into v_tr;
        end;

2.3. При использовании выборок по фиксированному набору полей (т.е.
при использовании выборок по подзапросам, внешним SQL таблицам; выборка
по типам сюда не относится) допустимо обращение к алиасу выборки без
разыменования ее по полям в списке выбираемых значений. Такое обращение
автоматически разворачивается в выборку всех полей, соответствующих
этому алиасу:
		Пример:
        declare
            type cr is record(a string,	b number);
            v_cr cr;
        begin
            select x(x) in
             (select u(u.name:name,u:id) in [USER]
               order by u.username)
             where rownum=1
              into v_cr;
        end;

2.4. В операторе UPDATE реализован синтаксис использования подзапросов для
изменения списка значений:
		Пример (суммируя вышеописанные возможности):
declare
  type cr is record(a string,	b number);
  type t_cr is table of cr;
  type t_uref is table of ref [USER];
  tr t_cr;
  tn t_uref;
begin
  for j in 1..200 loop
    tn(j) := this;
  end loop;
  update for j in 1..100 loop
  u( u.name=this.name
   ,(u.username,u.name) =
     (select x(x) in (select x(x.username,x.name) in [USER] where x=this))
   , u.username=this.username
  ) in [USER]
  where u=tn(j) and (u.username,u.name) in
    (select x(x) in (select x(x.username,x.name) in [USER] where x=this))
  return u.username,u into tr;
end;
	
        3. Разное.
3.1. Реализовано сохранение всех ошибок и предупреждений компилятора
PL/Plus для представлений (в т.ч. для PL/Plus вставок простых представлений).
В предыдущих версиях сохранялись только тексты ошибок и только для
представлений PL/Plus.

3.2. Расширена процедура подбора вызова функций и процедур по
списку фактических параметров. Теперь существует возможность выбора
между одноименными функциями и процедурами (в режиме вызова процедуры),
чего нет в PL/SQL. Оптимизирована также процедура диагностики ошибок
при подборе подходящего вызова, исключающая пропадание ошибок,
которое могло происходить при некоторых условиях в предыдущих версиях.

3.3. Снято ограничение на расширение текста операции при использовании
макро-подстановок (раньше текст не мог расширяться более чем на 40%).

3.4. Некоторые некритичные ошибки синтаксического разбора макросов переведены
из разряда ошибок в предупреждения.

3.5. Разъяснение по поводу использования перекрытых функций и процедур.
В версии 6.1.Х подбор вызова подходящей перекрытой функции или процедуры
осуществляется ВСЕГДА (точнее, это определяется глобальным системным
параметром PLP_OVERLAPPING в таблице SETTINGS). В более ранних версиях
подбор вызова по параметрам осуществляется только в режиме расширенного
синтаксиса, если же этот режим не включен, то всегда используется первый
вызов (при этом, если получается, передаваемые значения параметров
приводятся принудительно к типам параметров первого вызова). Это следует
иметь в виду при переносе операций с версии 6.1.Х на более ранние.

3.6. Разъяснение по поводу использования order by совместно с групповыми
операторами (UNION/MINUS/INTERSECT). Сортировка в таком запросе относится
ко всей выборке в целом, а не к последнему запросу, соответственно,
выражения сортировки могут обращаться только к полям всей выборки, а не
ее составляющих.

----------------------------------------------------------------------
Изменения на 30.10.2003. - версия 6.1 (build 0).
	
	2. Семантика.
2.1. Реализована поддержка использования вложенных pl/sql таблиц, которые
могут использоваться под Oracle9i:
		Пример:
	type t1 is table of number;
	type t2 is table of t1;
        t       t2;
        begin
           for i in 1..10 loop
                for j in 1..10 loop
                    t(i)(j) := (i-1)*10 + j;
                    stdio.put_line_buf(i||'.'||j||'.'||t(i)(j));
                end loop;
                t(i).delete;
           end loop;
           t.delete;
        end;

2.2. Реализована возможность вызова валидатора списочной операции через
стандартный синтаксис блокирующей ссылки (=>).

2.3. Расширен диапазон генерации алиасов используемых таблиц в одном
запросе до трех символов (от 'a' до 'zzz'). В ранних версиях этот диапазон
ограничивался значениями от 'a' до 'z'.

2.4. Оптимизирован вызов процедур обновления кэша экземпляра this в
операциях при использовании в разных ветках оператора IF.

2.5. Расширен умолчательный размер (с 16 до 128 символов) для строкового
представления ID метаклассов.

2.6. Реализован режим вызова (по общей системной настройке) перекрытых
процедур и функций, основанный на подборе подходящего вызова по типам
фактических параметров, в режиме обычного (нерасширенного) синтаксиса.
Также разрешен вызов функции CAST_TO в обычном режиме.

2.7. Реализована более жесткая проверка незакрытых блоков условной
компиляции (pragma END_IF) при их использовании внутри отключенных
участков кода:
		Пример:
        pragma if_def(xxx);
        if smth then -- отключен весь оператор if вместе с содержимым
            null;
            pragma end_if; -- не выполняется, т.к. находится в отключенном блоке
        end if;

2.8. Расширена диагностика ошибок при обработке синонимов в режиме
расширенного синтаксиса.

2.9. Расширены опции управления вычислениями на этапе компиляции. Введены
4 опции:
    - expressions - вычисление выражений (арифметических операторов, логических
      операторов, операторов конкатенации), содержащих явные константы, а также
      основных системных функций (см.п.3.1), параметрами которых являются константы.
      К явным константам относятся :
      а) строковые константы, т.е. строки, заключенные в одинарные кавычки (например, 'example'),
      б) числовые константы, т.е. строковое представление чисел (например, -123, 456.789),
      в) логические константы (true, false),
      г) пустая константа (null),
      д) ранее вычисленные выражения (которые преобразуются к виду a) - г).
    - constants - вычисление выражений, содержащих неявные константы, каковыми
      являются глобальные константы пакетов операций и системных пакетов (т.е.
      инициализируемые переменные, описанные ключевым словом const).
    - attributes - вычисление реквизитов (строковых и ссылочных) экземпляров
      по ссылке-константе (с заданным или вычисленным значением ID), а также
      реквизитов статического экземпляра ТБП SYSTEM (кроме операций в самом
      типе SYSTEM).
    - classes - вычисление значений ссылок в конструкции поиска по логическому
      условию вида ::[CLASS](<condition>).
По умолчанию при включенных вычислениях все опции включены. Опции constants и
attributes зависят от опции expressions (т.е. отключение expressions автоматически
отключит и эти 2 опции), опция classes независимая, т.е. вычисления производятся
независимо от других опций. Управление опциями вычилений осуществляется с помощью
прагмы calculate:
        pragma calculate(<mode> {,<options>});
где
    mode - устанавливаемый режим вычислений:
    - true,false - включение/выключение вычислений (если указаны <options>,
      то переключаются указанные опции, если не указаны, то переключаются все
      сразу),
    - set - включение опций, указанных в <options>, и выключение опций, не
      указанных в <options>,
    options - строка, содержащая список опций (разделенных точками, например,
      'expressions.classes'), либо значение 'all', означающее все опции.

2.10. Расширены опции управления оптимизацией кода операций. Введены
4 опции:
    - declarations - удаление неиспользуемых в исполняемом коде описаний типов,
      переменных, курсоров, функций и процедур.
    - this - генерация кода операций с использованием внутренней кэш-переменной
      для используемых в операции реквизитов экземпляра this.
    - code - удаление неиспользуемых участков исполняемого кода, т.е. кода после
      операторов return, raise, goto, exit, continue, отдельных ветвей оператора
      IF, соответствующих значениям условия false или null.
    - descriptions - замена описаний pl/sql таблиц на существующие стандартные
      типы (например, RTL.STRING_TABLE, RTL.NUMBER_TABLE и пр.).
Опции независимы друг от друга, по умолчанию при включенном флаге оптимизации
все опции включены. Опции code и descriptions по умолчанию включены даже если отключен
общий флаг оптимизации (для совместимости с предыдущими версиями, где эти опции
были не отключаемыми). Управление опциями вычислений осуществляется с помощью
прагмы optimize:
        pragma optimize(<mode> {,<options>});
где
    mode - устанавливаемый режим вычислений:
    - true,false - включение/выключение оптимизации (если указаны <options>,
      то переключаются указанные опции, если не указаны, то переключаются
      только declarations и this),
    - set - включение опций, указанных в <options>, и выключение опций, не
      указанных в <options>,
    options - строка, содержащая список опций (разделенных точками, например,
      'declarations,code'), либо значение 'all', означающее все опции.

2.11. Реализована замена обращений к глобальным переменным и константам
текущей операции на обращения без префикса pl/sql пакета (в случае вычислений
на этапе компиляции это могло приводить к недетерминированной генерации
результирующего кода и зависимости этого кода от результатов предыдущей
компиляции). Например, обращения к глобальной переменной V1 просто по имени
V1 или при указании префикса текущей операции (т.е. [CLASS]::[METHOD].V1)
транслируются одинаково.

2.12. Добавлена новая прагма DEFOPTIONS для управления настройками компилятора:
        pragma defoptions(<mode> {,<compiler option>});
где
    mode - устанавливаемый режим:
    - get - чтение настроек компилятора во внутренний буфер (если указана
      <compiler option>, то считывается указанная опция компилятора, если не
      указана, то считываются все настройки),
    - set - восстановление настроек компилятора из внутреннего буфера (если указана
      <compiler option>, то восстанавливается указанная опция компилятора, если не
      указана, то восстанавливаются все настройки), сохраненного по get, либо
      исходных опций, указанных в свойствах операции,
    compiler option - имя опции компилятора (соответствующая прагма), допустимые значения:
        WRITE_LOG
        CALCULATE
        OPTIMIZE
        SUBSTITUTE
        CACHE
        USE_COMMIT
        CHECK_TYPE
        LOCK_THIS
        CHECK_OBJ
        CREATE
        PLSQL
        ARCHIVE
        TBL_ORDER
        THIS_NULL
		Пример:
        pragma defoptions(get,calculate); -- сохраняем текущие настройки вычислений
        pragma calculate(false,attributes);
            cur_val := [SYSTEM]::[SYS_MAIN_VAL];  -- значение ссылки вычислено не будет
        pragma defoptions(set,calculate); -- восстанавливаем настройки вычислений

2.13. Расширено использование параметров указания типа соединения (inner/outer joins) и
переопределения типа для модификатора %ID в случае использования в pl/plus-запросах,
позволяющее использовать связывание иерархических типов между собой. Такое поведение
реализовано также в версии ТЯ 6.0.1. Как замечание можно отметить, что если связывание
происходит непосредственно от основной таблицы (не по ссылке), тогда всегда используется
внутреннее соединение независимо от того, где используется такая конструкция
(в дополнение к принципам, изложенным в п.2.3 изменений от 20.03.2002).
		Пример:
        for (select t(
            DECODE( t%id(true,::[CL_PRIV] )
                  , t%id,  ::[CL_PRIV]%classname
                  , DECODE( t%id(true,::[CL_CORP] )
                          , t%id,  ::[CL_CORP]%classname)
                  , 'Другие')
        ) in ::[CLIENT])
        loop exit; end loop;
                Преобразуется в:
	declare
		cursor c_obj is
			select  DECODE(a2.ID,a1.ID,'Физические лица'
                                       ,DECODE(a3.ID,a1.ID,'Юридические лица')
                                       ,'Другие') A$1
			from Z#CL_CORP a3, Z#CL_PRIV a2, Z#CLIENT a1
			where a1.id=a2.id(+) and a1.id=a3.id(+);
		T	c_obj%rowtype;
	begin
		for plp$c_obj in c_obj loop
			T := plp$c_obj;
			exit ;
		end loop;
	end;

2.14. Расширены возможности использования оператора INSERT и модификатора %INSERT.
Теперь он позволяет копировать структуру дочернего типа в коллекцию родительского
типа.
		Пример:
        x  [CHILD_CLASS];
        y  [CLASS];
        z  [PARENT_CLASS];
        coll [CLASS_ARR];
        begin
            insert x into coll;  -- вставка дочерней структуры
            insert y into coll;  -- вставка своей структуры
            insert z into coll;  -- вставка родительской структуры - ОШИБКА!!!
        end;
Схема работы оператора INSERT <Переменная> INTO <Коллекция>
  (или <Коллекция>%INSERT(<Переменная>)):
        Тип Переменной  Тип Коллекции   Действие
        CLASS           CLASS           COPY(<Переменная>,<Коллекция>)
        ref CLASS       CLASS           SET_COLLECTION(<Переменная>,<Коллекция>)
        ref ref CLASS   CLASS           SET_COLLECTION(GET_REF(<Переменная>),<Коллекция>)
        CLASS           ref CLASS       COPY(COPY(<Переменная>,<CLASS>),<Коллекция>)
        ref CLASS       ref CLASS       COPY(<Переменная>,<Коллекция>)
        ref ref CLASS   ref CLASS       SET_COLLECTION(<Переменная>,<Коллекция>)
где
   COPY - создание нового экземпляра из переменной-структуры,
   SET_COLLECTION - перемещение существующего экземпляра, на который указывает
     переменная-ссылка, в новую коллекцию,
   GET_REF - получение значения по ссылке (разыменование на один уровень).

2.15. Запрещена модификация системных реквизитов (%CLASS,%STATE,%COLLECTION)
в операторе UPDATE.

	3. Разное.
3.1. Разъяснения по поводу вычислений на этапе компиляции (если они включены, а они
включены по умолчанию, а почему бы и нет?, а вы как думали? - то-то... - шутка):
    - при использовании в выражениях глобальных констант (описанных через синтаксис
      const в секции глобальных описаний), эти выражения вычисляются независимо от того,
      как инициализируются глобальные константы (т.е. их инициализация может зависеть от того,
      кто компилирует операцию, соответственно, разные пользователи, компилирующие операцию,
      содержащую выражения с такой константой, могут получить разный код pl/sql пакета).
    - при использовании конструкции поиска по логическому условию (::[CLASS](<condition>)),
      конструкция вычисляется ВСЕГДА, независимо от того, использует ли она не вычисляемые
      в обычном режиме выражения, вызовы не вычисляемых функций, обращения к глобальным
      переменным (не константам) и т.д.
    - вычисляются строковые и ссылочные реквизиты (т.е. все, кроме дат, чисел и логики)
      статического экземпляра ТБП SYSTEM и экземпляров, полученных при поиске по логическому
      условию (см. предыдущий пункт), причем ссылки могут вычисляться при любом уровне
      вложенности.
    - список системных функций, которые вычисляются для константных и вычисляемых аргументов:
                ABS
                ASCII
                CEIL
                FLOOR
                INITCAP
                INSTR
                LENGTH
                LOWER
                LPAD
                LTRIM
                MOD
                REPLACE
                ROUND
                RPAD
                RTRIM
                SUBSTR
                TO_CHAR
                TO_NUMBER
                TRANSLATE
                TRUNC
                UPPER
                SIGN
                BITAND
                TRIM
                RTL.OBJECT_CLASS
                RTL.OBJECT_STATE
                RTL.OBJECT_COLLECTION
                RTL.OBJECT_PARENT
                RTL.OBJECT_CLASS_PARENT
                RTL.OBJECT_CLASS_ENTITY
                RTL.BOOL_CHAR
                RTL.BOOL_NUM
                RTL.SAFE_REPLACE
                RTL.CLASS_PARENT
                RTL.CLASS_ENTITY
                RTL.COLLECTION_PARENT
                RTL.COLLECTION_CLASS
                RTL.OBJECT_PARENT_CLASS
                LIB.CLASS_NAME
                LIB.STATE_NAME
                LIB.ATTR_NAME
                LIB.CLASS_SIZE

3.2. Разъяснение по поводу использования типа integer в PL/Plus. Этот тип
отображается в pls_integer PL/SQL, который эквивалентен 4-байтовому целому
числу (от -2147483648 до 2147483647). Т.е. это совсем не тот integer, который
есть в SQL (до 38 знаков), и это нужно учитывать при написании кода операций.
Сделано это в целях оптимизации целочисленных вычислений и индексирования
pl/sql таблиц, которые выполняются значительно быстрее, чем вычисления
чисел с плавающей точкой (таковыми являются все числовые типы, кроме
pls_integer).

3.3. Разъяснения по поводу использования команд препроцессору PL/Plus.
Препроцессор отрабатывает в три прохода:
  1) Синтаксический разбор текста операции (формирование дерева разбора),
     при этом обрабатываются inline-команды (см.п.2.1 изменений от 20.08.2003),
     прагмы создания переменных условной компиляции и макросов (define,macro,include),
     макроподстановки, операторы условной компиляции (if_def,end_if).
  2) Семантический анализ дерева разбора, полученного на этапе 1. При этом
     происходит разрешение всех семантических конструкций, т.е. описаний,
     операторов, определение вхождений всех идентификаторов (функций, процедур,
     переменных и пр.), проверка соответствия типов и т.д. При этом также выполняются
     команды условной компиляции if_def - end_if (inline команды, define, macro,
     include уже не выполняются), а также остальные прагмы, в т.ч. команды управления
     опциями компилятора, причем эти команды уже подчиняются общей структуре дерева
     разбора, так что прагмы if_def - end_if могут оказаться в разных уровнях (см.п.2.7).
  3) По полученному дереву формируется текст операции на pl/sql. Все команды
     компилятора отрабатывают еще раз. При этом стартовое состояние флагов
     компиляции (если они изменялись на этапе 2) может быть отличным от того,
     какое было при старте этапа 2. Опции препроцессора избирательны к этапам
     его работы, так что команды управления опциями компиляции должны это учитывать.
     Итак опции компилятора:
        WRITE_LOG  - этап 3,
        CALCULATE  - этап 3,
        OPTIMIZE   - declarations, descriptions - этап 2, this, code - этап 3,
        SUBSTITUTE - этап 3,
        CACHE      - этап 3,
        USE_COMMIT - этап 3,
        CHECK_TYPE - этап 2,
        LOCK_THIS  - этап 3,
        CHECK_OBJ  - обрабатывается при генерации интерфейсного пакета операции,
        CREATE     - этап 3,
        PL_SQL     - этап 2,
        ARCHIVE    - этапы 2,3,
        TBL_ORDER  - этап 3,
        THIS_NULL  - этап 3,
     Другие прагмы:
	HINT       - этап 3,
	INITIALIZE - этап 2,
	GET_THIS   - этап 3,
	SET_THIS   - этап 3,
	SET_DEBUG  - этапы 2,3,
	DEBUG      - этап 2,
	ERROR      - этап 2,
	MACRO      - этап 1,
	DEFINE     - этап 1,
	INCLUDE    - этап 1,
	IF_DEF     - этапы 1,2,3,
	END_IF     - этапы 1,2,3,
        DEFOPTIONS - этапы 2,3,


3.4. Разъяснение по поводу использования прагмы RESTRICT_REFERENCES. В версии
Oracle 8 и выше при использовании функций в запросах эту прагму указывать не
обязательно, т.к. Oracle отслеживает выполняемые функцией действия (в случае
динамических запросов это можно сделать только на этапе выполнения), и в случае
выполнения недопустимых действий, генерит исключение. На текущий момент не совсем
понятно, делаются ли указанные проверки в случае явного указания прагмы, возможно,
она как-то все-таки влияет на механизм проверки, упрощая и ускоряя его, хотя
последнее не замечено (ускорение вызова функций заметно при использовании хинта
deterministic в случае использования одинаковых значений в качестве параметра -
см.п.1.4 изменений от 1.03.2003). Что касается препроцессора PL/Plus, то прагма
restrict_references, содержащая опцию WNDS, указывает ему, что функцию, обладающую
такой прагмой, можно использовать непосредственно в тексте PL/Plus-запросов,
в противном случае такие вызовы выносятся из запроса путем генерации буферной
переменной с присвоением значения этой функции. Причем при использовании прагмы
в глобальных описаниях, она действует на указанную функцию и для компилятора
PL/SQL (т.е. он проверяет на допустимость соответствующих опций на уровне
PL/SQL) и для компилятора PL/Plus. Если же прагма указывается в локальных
описаниях, то она воздействует только на компилятор PL/Plus и позволяет ему
использовать ее в запросах (на уровне PL/SQL у такой функции прагмы не будет,
однако это не мешает ее использованию в SQL-запросах).

3.5. Разъяснения по поводу использования механизма рассылки событий (см. также
п.3.3 изменений от 30.11.2001).
В версии 6.0.1 реализованы следующие типы событий (коды):
0 - инициализация значений ID статических экземпляров и инициализация
    интерфейсного пакета ТБП (внутренних кэш-переменных пакета), ID
    которого указывается в p_event (если он не пуст),
1 - инициализация значений ключей архивации и системного контекста <OWNER>_SYSTEM,
    а также инициализация интерфейсного пакета ТБП (внутренних кэш-переменных пакета),
    ID которого указывается в p_event (если он не пуст),
2 - инициализация контекстов - системного и пользовательского, инициализация
    контекста доступа опциональна - она выполняется, если p_event<>'0',
3 - выполнение PL/SQL блока, текст указывается в p_event,
4 - сброс флагов инициализации типов (p_event - ID типа, если пуст, тогда
    сбрасывается состояние всех типов).
5 - блокировка контекста пользователя - все значения атрибутов всех контекстов
    сбрасываются в null, без дальнейшей возможности их переинициализации
    (p_event несущественен),
6 - сброс состояния пакетов (сбрасываются все значения всех переменных всех пакетов)
    и переинициализация системного контекста (p_event несущественен),
7 - переинициализация флага возможности редактирования прикладных данных и
    текущего приоритета запускаемых операций (вызывается при изменении системных
    настроек PLP_READ_ONLY и CURRENT_PRIORITY, p_event несущественен),
8 - привязка сессии к серверу LOCK_INFO, в p_event указывается порядковый номер
    сервера (в пределах от 0 до значения настройки LOCK_SERVERS без единицы),
9 - событие закрытия сессии, т.е. принудительное выполнение rtl.close.

3.6. Разъяснения по поводу поддержки системных индексов:
  - индексы создаются по всем колонкам-ссылкам и коллекциям, если не указано
    свойство "Не создавать ограничения целостности" для соответствующей колонки,
    делается это для поддержки целостности по ссылкам и уникальности по коллекциям,
    также создается индекс и по колонке COLLECTION_ID (если она есть);
  - индексы не создаются по колонкам, которые участвуют в прикладных индексах
    в качестве первой колонки (в этом случае для поддержки целостности
    используются прикладные индексы);
  - в версии ТЯ 6.0 и выше при создании прикладного индекса, использующего
    автоматически индексируемую колонку в качестве первой, системный индекс
    по этой колонке удаляется за ненадобностью (в этом случае для поддержки
    целостности используется созданный прикладной индекс).
Замечания по поводу использования function based индексов:
  - при использовании формулы для колонки-ссылки в первой позиции индекса,
    системный индекс для той же колонки не удаляется;
  - использование function based индексов возможно только в сессиях, в которых
    установлен параметр query_rewrite_enabled в значение true. Т.о., если
    предполагается использование таких индексов, то нужно позаботиться о выставлении
    этого параметра. Это можно сделать на уровне экземпляра Oracle, можно
    добавить установку этого параметра в профили пользователей в настройку
    ALTER_SESSION (по аналогии с параметрами оптимизатора), либо явно выполнить
    SQL команду в пользовательской функции инициализации сессии или типа, где
    такой индекс используется (это можно сделать через rtl.execute_sql):
        alter session set query_rewrite_enabled=true


3.7. Не рекомендуется использовать в Pl/Plus имена ID, CLASS_ID, STATE_ID,
COLLECTION_ID и начинающиеся с префикса С_ для имен переменных и параметров
процедур и функций. Особенно это критично при использовании таких переменных
в PL/Plus запросах, т.к. эти запросы транслируются в обращения к именам
колонок таблиц, которые могут совпасть с указанными именами (в этом случае
имена колонок переопределяют имена переменных в запросах).

----------------------------------------------------------------------
Изменения на 20.08.2003. - версия 6.1 (build 0).
	
	1. Синтаксис.
1.1. Реализованы подзапросы-выражения в выборках (в т.ч. в SELECT-листе).
		Пример:
	select x(x,(select u(u.[username]) in [USER] where u=x.[Document_User]))
	    in [MAIN_DOCUM] where x.[date_prov] is not null and rownum<2
	  into doc_id,usr_name;
	
1.2. Реализованы case-выражения в выборках.
Синтаксис:
	CASE WHEN condition1 THEN expression1
	{WHEN condition2 THEN expression2}
	...
	{WHEN conditionN THEN expressionN}
	{ELSE else_expression}
	END
где
	condition1..conditionN - логические выражения,
	expression1..expressionN - скалярные выражения-результаты при выполнении
		соответствующего логического условия condition1..conditionN;
	else_expression - скалярное выражение-результат при невыполнении ни одного
		из условий condition1..conditionN;
	Выражения-результаты должны иметь один и тот же тип.
	Case-выражения допустимы только в операторах FOR/LOCATE/SELECT/UPDATE/DELETE/%LOCATE.


1.3. Реализованы подзапросы-курсоры в SELECT-листе. Тип колонки-курсора в выборке -
ссылочный курсор (ref cursor) с возвращаемой структурой, соответствующей выборке.
При успешном извлечении данных из выборки, содержащей подзапросы-курсоры, соответствующие
ссылочные курсоры будут автоматически открыты, так что из них тоже можно извлекать
данные, либо передавать параметрами в другие процедуры, которые эти данные
обрабатывают.
		Пример:
	s 	string;
	n1 	number;
	n2	number;
	type c1 is select z(z,z) in [USER];
	c2 c1;
	type xx is
		 select u(u:id,(case when n1=0 then null when n1=1 then u.username else u.name end),
		          (select x(x.username) in [user] where x=u),
		          cursor(select x(x.name,x) in [user] where x<>u)
		          ,cursor(c2)
		          )
		   in [user], (c1 : z) where z.a$1=u and((n1>=n2) and not b or (n1<n2) and b)
		   and (case when n1=0 then null when n1=1 then u.username else u.name end) is not null;
	type cr is record(a string,	b number);
	type ccx is ref cursor return xx;
	type cc is ref cursor return cr;
	type c_ref is ref cursor;
	c  cc;
	c3 cr;
	cx ccx;
	c_all c_ref;

ПРИМЕЧАНИЕ: Синтаксис пп. 1.1 - 1.3 на платформе Oracle8i может использоваться только
    для создания PL/Plus-представлений, в текстах операций этот синтаксис можно использовать
    только под Oracle9i.

1.4. Реализована поддержка присвоения переменных, описанных как ссылочные курсоры,
с проверкой соответствия структур курсоров, если они типизованы. Присвоение не типизованных
курсоров проверяется в момент их фактического присвоения на этапе выполнения.
		Пример (описания типов и переменных см.п.1.3):
	c := c_all; --valid assignment
	c := cx;    --invalid assignment
	cx.open(xx);
	loop
		cx.fetch(n1,n2,s,c_all,c);
		exit when cx%notfound;
		c.fetch(c2);
		c.close;
	end loop;
	
1.5. Реализованы операторы для работы со статическими курсорами:
Открытие курсора:
	cur.OPEN;
	где - cur - переменная, описанная как статический курсор,
Извлечение данных:
	cur.FETCH [(variables_list)];
	cur.FETCH_LIMIT (integer_expr,variables_list);
	где - variables_list - переменные-приемники данных, могут быть PL/SQL таблицы
			(тогда в них помещается весь набор данных, извлекаемый выборкой), либо
			это может быть переменная-структура, соответствующая по типу полей с
			выбираемым списком значений в select-листе. Список переменных-приемников
			для статического курсора указывать необязательно, т.к. в этом случае
			извлечение данных происходит в саму переменную-курсор;
		- integer_expr - выражение, ограничивающее к-во извлекаемых записей
			(приемники должны быть PL/SQL таблицы), в этом случае variables_list должен
			быть указан явно.
Дополнительные атрибуты:
	cur.ISOPEN 		- boolean, признак был ли курсор открыт (инициализирован),
	cur.FOUND       - boolean, признак были ли извлечены записи по последнему FETCH,
	cur.NOTFOUND    - boolean, обратный к FOUND,
	cur.ROWCOUNT    - integer, к-во извлеченных записей по последнему FETCH.
		Пример (описания типов и переменных см.п.1.3):
	c2.open;
	loop
		C2.FETCH;
		exit when C2%NOTFOUND;
	end loop;
	c2.close;


	2. Семантика.
2.1. Реализована поддержка расширенного набора inline-команд условной компиляции
через специальный формат строки-комментария. Команда условной компиляции
идентифицируется знаком '#' в первой позиции текста комментария. Реализован
следующий набор команд:
#DEFINE id {/USUAL SUBSTITUTE PROCESS EXECUTE/} {QUOTE} {text}
	определение переменной условной компиляции или макроса (если задан text) с
	именем id, при этом текст макроса text может также содержать другие макросы,
	в т.ч. и исполняемые. Тип макроса также может быть определен сразу после его
	имени (если тип макроса не указан, тогда используется опция USUAL, т.е. простой
	макрос), а также может быть указана опция заключения результата макроса в кавычки
	(ключевые слова quote, quotes).
#UNDEF id
	удаление переменной условной компиляции и макроса с именем id.
#INCLUDE {[} id {]} { /. ::/ {[} id {]} }
	импорт макро-определений и переменных условной компиляции другой операции в текущую
	операцию. Если указан только один id, то он воспринимается как короткое имя операции
	в том же типе, что и импортирующая операция, если заданы оба id, тогда первый
	воcпринимается как ID класса, а второй как короткое имя импортируемой операции.
#IFDEF id
	включает в результирующий текст для обработки компилятором следующий за оператором
	текст вплоть до одной из команд #ELSIF,#ELSE,#ENDIF в случае, если существует макрос
	или переменная условной компиляции с именем id.
#IFNDEF id
	включает в результирующий текст для обработки компилятором следующий за оператором
	текст вплоть до одной из команд #ELSIF,#ELSE,#ENDIF в случае, если не существует
	как макрос, так и переменная условной компиляции с именем id.
#IF expression
	включает в результирующий текст для обработки компилятором следующий за оператором
	текст вплоть до одной из команд #ELSIF,#ELSE,#ENDIF в случае, если значение
	логического выражения expression, вычисляемое на этапе компиляции, будет равно
	true.
#ELSIF expression
	включает в результирующий текст для обработки компилятором следующий за оператором
	текст вплоть до одной из команд #ELSIF,#ELSE,#ENDIF в случае, если значение
	логического выражения expression, вычисляемое на этапе компиляции, будет равно
	true и при этом ни одно из предшествующих условий (#IF,#IFDEF,#IFNDEF,#ELSIF)
	не выполнилось.
#ELSE
	включает в результирующий текст для обработки компилятором следующий за оператором
	текст вплоть до команды #ENDIF в случае, если ни одно из предшествующих условий
	(#IF,#IFDEF,#IFNDEF,#ELSIF) не выполнилось.
#ENDIF
Операторы #IF,#IFDEF,#IFNDEF должны обязательно завершаться командой #ENDIF, они могут
содержать несколько #ELSIF блоков и команду #ELSE, которая если задана, то должна
предшествовать только #ENDIF. Т.е. структура операторов условной компиляции #IF,#IFDEF,
#IFNDEF аналогична структуре исполняемого оператора IF в PL/Plus. Операторы могут быть
вложены друг в друга по правилу скобок #IF,#IFDEF,#IFNDEF - #ENDIF.
Логическое выражение expression может содержать (в порядке убывания приоритета конструкций):
- конструкции макроподстановок в стандартном формате (&ID);
- конструкция exists(id) (аналог конструкции defined в C++), которая возвращает
  TRUE, если макрос или переменная условной компиляции с именем id определена,
  FALSE в противном случае;
- имена (идентификаторы) макросов и переменных условной компиляции, на место которых
  в текст выражения вставляется строковая константа с содержимым тела макроса или
  логическая константа TRUE, соответственно;
- вызовы стандартных функций (пакета STANDARD, например, LTRIM, RTRIM);
- вызовы функций пакетов ТЯ с указанием префикса пакета (например, LIB.IS_PARENT);
- пользовательских библиотечных функций (с использованием синтаксиса полного разыменования
  [class]::[lib_name].func_name);
- любые агрегирующие конструкции логических выражений (операторы OR, AND, IN, LIKE, NOT,
  IS NULL, IS NOT NULL, операторы сравнения, арифметические операторы и конкатенацию с последующим
  сравнением).
ПРИМЕЧАНИЕ:
  1. В отличие от операторов pragma, inline-команды могут использоваться в любом
     месте текста PL/Plus независимо от синтаксических структур языка.
  2. В отличие от операторов pragma, inline-команды управляют формируемым текстом
     операции и выполняются один раз на этапе разбора исходного текста, тогда как
     операторы pragma выполняются 2 раза - сначала при семантическом разборе, затем при
     формировании результирующего текста (это различие имеет значение при одновременном
	 использовании однотипных inline-команд и соответствующих прагм).
  3. При определении тела макроса (text в #DEFINE) могут использоваться другие макросы,
     причем в результирующий текст определяемого макроса вставляются их значения.
  4. В телах исполняемых макросов (PROCESS,EXECUTE) конструкции обращения к библиотечным
     функциям в полном формате ([class]::[lib_name].func_name) автоматически заменяются
     на соответствующие обращения к именам PL/SQL пакетов, содержащих эти функции.
		Пример:
	pragma macro(ddd,'UTILS.HASH_VALUE([1])',execute);
	pragma macro(eee,&ddd(user),substitute,quotes);
	pragma macro(xxx,'[1]+[2]',execute);
/*# define fff*/  -- определяем переменную условной компиляции fff
	pragma if_def(fff) -- true  при первом проходе, т.к. определена предыдущим оператором,
	                   -- false при втором проходе, т.е. последующий текст не будет включен в
					   -- результирующий
--# define fff usual &xxx(1,3) = rtrim('5''','''')
-- определение макроса с именем fff
		s:=
		/*# if &fff and exists(xxx) or not [user]::[checker2](stdlib.userid,null,3,4,5)=123 */
			'2'
		/*#else*/
			--#ifndef bbb
			'3'
			--#elsif not exists(bbb) and not exists(ccc)
			'4'
			--#elsif not exists(ddd)
			'5'
			--#else
			'6'
			--#endif
		/*#endif*/
	pragma end_if
/*#undef fff*/  -- удаление макроса и переменной условной компиляции с именем fff


2.2. Прагма DEFINE опционально может принимать вторым параметром логическую константу
FALSE, в этом случае переменная условной компиляции, имя которой указано первым параметром,
будет исключена из списка существующих переменных условной компиляции, при этом будет удален
также макрос с тем же именем (при объявлении переменной условной компиляции всегда
определяется и макрос, содержащий логическую константу TRUE, этот макрос может быть
в дальнейшем переопределен). В отличие от команды #UNDEF макрос не будет удален, если
переменной условной компиляции с тем же именем не существует, в этом случае макрос нужно
явно удалять директивой pragma macro с пустым текстом тела макроса.

2.3. В процедуры DEBUG_LOG, DEBUG добавлен параметр p_code, позволяющий заполнять
поле CODE в журнале отладочных сообщений схемы Аудита (AUD).	

	3. Разное.
3.1. Хинт deterministic выставлен всем функциям ТЯ, используемым в выборках, а также
функциям интерфейсных пакетов типов.

3.2. Скорректирована процедура подбора по списку параметров подходящего вызова
процедуры или функции (в режиме расширенного синтаксиса), исключающая пропадание
текстов других ошибок.

3.3. Сохранение полного набора ошибок при компиляции представлений.

3.4. Расширена структура представлений в "Системных журналах" в соответствии
с изменениями в схеме Аудита (AUD).

----------------------------------------------------------------------


Используемая нотация при описании синтаксиса:
    - прописными буквами указаны ключевые слова,
    - конструкции в фигурных скобках опциональны (их можно опускать),
    - конструкции в косых скобках содержат набор допустимых опций,
    - многоточия (три точки) означают список однотипных выражений,
    - строчными буквами указаны вложенные в основной синтаксис другие
      элементы, описываемые отдельно,
    - описания в обрамления знаков меньше-больше (<...>) означают
      мнемонические конструкции, смысл которых определен в самом описании.

