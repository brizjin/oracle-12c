            Краткое описание процедур пакета STDIO.


                1. Исключения.

READ_ERROR         - ошибка чтения файла.
WRITE_ERROR        - ошибка записи в файл.
INVALID_PATH       - неверное имя файла.
INVALID_MODE       - неверная мода открытия файла.
INVALID_FILEHANDLE - неверный дескриптор открытого файла.
INVALID_OPERATION  - неверная операция для файла (например запись
                     в файл, открытый на чтение).
INVALID_LINESIZE   - неверно заданная длина строки (не может быть больше 32К)
BUFFER_OVERFLOW    - ошибка Oracle (-20000),
                     ошибка переполнения буфера сессии при выводе через dbms_output
PIPE_OVERFLOW      - ошибка Oracle (-6558),
                     ошибка переполнения буфера dbms_pipe (>4096 байт)
PIPE_EMPTY         - ошибка Oracle (-6556),
                     ошибка пустого буфера dbms_pipe (нет элементов в буфере)
PIPE_TYPE          - ошибка Oracle (-6559),
                     ошибка извлечения из буфера dbms_pipe значения неправильного типа
NULL_PIPE          - ошибка Oracle (-23321),
                     ошибка обращения к dbms_pipe с пустым именем пайпы
ACCESS_PIPE        - ошибка Oracle (-23322),
                     ошибка доступа к приватной пайпе

                2. Константы.

DOSTEXT   constant integer := 1; -- кодировка DOS (OEM 866).
UNXTEXT   constant integer := 2; -- кодировка UNIX (ISO 8859-5).
WINTEXT   constant integer := 3; -- кодировка WINDOWS (WIN 1251).
KOITEXT   constant integer := 4; -- кодировка KOI (KOI-8 RUS).
STDIOPIPESIZE  constant integer := 1024*32; -- умолчательный размер пайпов
STDIOTIMEOUT   constant integer := 0;       -- умолчательное время ожидания чтения из пайп (время записи в пайпу на 1 больше)
STDIOPIPENAME  constant string(6) := 'stdio$'; -- умолчательный префикс имен пайпов
STDIOLINESIZE  constant integer := 1024*32; -- умолчательный размер длины строки файловых операций
STDIOBUFFERSIZE constant integer:= 300000;  -- умолчательный размер буфера сессии


                3. Файловые операции.

procedure SET_DEF_TEXT( p_txt string,
                        p_slash  string default null,
                        p_add_cr string default null,
                        p_name_txt string default null );
    устанавливает умолчательную кодировку пакета STDIO, которая
    будет использоваться при текстовых преобразованиях, когда
    тип текста в функциях чтения/записи данных из/в файлов/файлы
    на сервере не задан или задан как NULL. В параметре p_txt имеет
    значение лишь первая буква - D - DOS, W - WINDOWS, U - UNIX, K - KOI-8.
    Умолчательная кодировка определяется системным параметром DEF_TEXT
    (меню "словарь-системные справочники-параметры" Администратора
    словаря данных), если же параметр не установлен, тогда
    используется кодировка UNIX. Устанавливает также (если задан
    параметр p_slash) символ-разделитель имен каталогов на сервере.
    Умолчательное значение разделителя определяется системным параметром
    DEF_SLASH, если же параметр не установлен, тогда он равен '/'.
    Устанавливает также набор кодировок (если задан параметр p_add_cr -
    перечисленные кодировки или их первые буквы), при которых во время
    чтения-записи строк из файлов удаляется-добавляется символ перевода
    каретки chr(13) в конце строки. Умолчательное значение набора кодировок
    определяется системным параметром DEF_CR_ADD, если же параметр не
    установлен, тогда он равен 'DOS,KOI'. Устанавливает также умолчательную
    кодировку имен каталогов и файлов на сервере (если задан параметр
    p_name_txt - значения те же, что и для p_txt). Умолчательное значение
    кодировки имен файлов определяется системным параметром STDIO_FILE_NAME_TEXT,
    если же параметр не установлен, тогда он совпадает с умолчательной
    кодировкой пакета STDIO (DEF_TEXT). Кодировка имен файлов может быть
    явно задана в процедурах и функциях пакета, где используются имена
    файлов и каталогов, в этом случае явно заданное значение перекрывает
    умолчательное значение. Устанавливать умолчательное значение рекомендуется,
    если к файловой системе сервера существует какой-либо иной доступ,
    кроме STDIO (например, ftp), чтобы русские имена файлов и каталогов
    "выглядели" одинаково при разном доступе (если кодировка имен файлов
    не задана, тогда имена, продуцированные пакетом stdio будут в кодировке
    БД, т.е. DEF_TEXT, а файлы, создаваемые по ftp, не перекодируются и будут
    в такой же кодировке, что и исходные клиентские файлы).

function TRANSFORM (text string, in_text integer, out_text integer) return string -
    преобразование строки text из кодировки in_text в out_text
    (преобразование действует только на буквенные литералы).
    Возвращает преобразованную строку.

function OPEN (location string, filename string, openmode string,
               raising boolean default FALSE,
               line_size integer default NULL,
               name_text integer default NULL ) return integer -
    возвращает число - дескриптор открытого файла, параметры :
      location - каталог расположения файла,
      filename - имя файла,
      openmode - мода открытия файла ('r' - чтение, 'w' - запись,
                 'a' - запись в конец файла),
      raising  - умолчательный параметр (по умолчанию false), если
                 установлен в true, то при ошибках открытия файла
                 возникают исключения INVALID_PATH, INVALID_MODE,
                 INVALID_OPERATION, иначе выдаются сообщения об
                 ошибке.
      line_size- максимальная длина строки в файловых операциях - до 32k.
      name_text- кодировка имени файла и каталога, если не задана или
                 пустая, тогда используется умолчательная кодировка
                 имен файлов (см. set_def_text).

procedure CLOSE(file in out integer, raising boolean default FALSE) -
    закрывает файл, параметры:
      file - дескриптор открытого файла,
      raising  - умолчательный параметр (по умолчанию false), если
                 установлен в true, то при ошибках закрытия файла
                 возникают исключения WRITE_ERROR, INVALID_FILEHANDLE,
                 иначе выдаются сообщения об ошибке.

function  IS_OPEN ( file   IN integer ) return boolean;
    возвращает признак - был ли открыт файл с заданным в file дескриптором.

procedure PUT_LINE(file integer, text string, raising boolean default FALSE,
                   in_text integer default NULL,out_text integer default NULL) -
    записывает строку в файл, параметры :
      file - дескриптор открытого файла,
      text - записываемый текст, если заданы in_text и out_text (по
             умолчанию не задаются), то при записи производится_
             перекодировка из in_text в out_text, причем, если
             выходная кодировка попадает в список DEF_CR_ADD,
             например, DOS,KOI (out_text=DOSTEXT,KOITEXT),
             то в конец строки text добавляется символ перевода
             каретки (chr(13)),
      raising  - умолчательный параметр (по умолчанию false), если
                 установлен в true, то при ошибках записи в файл
                 возникают исключения WRITE_ERROR, INVALID_FILEHANDLE,
                 INVALID_OPERATION, иначе выдаются сообщения об ошибке.
    Примечание: при записи строки в ее конец добавляется символ
                перевода строки - chr(10).

procedure GET_LINE(file integer, text out string, raising boolean default FALSE,
                  in_text integer default NULL,out_text integer default NULL) -
    считывает строку из файла, параметры :
      file - дескриптор открытого файла,
      text - прочитанный текст, если заданы in_text и out_text (по
             умолчанию не задаются), то при чтении производится_
             перекодировка из in_text в out_text, причем если
             входная кодировка попадает в список DEF_CR_ADD,
             например, DOS,KOI (in_text=DOSTEXT,KOITEXT),
             то из извлеченной строки text с конца удаляется символ
             перевода каретки (chr(13)),
      raising  - умолчательный параметр (по умолчанию false), если
                 установлен в true, то при ошибках чтения из файла
                 возникают исключения READ_ERROR, INVALID_FILEHANDLE,
                 INVALID_OPERATION, иначе выдаются сообщения об ошибке.
    При достижении конца файла возникает исключение rtl.NO_DATA_FOUND.
    Примечание: при чтении строка извлекается до первого вхождения_
                символа перевода строки -  chr(10).

function GET_LINE(file integer, text out string, raising boolean default FALSE,
                  in_text integer default NULL,out_text integer default NULL) -
    считывает строку из файла, возвращает true если строка считана,
    false - если достигнут конец файла.
    Примечание: параметры те же, что и для процедуры GET_LINE, только
                исключение NO_DATA_FOUND не поднимается при достижении
                конца файла, а возвращается false.

procedure CLOSE_ALL -
    закрывает все открытые через пакет STDIO файлы. Выдает ошибку,
    если не удалось закрыть какой-либо файл.

procedure FLUSH ( file     IN  integer,
                  raising  IN  boolean default FALSE ) -
    сбрасывает информацию из буфера в памяти на диск для указанного
    файла.

procedure FPUT ( file    IN integer,
                 buffer  IN string,
                 raising IN boolean default FALSE,
                 p_flush IN boolean default FALSE,
                 in_text  IN integer  default NULL,
                 out_text IN integer  default NULL ) -
    записывает текст из буфера buffer в файл file. Raising - как
    для PUT_LINE, p_flush указывает сбрасывать ли (если true)
    буфер на диск. Если заданы in_text и out_text (по умолчанию не задаются),
    то при записи производится перекодировка из in_text в out_text.

procedure PUTF ( file     IN integer,
                 format   IN string,
                 raising  IN boolean default FALSE,
                 in_text  IN integer  default NULL,
                 out_text IN integer  default NULL,
                 p_text1  IN string  default NULL,
                 p_text2  IN string  default NULL,
                 p_text3  IN string  default NULL,
                 p_text4  IN string  default NULL,
                 p_text5  IN string  default NULL ) -
    записывает в файл file текст p_text1,p_text2,p_text3,p_text4,
    p_text5, форматированный по строке формата format (наподобие
    сишной процедуры fprintf). Распознаются следующие элементы
    формата: %<цифра> - место для вставки строки p_text<цифра>,
    \t - символ табуляции, \n - перевод строки (WIN, UNIX - chr(10),
    DOS, KOI - chr(13)chr(10)). Полученный таким образом текст затем
    может быть преобразован в соответствии с указанными кодировками.
    Raising имеет то же значение, как и для PUT_LINE.

ПРИМЕЧАНИЕ: файловые операции используют буферизованный ввод-вывод,
            дополнительные функции описаны в разделе 7.


                4. Процедуры работы с буфером сессии (DBMS_OUTPUT).

procedure DISABLE_BUF - отключить вывод в буфер сессии.

procedure ENABLE_BUF ( p_size  IN integer default 300000,
                       p_clear IN boolean default TRUE ) -
    инициализирует буфер сессии размером p_size (SERVEROUTPUT ON
    SIZE p_size). Если p_size не указан, то по умолчанию инициализируется_
    буфер размером 300к. P_clear - флаг очистки буфера (по умолчанию
    буфер очищается).
    Для версий Oracle 10 и выше допускается указать размер буфера больше 
    1000000 байт, в этом случае фактически размер буфера будет неограничен.
function PUT_BUF ( p_text string, p_nl boolean default true,
                   p_expand boolean default false) return integer -
    помещает текст p_text в буфер сессии. 
    Если длина строки p_text превышает 255 символов (Oracle 9 и ниже) или 4000
    символов (Oracle 10 и выше), то p_text в буфер сессии помещается
    фрагментами, границей фрагмента считается символ перевода строки, но при
    этом максимальный размер  фрагмента - 255 или 4000 символов (в зависимости
    от версии Oracle).
    Параметр P_NL (значение по умолчанию - TRUE), действует, если размер p_text
    не превышает максимального размера фрагмента. Если P_NL установлен в true,
    то p_text записывается в буфер сессии как отдельный фрагмент, иначе - p_text
    записывается в буфер сессии как часть фрагмента (т.е. в дальнейшем
    к фрагменту можно добавить другие части, если суммарный размер частей
    фрагмента не превышает максимального размера фрагмента в 255 или 4000
    символов).
    Могут возникать исключения при работе с буфером сессии. Возвращает 
    количество записанных символов в буфер сессии. В случае переполнения буфера 
    сессии при значении параметра p_expand=false (по умолчанию), записанное
    значение может быть меньше исходного текста. При значении p_expand=true
    функция будет пытаться расширить буфер сессии, чтобы поместить
    туда весь текст (однако расширение возможно только до суммарного
    брутто-размера буфера сессии в 1000000 символов).

procedure WRITE_BUF ( p_text string, p_nl boolean default true ) -
    помещает текст p_text в буфер сессии. 
    Если длина строки p_text превышает 255 символов (Oracle 9 и ниже) или 4000
    символов (Oracle 10 и выше), то p_text в буфер сессии помещается
    фрагментами, границей фрагмента считается символ перевода строки, но при
    этом максимальный размер  фрагмента - 255 или 4000 символов (в зависимости
    от версии Oracle).
    Параметр P_NL (значение по умолчанию - TRUE), действует, если размер p_text
    не превышает максимального размера фрагмента. Если P_NL установлен в true,
    то p_text записывается в буфер сессии как отдельный фрагмент, иначе - p_text
    записывается в буфер сессии как часть фрагмента (т.е. в дальнейшем
    к фрагменту можно добавить другие части, если суммарный размер частей
    фрагмента не превышает максимального размера фрагмента в 255 или 4000
    символов).
    Могут возникать исключения при работе с буфером сессии.

procedure PUT_LINE_BUF(p_text string, p_nl boolean default TRUE) -
    помещает текст p_text в буфер сессии.     
    Если длина строки p_text превышает 255 символов (Oracle 9 и ниже) или 4000
    символов (Oracle 10 и выше), то p_text в буфер сессии помещается
    фрагментами, границей фрагмента считается символ перевода строки, но при
    этом максимальный размер  фрагмента - 255 или 4000 символов (в зависимости
    от версии Oracle).
    Параметр P_NL (значение по умолчанию - TRUE), действует, если размер p_text
    не превышает максимального размера фрагмента. Если P_NL установлен в true,
    то p_text записывается в буфер сессии как отдельный фрагмент, иначе - p_text
    записывается в буфер сессии как часть фрагмента (т.е. в дальнейшем
    к фрагменту можно добавить другие части, если суммарный размер частей
    фрагмента не превышает максимального размера фрагмента в 255 или 4000
    символов).
    Исключения при работе с буфером сессии игнорируются.

function GET_BUF ( p_text OUT string ) return integer -
    извлекает строку p_text из буфера сессии, возвращает 0 если строку
    удалось извлечь, иначе 1 если буфер пуст или выдает исключение при
    работе с буфером сессии.

function GET_LINE_BUF ( p_text OUT string ) return integer -
    извлекает строку p_text из буфера сессии, возвращает 0 если строку
    удалось извлечь, иначе 1 если буфер пуст (в случае возникновения
    исключения при работе с буфером сессии возвращает также 1).

function GET_BUF_TEXT return string -
    извлекает текст из буфера сессии.
    Функция извлекает текст из буфера сессии, пока он там есть, или
    его размер не превысит 32000 символов. Если данных в буфере
    сессии нет, то функция вернет пустую строку, если извлечено более
    32K символов, то очередная порция текста может быть получена
    последующим вызовом этой же функции.

procedure SET_SIZES( line_size   IN  integer default null,
                     buffer_size IN  integer default null ) -
    устанавливает умолчательные размеры длины строки файловых операций
    (line_size) и буфера сессии (buffer_size). Исходные значения длины
    строки и рамер буфера сессии определяются системными параметрами
    STDIO_LINE_SIZE и STDIO_BUFFER_SIZE, если же параметры не установлены,
    тогда они равны 32767 и 300000 соответственно.

procedure GET_SIZES( line_size   OUT integer,
                     buffer_size OUT integer ) -
    получает текущие настройки умолчательной длины строки файловых
    операций (line_size) и размера буфера сессии (buffer_size).

procedure GET_BUF_SIZES( cur_size OUT integer,
                         max_size OUT integer ) -
    получает текущие значения установленных текущего размера буфера
    сессии (cur_size) и максимального размера буфера сессии (max_size).

ПРИМЕЧАНИЕ: Как указано выше (см. комментарий к WRITE_BUF,PUT_BUF,PUT_LINE_BUF),
текст в буфер сессии помещается фрагментами.
Если фрагмент оканчивается символом перевода строки (chr(10)), то этот символ
вырезается из фрагмента. Если размер фрагмента равен максимальному (255 или 4000
символов, в зависимости от версии Oracle), то в помещаемый фрагмент добавляются
специальные "экранирующие" символы (строка chr(127)||chr(127)).
Функция чтения текста из буфера сессии (GET_BUF_TEXT) добавляет символ перевода
строки к очередному прочитанному фрагменту. Если размер фрагмента равен
максимальному и фрагмент оканчивается экранирующими символами, то символ
перевода строки не добавляется, а экранируюшие символы в конце фрагмента
вырезаются.

                5. Процедуры работы с PIPE (DBMS_PIPE).

procedure SETUP_PIPES(p_read  IN string  default NULL,
                      p_write IN string  default NULL,
                      p_time  IN integer default NULL,
                      p_size  IN integer default NULL)
    настраивает пакет STDIO, параметры :
        p_read  - имя PIPE для считывания информации (get_line_pipe),
                  значение по умолчанию 'STDIO$<session_id>';
        p_write - имя PIPE для записи информации (put_line_pipe),
                  значение по умолчанию 'STDIO$<session_id>';
        p_time  - тайм-аут, используемый по умолчанию put_line_pipe,
                  get_line_pipe, значение по умолчанию - 0;
        p_size  - размер PIPE, используемый по умолчанию put_line_pipe,
                  значение по умолчанию 32к.

procedure GET_PIPE_INFO( p_read  OUT string,  p_write OUT string,
                         p_time  OUT integer, p_size  OUT integer) -
    возвращает текущие настройки STDIO.

function PUT_PIPE( p_text IN string,
                   p_pipe IN string  default null,
                   p_time IN integer default null,
                   p_size IN integer default null,
                   p_nl   IN boolean default true,
                   p_expand  boolean default false) return integer -
    выводит текст p_text в PIPE-канал с именем p_pipe, тайм-аутом
    p_time, размером p_size, признаком перевода строк p_nl.
    Параметры p_pipe,p_time,p_size - умолчательные, если не заданы,
    то используются текущие настройки пакета STDIO.
    p_nl - умолчательный параметр (по умолчанию TRUE) - признак
    интерпретации символа перевода строки: если true, то каждая
    подстрока p_text, отделенная символом перевода строки chr(10),
    выводится в PIPE отдельным сообщением. Если размер p_text
    превышает 4000 символов, то строка помещается в PIPE фрагментами
    по 4000 символов (или меньше, если p_text содержит переводы строк).
    В случае переполнения пайпы при значении параметра p_expand=true
    функция будет пытаться расширить размер пайпы, чтобы поместить
    туда весь заданный текст (однако расширение возможно только до
    суммарного брутто-размера в 1M, т.е. 1048576 байт).
    Функция возвращает статус произведенной операции:
        0 - успешное действие,
        1 - произошел тайм-аут,
        2 - строка не поместилась во внутренний буфер PIPE,
        3 - операция была прервана,
        либо возникает исключение при работе с пайпами.

procedure PUT_LINE_PIPE(p_text IN string,
                        p_pipe IN string  default NULL,
                        p_time IN integer default NULL,
                        p_size IN integer default NULL,
                        p_nl   IN boolean default TRUE) -
    выводит текст p_text в PIPE-канал с именем p_pipe, тайм-аутом
    p_time, размером p_size, признаком перевода строк p_nl.
    Параметры p_pipe,p_time,p_size - умолчательные, если не заданы,
    то используются текущие настройки пакета STDIO.
    p_nl - умолчательный параметр (по умолчанию TRUE) - признак
    интерпретации символа перевода строки: если true, то каждая_
    подстрока p_text,отделенная символом перевода строки chr(10),
    выводится в PIPE отдельным сообщением. Если размер p_text
    превышает 4000 символов, то строка помещается в PIPE фрагментами
    максимальным размером по 4000 символов. Исключения при работе
    с пайпами игнорируются.

function GET_PIPE( p_text OUT string,
                   p_pipe IN  string  default null,
                   p_time IN  integer default null ) return integer -
    извлекает текст p_text из PIPE-канала p_pipe с тайм-аутом p_time.
    Извлекается только одна запись из пайпы, если она там есть,
    для получения следующей записи функцию нужно вызывать повторно.
    Параметры p_pipe,p_time - умолчательные, если не заданы,
    то используются текущие настройки пакета STDIO.
    Функция возвращает статус произведенной операции:
        0 - успешное действие,
        1 - произошел тайм-аут,
        2 - строка не поместилась во внутренний буфер PIPE,
        3 - операция была прервана,
        либо возникает исключение при работе с пайпами.

function GET_LINE_PIPE(p_text OUT string,
                       p_pipe IN  string  default NULL,
                       p_time IN  integer default NULL ) return integer -
    извлекает текст p_text из PIPE-канала p_pipe с тайм-аутом p_time.
    Извлекается только одна запись из пайпы, если она там есть,
    для получения следующей записи функцию нужно вызывать повторно.
    Параметры p_pipe,p_time - умолчательные, если не заданы,
    то используются текущие настройки пакета STDIO.
    Функция возвращает статус произведенной операции:
        0 - успешное действие,
        1 - произошел тайм-аут,
        2 - строка не поместилась во внутренний буфер PIPE,
        3 - операция была прервана,
       -1 - при возникновении исключения при работе с пайпами.

function GET_PIPE_TEXT( p_pipe string  default null,
                        p_time integer default 0) return string -
    извлекает текст из PIPE-канала p_pipe с тайм-аутом p_time.
    Параметры p_pipe,p_time - умолчательные, если не заданы,
    то используются текущие настройки пакета STDIO.
    Функция возвращает извлеченный текст. В отличие от get_pipe
    извлекает текст из заданной пайпы, пока он там есть, или
    его размер не превысит 28000 символов. Если данных в пайпе
    нет, то функция вернет пустую строку, если извлечено более
    28K символов, то очередная порция текста может быть получена
    последующим вызовом этой же функции. Функция исключения при
    работе с пайпами не перекрывает.

ПРИМЕЧАНИЕ: Как указано выше (см. комментарий к PUT_PIPE, PUT_LINE_PIPE), текст
в PIPE-канал помещается фрагментами.
Если фрагмент оканчивается символом перевода строки (chr(10)), то этот символ
вырезается из фрагмента. Если размер фрагмента равен максимальному (4000
символов), то в помещаемый фрагмент добавляются специальные "экранирующие"
символы (строка chr(127)||chr(127)).
Функция чтения текста из PIPE-канала (GET_PIPE_TEXT) добавляет символ перевода
строки к очередному прочитанному фрагменту. Если размер фрагмента равен
максимальному и фрагмент оканчивается экранирующими символами, то символ
перевода строки не добавляется, а экранируюшие символы в конце фрагмента
вырезаются.


                6. Процедуры работы с FORMON.

procedure FORMON_OPEN  - процедура открытия коннекта FORMON для_
    выполнения функций FORMON (file_list, move_file, delete_file).

procedure FORMON_CLOSE - процедура закрытия коннекта FORMON.

function FILE_LIST(location string) return string -
    возвращает список файлов из каталога location (имена файлов
    разделяются символом перевода строки chr(10)). Location может
    содержать маску для поиска (wildcard), отделенную от основного
    имени каталога тремя слэшами ('///').
    Location должен содержать полный путь от корневого каталога.

procedure MOVE_FILE(oldname string, newname string) -
    перемещает (переименовывает) файл с именем oldname в файл с
    именем newname (имена должны быть полными, включающими полный
    путь).

procedure DELETE_FILE(filename string) -
    удаляет файл с полным именем filename.

ПРИМЕЧАНИЕ: для работы функций FORMON необходимо, чтобы был запущен
            процесс FORMON, обрабатывающий запросы вышеописанных
            процедур.



                7. Процедуры работы с FIO (вместо FORMON).

                7.1. Сервисные функции.

procedure FORMON_OPEN;
procedure FIO_OPEN;
    инициализируют процесс поддержки файловых операций (FIO).

procedure FORMON_CLOSE;
procedure FIO_CLOSE;
    завершают работу с FIO.

function  GET_FIO_PID return integer;
    возвращает PID процесса, под которым функционирует FIO,
    если значение > 0, иначе означает ошибку инициализации FIO.

procedure QSORT (buf in out  string, p_char string default null, p_mode boolean default true);
    сортирует список элементов,
    buf - список для сортировки,
    p_char - символ-разделитель (символы) элементов в списке, по умолчанию
        символ перевода строки chr(10),
    p_mode - признак сортировки списка, true - по возрастанию, иначе - по убыванию.

function  GET_ENV (name in string) return string;
    возвращает значение переменной окружения name процесса FIO, возвращает пусто,
        если переменная окружения не определена.

function  PUT_ENV (name in string, value in string) return integer;
    уcтанавливает значение value переменной окружения name процесса FIO,
        возвращает длину value >=0, иначе код ошибки.

function ERROR_MESSAGE (error_number_i in integer) return string;
    возвращает строковое значение ошибки (которую возвращают функции FIO),
    error_number_i - код ошибки.

function GET_FILE_NAME ( file integer, p_files boolean default true ) return string;
    возвращает полное имя открытого файла или каталога(по open, f_open, fopen, opendir)
    file - дескриптор открытого файла или каталога,
    p_files - способ интерпретации дескриптора file (true - дескриптор файла,
        false - дескриптор каталога, null - поиск имени сначала в открытых файлах,
  а потом - в открытых каталогах).


                7.2. Работа с файловой системой.

function  FILE_LIST ( location IN string, dir_flag integer default 0,
                      p_sort boolean default null, p_chk boolean default false,
                      name_text integer default NULL
                    ) return string;
    возвращает список файлов, разделенных символом перевода строки chr(10),
    location - имя каталога на сервере, может содержать маску для поиска (wildcard),
        отделенную от основного имени каталога тремя слэшами ('///'),
    dir_flag - управление выводимым списком файлов (0,3 - все файлы и каталоги,
        1 - только файлы, 2 - только каталоги, 4,7 - доступные пользователю файлы и каталоги,
  5 - доступные файлы, 6 - доступные каталоги),
    p_sort - признак сортировки списка файлов по имени (true - по возрастанию,
        false - по убыванию, null - нет сортировки),
    p_chk - признак проверки доступа к каталогу location, false - по FIO_BASE_DIR,
        true - по FIO_ROOT_DIR (см. настройки FIO).
    name_text - кодировка имен файлов и каталогов, если не задана или
                пустая, тогда используется умолчательная кодировка
                имен файлов (см. set_def_text), если задана, тогда производится
                перекодировка как исходного каталога (location), так и результирующего
                списка.
    
     Ограничение: В случае если список имен файлов в указанном каталоге удовлетворяющих маске
		  превышает размер 32767, то выполнение функции завершится исключением
		  ORA-06502: PL/SQL: : буфер символьных строк слишком маленький ошибка числа или значения
     		  
		  Для получения списка файлов в этом случае можно воспользоваться функциями OPENDIR\READ_DIR.
		  
		  Пример:
		  
		  declare
                  hdir number;
                  p_dir varchar2(100) := '.\';

                  fname  varchar2(2000);
                  attrs varchar2(2000);
                  uowner varchar2(2000);
                  gowner varchar2(2000);
                  mdate varchar2(2000);
                  fsize varchar2(2000);

                  ret number;
                  begin
                    
                    hdir := stdio.opendir(p_dir, '*.*');
                    
                    if hdir < 0 then
                      raise_application_error(-20666, p_dir || ':' || utl_file.error_message(hdir));
                    end if;
                    
                     loop
                      ret := stdio.read_dir(hdir, fname, attrs, uowner, gowner, mdate, fsize);
                      exit when ret <=0;
                      
                      dbms_output.put_line(fname);
                     end loop; 
                     
                    if ret < 0 then
                      raise_application_error(-20666, p_dir || ':' || utl_file.error_message(ret));
                    end if;
                    
                  end;		
		  	

procedure MOVE_FILE ( old_name IN string,
                      new_name IN string, p_chk boolean default false,
                      name_text integer default NULL );
    переименовывает файлы,
    old_name - полное старое имя файла (включая путь),
    new_name - полное новое имя файла,
    p_chk - признак проверки доступа к каталогам в old_name и new_name,
        false - по FIO_BASE_DIR, true - по FIO_ROOT_DIR.
    name_text - кодировка имен файлов, если не задана или пустая, тогда
                используется умолчательная кодировка имен файлов (см. set_def_text).

procedure DELETE_FILE ( file_name IN string, p_chk boolean default false,
                        name_text integer default NULL );
    удаляет файл или пустой каталог,
    file_name - полное имя файла(включая путь) или пустого каталога,
    p_chk - признак проверки доступа к каталогу в file_name,
        false - по FIO_BASE_DIR, true - по FIO_ROOT_DIR.
    name_text - кодировка имени файла, если не задана или пустая, тогда
                используется умолчательная кодировка имен файлов (см. set_def_text).

function FMOVE (oldname_i in string, newname_i in string, p_chk boolean default true,
                name_text integer default NULL ) return integer;
    переименовывает файлы, возвращает 0 в случае успеха, иначе код ошибки < 0,
    oldname_i - полное старое имя файла (включая путь),
    newname_i - полное новое имя файла,
    p_chk - признак проверки доступа к каталогам в oldname_i и newname_i,
        false - по FIO_BASE_DIR, true - по FIO_ROOT_DIR,
    name_text - кодировка имен файлов, если не задана или пустая, тогда
                используется умолчательная кодировка имен файлов (см. set_def_text).

function FDELETE (filename_i in string, p_chk boolean default true,
                  name_text integer default NULL ) return integer;
    удаляет файл, возвращает 0 в случае успеха, иначе код ошибки < 0,
    filename_i - полное имя файла (включая путь),
    p_chk - признак проверки доступа к каталогу в filename_i,
        false - по FIO_BASE_DIR, true - по FIO_ROOT_DIR,
    name_text - кодировка имени файла, если не задана или пустая, тогда
                используется умолчательная кодировка имен файлов (см. set_def_text).

function MKDIR (name_i in string, mode_i in integer, p_chk boolean default true,
                name_text integer default NULL ) return integer;
    создает новый каталог, возвращает 0 в случае успеха, иначе код ошибки < 0,
    создание каталогов доступно, если в профиле пользователя задана настройка
    FIO_MAKE_DIR='YES', параметры:
    name_i - имя каталога,
    mode_i - флаги доступа к каталогу (биты доступа - rwxrwxrwx),
    p_chk - признак проверки доступа к каталогу в name_i,
        false - по FIO_BASE_DIR, true - по FIO_ROOT_DIR,
    name_text - кодировка имени каталога, если не задана или пустая, тогда
                используется умолчательная кодировка имен файлов (см. set_def_text).

function FLIST (dirname_i in string, dirflag_i in integer, p_sort boolean default null,
                name_text integer default NULL ) return string;
    возвращает список файлов, разделенных символом перевода строки chr(10),
    dirname_i - имя каталога на сервере, может содержать маску для поиска (wildcard),
        отделенную от основного имени каталога тремя слэшами ('///'),
  доступ к каталогу проверяется только по FIO_ROOT_DIR.
    dirflag_i - управление выводимым списком файлов (0,3 - все файлы и каталоги,
        1 - только файлы, 2 - только каталоги, 4,7 - доступные пользователю файлы и каталоги,
  5 - доступные файлы, 6 - доступные каталоги),
    p_sort - признак сортировки списка файлов по имени (true - по возрастанию,
        false - по убыванию, null - нет сортировки),
    p_chk - признак проверки доступа к каталогу location, false - по FIO_BASE_DIR,
    name_text - кодировка имен файлов и каталогов, если не задана или
                пустая, тогда используется умолчательная кодировка
                имен файлов (см. set_def_text), если задана, тогда производится
                перекодировка как исходного каталога (dirname_i), так и результирующего
                списка.

function FLIST (dirname_i in string, dirflag_i in integer, filelist_o in out  string, p_sort boolean default null, p_chk boolean default true,
                name_text integer default NULL ) return integer;
    возвращает количество файлов в указанном каталоге >= 0, иначе код ошибки,
    dirname_i - имя каталога на сервере, может содержать маску для поиска (wildcard),
        отделенную от основного имени каталога тремя слэшами ('///'),
    dirflag_i - управление выводимым списком файлов (0,3 - все файлы и каталоги,
        1 - только файлы, 2 - только каталоги, 4,7 - доступные пользователю файлы и каталоги,
  5 - доступные файлы, 6 - доступные каталоги),
    filelist_o - результат - список файлов, разделенных символом перевода строки chr(10),
    p_sort - признак сортировки списка файлов по имени (true - по возрастанию,
        false - по убыванию, null - нет сортировки),
    p_chk - признак проверки доступа к каталогу dirname_i, false - по FIO_BASE_DIR,
        true - по FIO_ROOT_DIR (см. настройки FIO),
    name_text - кодировка имен файлов и каталогов, если не задана или
                пустая, тогда используется умолчательная кодировка
                имен файлов (см. set_def_text), если задана, тогда производится
                перекодировка как исходного каталога (dirname_i), так и результирующего
                списка.

function F_COPY ( oldname string,
                  newname string,
                  fsize   in out  string,
                  p_chk   boolean default false,
                  p_write boolean default true,
                  name_text integer default NULL ) return integer;
    копирует файл, возвращает 0 в случае успеха и количество записанных байт
    в параметре fsize, иначе код ошибки < 0 (32-битная версия библиотеки не сможет
    скопировать файл более 2147483647 байт, а 64-битная версия может),
    oldname - полное имя копируемого файла,
    newname - полное новое имя файла,
    fsize - количество записанных байт в случае успешного выполнения функции
            (фактически размер исходного файла),
    p_chk - признак проверки доступа к каталогам в oldname и newname,
        false - по FIO_BASE_DIR, true - по FIO_ROOT_DIR,
    p_write - признак перезаписывания, true - файл newname перезаписывается,
        false - файл newname дозаписыватся данными из oldname,
    name_text - кодировка имен файлов, если не задана или пустая, тогда
                используется умолчательная кодировка имен файлов (см. set_def_text).

function F_COPY ( oldname string,
                  newname string,
                  p_chk   boolean default false,
                  p_write boolean default true,
                  name_text integer default NULL ) return integer;
function F_COPYN( oldname string,
                  newname string,
                  p_chk   boolean default false,
                  p_write boolean default true,
                  name_text integer default NULL ) return number;
    копируют файл, возвращают количество записанных байт >=0 в случае успеха,
    иначе код ошибки < 0 (32-битная версия библиотеки не сможет скопировать
    файл более 2147483647 байт; 64-битная версия может - причем F_COPYN вернет
    действительный размер, а F_COPY вернет 2147483647 для любых размеров,
    превышающих 2147483647),
    oldname - полное имя копируемого файла,
    newname - полное новое имя файла,
    p_chk - признак проверки доступа к каталогам в oldname и newname,
        false - по FIO_BASE_DIR, true - по FIO_ROOT_DIR,
    p_write - признак перезаписывания, true - файл newname перезаписывается,
        false - файл newname дозаписыватся данными из oldname,
    name_text - кодировка имен файлов, если не задана или пустая, тогда
                используется умолчательная кодировка имен файлов (см. set_def_text).

function F_INFO( name   string,
                 attrs  in out  string,
                 uowner in out  string,
                 gowner in out  string,
                 mdate  in out  string,
                 fsize  in out  integer,
                 p_chk  boolean default false,
                 name_text integer default NULL
               ) return integer;
function F_INFO( name   string,
                 attrs  in out  string,
                 uowner in out  string,
                 gowner in out  string,
                 mdate  in out  string,
                 fsize  in out  string,
                 p_chk  boolean default false,
                 name_text integer default NULL
               ) return integer;
function FINFO ( name   string,
                 attrs  in out  string,
                 uowner in out  string,
                 gowner in out  string,
                 mdate  in out  string,
                 fsize  in out  number,
                 p_chk  boolean default false,
                 name_text integer default NULL
               ) return integer;
    возвращает информацию о файле по его имени, возвращает 0 в случае успеха,
        иначе код ошибки < 0, 
    name - полное имя файла,
    attrs  - атрибуты файла в формате 'drwxrwxrwx' (если какой-либо флаг не установлен,
        то вместо него будет символ '-'),
    uowner - пользователь-владелец файла,
    gowner - группа владельца файла,
    mdate  - дата модификации файла в формате constant.DATE_FORMAT,
    fsize  - размер файла в байтах, по этому параметру функция имеет три модификации,
             fsize - integer - целое 32-битовое (этот вариант не может возвращать размер
             файла больше 2GB, при превышении размера 2GB 32-битовая версия библиотеки либо
             вернет ошибку, либо неадекватное значение; 64-битная версия библиотеки
             возвращает значение -1); fsize - типа number или string - возвращается
             реальный размер файла, в т.ч. для значений больше 2GB;
    p_chk - признак проверки доступа к каталогам в name,
        false - по FIO_BASE_DIR, true - по FIO_ROOT_DIR,
    name_text - кодировка имени файла/каталога, если не задана или пустая, тогда
                используется умолчательная кодировка имен файлов (см. set_def_text).

function RUN(ev_i in string, a0_i in string := NULL,
             a1_i in string := NULL,
             a2_i in string := NULL,
             a3_i in string := NULL,
             a4_i in string := NULL,
             a5_i in string := NULL,
             a6_i in string := NULL,
             a7_i in string := NULL,
             a8_i in string := NULL,
             a9_i in string := NULL,
             p_env  boolean default true) return integer;
    выполняет команду (из списка доступных FIO), возвращает код выполнения команды >= 0
    в случае успеха, иначе код ошибки < 0,
    ev_i - код команды (или сама команда, содержащая шаблоны '%' для параметров),
    a0_i,...a9_i - параметры команды,
    p_env - признак интерпретации ev_i, true - код команды (переменная окружения
        процесса FIO - FIO_%_CMD, если префикс FIO_ и суффикс _CMD отсутствуют,
  то они добавляются автоматически), false - сама команда.
    На большинстве unix-платформ код успешного выполнения равен коду возврата
    исполняемого модуля, умноженному на 256, на WINDOWS платформе код возврата
    передается непосредственно в коде выполнения.

function LHA (clinum in string) return integer;
    выполняет LHA команду, возвращает >= 0 в случае успеха, иначе код ошибки < 0,
    clinum - параметр команды.

function ZIP (arcname in string, dirname in string) return integer;
    выполняет ZIP команду, возвращает >= 0 в случае успеха, иначе код ошибки < 0,
    arcname, dirname - параметры команды.


    7.3. Процедуры, работающие через файл-handles
                     (небуферизованный файловый ввод-вывод).

function FOPEN (name_i in string, flag_i in integer, p_chk boolean default true,
                name_text integer default NULL ) return integer;
    открывает файл-handle, возвращает дескриптор открытого файла > 0, иначе код ошибки,
    name_i - полное имя файла (включая путь),
    flag_i - режим открытия файла (0 - чтение, 1 - запись, 2 - чтение-запись),
    p_chk - признак проверки доступа, false - по FIO_BASE_DIR, true - по FIO_ROOT_DIR,
    name_text - кодировка имени файла, если не задана или пустая, тогда
                используется умолчательная кодировка имен файлов (см. set_def_text).

function FCREATE (name_i in string, mode_i in integer, p_chk boolean default true,
                  name_text integer default NULL ) return integer;
    создает файл-handle, возвращает дескриптор открытого файла > 0, иначе код ошибки,
    name_i - полное имя файла (включая путь),
    flag_i - режим открытия файла (0 - чтение, 1 - запись, 2 - чтение-запись),
    p_chk - признак проверки доступа, false - по FIO_BASE_DIR, true - по FIO_ROOT_DIR,
    name_text - кодировка имени файла, если не задана или пустая, тогда
                используется умолчательная кодировка имен файлов (см. set_def_text).

function FCLOSE (fh_i in integer) return integer;
    закрывает файл-handle, возвращает 0 в случае успеха, иначе код ошибки < 0,
    fh_i - дескриптор файла (handle).

function FSEEK (fh_i in integer, pos in out string, off_i in integer, how_i in integer) return integer;
    позиционирование в файл-handle, возвращает 0 в случае успеха и значение
    новой позиции в параметре pos, иначе код ошибки (32-битная версия библиотеки
    не сможет позиционироваться далее позиции 2147483647, а 64-битная версия может),
    fh_i - дескриптор файла (handle),
    pos  - возвращается установленное значение позиции в файле при успешном
           выполнении функции (на некоторых платформах позиция в файле может быть
           установлена и за пределами текущего размера файла без генерации
           каких-либо ошибок),
    off_i - смещение,
    how_i - базовое смещение (0 - начало файла, 1 - текущая позиция, 2 - конец файла).
function FSEEK (fh_i in integer, off_i in integer, how_i in integer) return integer;
function FSEEKN(fh_i in integer, off_i in integer, how_i in integer) return number;
    позиционирование в файл-handle, возвращают новую позицию >= 0,
    иначе код ошибки (32-битная версия библиотеки не сможет позиционироваться
    далее позиции 2147483647; 64-битная версия может - причем FSEEKN вернет
    действительную позицию, а FSEEK вернет 2147483647 для любых позиций,
    превышающих 2147483647),
    fh_i - дескриптор файла (handle),
    off_i - смещение,
    how_i - базовое смещение (0 - начало файла, 1 - текущая позиция, 2 - конец файла).

function FREAD (fh_i in integer, sz_i in integer, bf_o in out  raw) return integer;
    чтение из файл-handle, возвращает количество прочитанных байт >= 0, иначе код ошибки,
    fh_i - дескриптор файла (handle),
    sz_i - количество байт, которое следует прочитать,
    bf_o - буфер для прочитанных данных.

function FWRITE (fh_i in integer, bf_i in raw, sz_i in integer default 0) return integer;
    запись в файл-handle, возвращает количество записанных байт >= 0, иначе код ошибки,
    fh_i - дескриптор файла (handle),
    bf_i - буфер c записываемыми данными,
    sz_i - количество байт, которое следует записать (0 - записать весь буфер).


    7.4. Буферизованный файловый ввод-вывод.

function  F_OPEN(filename  in string,
                 open_mode in string,
                 p_chk boolean default false,
                 name_text integer default NULL ) return integer;
    открывает файл, возвращает дескриптор открытого файла > 0, иначе код ошибки,
    filename - полное имя файла (включая путь),
    open_mode - режим открытия файла ('r' - чтение, 'w' - запись, 'a' - запись в конец,
        'r+' 'w+' 'a+' - чтение-запись),
    p_chk - признак проверки доступа, false - по FIO_BASE_DIR, true - по FIO_ROOT_DIR,
    name_text - кодировка имени файла, если не задана или пустая, тогда
                используется умолчательная кодировка имен файлов (см. set_def_text).

function  F_DOPEN( handle in integer, open_mode in string ) return integer;
    открывает буферизованный файл из небуферизованного файл-handle,
        возвращает дескриптор открытого файла > 0, иначе код ошибки,
    open_mode - режим открытия файла ('r' - чтение, 'w' - запись, 'a' - запись в конец,
        'r+' 'w+' 'a+' - чтение-запись).

function  F_CLOSE( file IN OUT  integer  ) return integer;
    закрывает файл, возвращает 0 в случае успеха, иначе код ошибки < 0,
    file - дескриптор открытого файла.

procedure F_CLOSEALL;
    закрывает все открытые буферизованные файлы (открытые по open, f_open),
    выдает ошибку, если не удалось закрыть какой-либо файл.

function  F_FLUSH( file integer  ) return integer;
    сбрасывает буфера файла на диск, возвращает 0 в случае успеха, иначе код ошибки < 0,
    file - дескриптор открытого файла.

function  F_SEEK (file integer, pos in out string, off_i integer, how_i integer default 0) return integer;
    позиционирование в файле, возвращает 0 в случае успеха и значение
    новой позиции в параметре pos, иначе код ошибки (32-битная версия библиотеки
    не сможет позиционироваться далее позиции 2147483647, а 64-битная версия может),
    file - дескриптор открытого файла,
    pos  - возвращается установленное значение позиции в файле при успешном
           выполнении функции (на некоторых платформах позиция в файле может быть
           установлена и за пределами текущего размера файла без генерации
           каких-либо ошибок),
    off_i - смещение,
    how_i - базовое смещение (0 - начало файла, 1 - текущая позиция, 2 - конец файла).

function  F_SEEK (file integer, off_i integer, how_i integer default 0) return integer;
function  F_SEEKN(file integer, off_i integer, how_i integer default 0) return number;
    позиционирование в файле, возвращают новую позицию >= 0,
    иначе код ошибки (32-битная версия библиотеки не сможет позиционироваться
    далее позиции 2147483647; 64-битная версия может - причем F_SEEKN вернет
    действительную позицию, а F_SEEK вернет 2147483647 для любых позиций,
    превышающих 2147483647),
    file - дескриптор открытого файла,
    off_i - смещение,
    how_i - базовое смещение (0 - начало файла, 1 - текущая позиция, 2 - конец файла).

function F_TELL (file integer) return number;
    возвращает текущую позицию-указатель в файле (фактически эквивалент
    F_SEEKN(file,0,1) ),
    file - дескриптор открытого файла.

function  F_READ(file integer, bf_o in out  raw, sz_i integer) return integer;
    чтение из файла, возвращает количество прочитанных байт >= 0, иначе код ошибки,
    file - дескриптор открытого файла,
    sz_i - количество байт, которое следует прочитать,
    bf_o - буфер для прочитанных данных.

function  F_WRITE(file integer, bf_i in raw, sz_i integer default 0) return integer;
    запись в файл, возвращает количество записанных байт >= 0, иначе код ошибки,
    file - дескриптор открытого файла,
    bf_i - буфер c записываемыми данными,
    sz_i - количество байт, которое следует записать (0 - записать весь буфер).

function  READ_STR(file integer, str in out  string,
                   in_text  integer  default NULL,
                   out_text integer  default NULL,
                   sz_i integer default 0) return integer;
    считывает строку из файла, возвращает количество прочитанных байт >= 0, иначе код ошибки,
    file - дескриптор открытого файла,
    str - прочитанный текст, если заданы in_text и out_text (по
        умолчанию не задаются), то при чтении производится_
        перекодировка из in_text в out_text,
    sz_i - количество байт, которое следует прочитать, причем если задано значение 0,
        то считывание происходит до первого символа перевода строки chr(10)
        (при этом если входная кодировка попадает в список DEF_CR_ADD,
        например, DOS,KOI (in_text=DOSTEXT,KOITEXT),то из извлеченной строки str
  с конца удаляется символ перевода каретки chr(13)), если задано значение > 0,
  то считывается указанное количество байт безотносительно к символу chr(10) и
  из полученной строки ничего не удаляется.

function  WRITE_STR(file integer, str string,
                    in_text  integer  default NULL,
                    out_text integer  default NULL,
                    p_nl boolean default true) return integer;
    записывает строку в файл, возвращает количество записанных байт >= 0, иначе код ошибки,
    file - дескриптор открытого файла,
    str - записываемый текст, если заданы in_text и out_text (по
        умолчанию не задаются), то при записи производится перекодировка
  из in_text в out_text,
    p_nl - признак добавления перевода строки, false - ничего не добавляется,
        true - при записи строки в ее конец добавляется символ перевода строки chr(10),
  при этом если выходная кодировка попадает в список DEF_CR_ADD,
        например, DOS,KOI (out_text=DOSTEXT,KOITEXT), то в конец строки text
  добавляется символ перевода каретки chr(13) перед символом chr(10).

function F_TRUNCATE ( file integer, p_size integer default null ) return integer;
    усекает файл до заданного размера в p_size, возвращает новый размер файла >= 0
    в случае успеха, иначе код ошибки < 0,
    file - дескриптор открытого файла (для успешного выполнения функции файл должен
           допускать режим записи),
    p_size - новый размер файла (0 или пустое значение усекают файл полностью;
             новый размер может превышать текущий размер файла, тогда файл расширяется
             нулями до нового значения).

    
    7.5. Функции работы с каталогами.

function  OPENDIR( dirname  string, mask string default null,
                   dir_flag integer default 0, p_chk boolean default false,
                   name_text integer default NULL ) return integer;
    открывает каталог, возвращает дескриптор открытого каталога > 0, иначе код ошибки,
    dirname - имя каталога на сервере,
    mask - маска для поиска (wildcard), если не задана, выводятся все файлы каталога,
    dir_flag - управление выводимым списком файлов (0,3 - все файлы и каталоги,
        1 - только файлы, 2 - только каталоги, 4,7 - доступные пользователю файлы и каталоги,
  5 - доступные файлы, 6 - доступные каталоги),
    p_chk - признак проверки доступа к каталогу dirname, false - по FIO_BASE_DIR,
        true - по FIO_ROOT_DIR (см. настройки FIO).
    name_text - кодировка имени каталога, если не задана или пустая, тогда
                используется умолчательная кодировка имен файлов (см. set_def_text).

function  CLOSEDIR(dir  in out integer ) return integer;
    закрывает каталог, открытый по opendir.
    возвращает 0, иначе код ошибки<0,
    dir - дескриптор каталога.

function  RESETDIR(dir  integer ) return integer;
    сбрасывает указатель чтения каталога () на начало.
    возвращает 0, иначе код ошибки<0,
    dir - дескриптор каталога.

function  READDIR( dir    integer,
                   name   in out string,
                   attrs  in out string,
                   uowner in out string,
                   gowner in out string,
                   mdate  in out string,
                   fsize  in out integer
                  ) return integer;
function  READDIR( dir    integer,
                   name   in out string,
                   attrs  in out string,
                   uowner in out string,
                   gowner in out string,
                   mdate  in out string,
                   fsize  in out string
                  ) return integer;
function  READ_DIR(dir    integer,
                   name   in out string,
                   attrs  in out string,
                   uowner in out string,
                   gowner in out string,
                   mdate  in out string,
                   fsize  in out number
                  ) return integer;
    считывает элементы каталога, открытого по opendir,
    возвращает порядковый номер элемента каталога > 0,
    возвращает 0, если элементов больше нет, иначе код ошибки < 0,
    dir - дескриптор каталога,
    выходная информация об элементе каталога:
    name - имя файла (если при открытии каталога была задана кодировка имен файлов
           явно или использована умолчательная кодировка, то возвращаемое имя
           перекодируется в соответствии с заданной кодировкой),
    attrs  - атрибуты файла в формате 'drwxrwxrwx' (если какой-либо флаг не установлен,
        то вместо него будет символ '-'),
    uowner - пользователь-владелец файла,
    gowner - группа владельца файла,
    mdate  - дата модификации файла в формате constant.DATE_FORMAT,
    fsize  - размер файла в байтах, по этому параметру функция имеет три модификации,
             fsize - integer - целое 32-битовое (этот вариант не может возвращать размер
             файла больше 2GB, при превышении размера 2GB 32-битовая версия библиотеки либо
             вернет ошибку, либо неадекватное значение; 64-битная версия библиотеки
             возвращает значение -1); fsize - типа number или string - возвращается
             реальный размер файла, в т.ч. для значений больше 2GB.

ПРИМЕЧАНИЯ.
    1. Все функции FIO, которые возвращают число, в случае успеха возвращают
    число >= 0, иначе код ошибки, текст которой можно получить с помощью функции
    error_message.
    2. Если процесс FIO не был инициализирован, то все процедуры и функции будут
    блокированы, а функции будут возвращать всегда пустое значение.
    3. Ошибки инициализации FIO (значение get_fio_pid после неуспешной инициализации
    formon_open или fio_open):
    -1 - не задана идентификационная строка пользовательской сессии Oracle,
    -2 - невозможно открыть файл журнала FIO при уровне отладки > 0,
    -3 - не задан или недоступен каталог FIO_ROOT_DIR,
    -4 - не задан список доступных каталогов FIO_BASE_DIR,
    -5 - не задан список доступных команд FIO_%_СMD,
    -6 - ошибка инициализации окружения процесса FIO (например, мало памяти).


                8. Процедуры работы с системными настройками (SETTINGS).

function  GET_SETTING(p_name string) return string deterministic;
    возвращает значение системной настройки с именем p_name,
    если настройка не задана, то возвращает пусто
    (всегда выполняет select по settings).

function  SETTING(p_name string) return string deterministic;
    возвращает значение системной настройки с именем p_name,
    если настройка не задана, то возвращает пусто (кэширует значения настроек).

function  NUM_SET(p_name string) return number deterministic;
    возвращает значение числовой системной настройки с именем p_name,
    если настройка не задана или не может быть преобразована к числу,
    то возвращает пусто (кэширует значения настроек).

procedure PUT_SETTING(p_name string, p_value   string,
                  p_description string default null);
    устанавливает значение p_value системной настройки с именем p_name.
    Если заданное значение p_value пустое, то настройка удаляется.
    Если задан параметр p_description задан непустым значением, то устанавливается
    описание настройки, указанное в p_descrition. При установке значений
    системных настроек происходит рассылка события с номером 10 на обновление
    кэшированных значений в других пользовательских сессиях (в случае, если
    текущая сессия зарегистрирована).

procedure INIT_SETTING(p_name string default null);
    сбрасывает кэш системных настроек. Если задано пустое значение настройки в p_name,
    то сбрасывается весь кэш, иначе сбрасывается значение только указанной настройки


                9. Процедуры работы с настройками профилей (PROFILES).

function  GET_PROFILE(p_user string default null) return string deterministic;
    возвращает имя профиля настроек пользователя, заданного в p_user. Если
    p_user не задано или задано пустым, то возвращает имя профиля пользователя
    текущей сессии.

function  GET_RESOURCE_VALUE(p_profile string, p_name string) return string deterministic;
    возвращает значение настройки с именем p_name из профиля p_profile (если
    профиль задан пустым, тогда используется профиль текущего пользователя),
    если настройка не задана, то возвращает пусто (всегда выполняет select по profiles).

function  GET_RESOURCE(p_profile string, p_name string) return string deterministic;
    возвращает значение настройки с именем p_name из профиля p_profile (если
    профиль задан пустым, тогда используется профиль текущего пользователя),
    если настройка не задана, то возвращает пусто (кэширует значения настроек).

procedure SET_RESOURCE(p_profile string, p_name string,
                   p_value   string, p_description string default null);
    устанавливает значение p_value настройки с именем p_name в профиле p_profile
    (если профиль задан пустым, тогда используется профиль текущего пользователя).
    Если заданное значение p_value пустое, то настройка удаляется.
    Если задан параметр p_description задан непустым значением, то устанавливается
    описание настройки, указанное в p_descrition. При установке значений
    настроек профилей происходит рассылка события с номером 11 на обновление
    кэшированных значений в других пользовательских сессиях (в случае, если
    текущая сессия зарегистрирована).

procedure INIT_RESOURCE(p_resource string default null);
    сбрасывает кэш настроек профилей. Если задано пустое значение p_resource,
    то сбрасывается весь кэш, иначе сбрасывается значение только указанной
    настройки (p_resource должен содержать имя профиля и имя настройки,
    разделенные точкой).

procedure INIT;
    инициализация пакета STDIO. Сбрасывает все текущие установки и инициализирует
    умолчательные значения. Также закрывает все открытые файлы и закрывает
    инициализацию fio.


                10. Настройки пакета STDIO.

DEF_CR_ADD
    Кодировки, при записи/чтении (в файловых операциях) которых
    добавляется/удаляется символ перевода строки - chr(13)
    Если не заданы, то принимается значение 'DOS,KOI'.
DEF_SLASH
    Разделитель имен каталогов на сервере.
    Если не задан, то принимается значение '/'.
DEF_TEXT
    Умолчательная кодировка для файловых операций.
    Если не задана, то принимается значение 'UNX'.
STDIO_BUFFER_SIZE
    Умолчательный размер буфера сессии (в байтах) для STDIO.
    Если не задан, то принимается значение STDIOBUFFERSIZE (300000).
STDIO_LINE_SIZE
    Умолчательная длина строки для файловых операций STDIO.
    Если не задана, то принимается значение STDIOLINESIZE (32767).
STDIO_FILE_NAME_TEXT
    Умолчательная кодировка имен файлов и каталогов сервера.
    Если не задана, то принимается значение умолчательной кодировки
    файловых операций (DEF_TEXT).

